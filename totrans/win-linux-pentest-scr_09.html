<html><head></head><body>
<div id="sbo-rt-content"><div id="_idContainer246">
<h1 id="_idParaDest-206"><em class="italic"><a id="_idTextAnchor205"/>Chapter 11</em>: Shellcoding – Bypassing Protections</h1>
<p>When I’m in a conversation with friends and family about airport security, a quip I often hear is <em class="italic">maybe we should just ban the passengers</em>. Though this is obviously facetious, let’s think about it for a moment—no matter what we do to screen everyone walking onto an airplane, we have to allow at least some people through the gates, particularly the pilots. There’s a clear divide between the malicious outsider with no good intention and the trusted insider who, by virtue of their role, must be given the necessary access to get some work done. Let’s think of the malicious outsiders trying to get on the plane as shellcode, and the trusted pilot who runs the show as a legitimate native binary. With perfect security screenings guaranteeing that no malicious individual can walk onto a plane, you will still have to trust that the pilot isn’t corrupted by an outside influence; that is, their power is being leveraged to execute a malicious deed.</p>
<p>Welcome to the concept of <strong class="bold">return-oriented programming</strong> (<strong class="bold">ROP</strong>), where the world we live in is a paradise in which no shellcode can be injected and executed, but we’ve figured out how to leverage the code that’s already there to do our dirty work. We’re going to learn how combining the density of the x86 instruction set with a good old-fashioned buffer vulnerability in a program allows us to construct almost any arbitrary functionality. We’ll take a break from injecting bad code and learn how to turn the good code against itself.</p>
<p>In this chapter, we will cover the following topics:</p>
<ul>
<li>Understanding the core defense concepts, such as <strong class="bold">data execution prevention</strong> (<strong class="bold">DEP</strong>) and <strong class="bold">address space layout randomization</strong> (<strong class="bold">ASLR</strong>)</li>
<li>Learning how to examine machine code and memory to identify instructions that we can leverage for our purposes, called <strong class="bold">gadgets</strong></li>
<li>Understanding the different types of ROP-based attacks</li>
<li>Exploring the tools used by hackers to pull off ROP attacks</li>
<li>Writing and attacking a vulnerable C program</li>
</ul>
<h1 id="_idParaDest-207"><a id="_idTextAnchor206"/>Technical requirements</h1>
<p>For ROP, you will require the following:</p>
<ul>
<li>32-bit Kali Linux 2021.3</li>
<li>ROPgadget</li>
</ul>
<h1 id="_idParaDest-208"><a id="_idTextAnchor207"/>DEP and ASLR – the intentional and the unavoidable</h1>
<p>So far, we’ve <a id="_idIndexMarker797"/>only mentioned these concepts in passing: DEP (which is also called NX for no-execute) and ASLR. I’m afraid we can’t put<a id="_idIndexMarker798"/> them off forever. I think I hear a couple of hackers at the back saying, <em class="italic">good! It took the impact out of the demonstrations when we had to disable basic protection to make the attack work</em>. Fair enough. When we introduced a basic buffer overflow in <a href="B17616_10_Final_VK_ePub.xhtml#_idTextAnchor187"><em class="italic">Chapter 10</em></a>, <em class="italic">Shellcoding – The Stack</em>, we explicitly disabled ASLR. (To be fair, Windows 7 comes out of the box like that.) This is all by design, though—we can’t understand the core concept without, first, taking a step back. These protection mechanisms are <em class="italic">responses</em> to the attacks we’ve demonstrated. But look at me, going off on a tangent again without defining these simple concepts.</p>
<h2 id="_idParaDest-209"><a id="_idTextAnchor208"/>Understanding DEP</h2>
<p>Do you remember where we stuff our shellcode? The answer is inside the stack or the heap, which is memory set aside for a thread of execution. When a function is running, space is allocated for variables and other data needed to get the work done; in other words, these are areas that are not intended to contain executable code. Picking a spot in memory to store a number but then later being told, <em class="italic">hey, remember that spot in memory? Let’s execute whatever’s sitting there</em>, should be suspicious. But don’t forget that processors are incredible, lightning-fast, and dumb. They will do what they’re told. This simple design of executing whatever is sitting at the location pointed to by the instruction pointer is what the shellcoding hacker exploits.</p>
<p>Enter DEP. The <a id="_idIndexMarker799"/>basic premise of DEP is to monitor whether the location that the instruction pointer is referencing has been explicitly marked as executable. If it isn’t, an access violation occurs. Windows has two types of DEP—<em class="italic">software-enforced</em> and <em class="italic">hardware-enforced</em>. The following screenshot shows what the DEP <a id="_idIndexMarker800"/>settings look like on the Windows interface:</p>
<div>
<div class="IMG---Figure" id="_idContainer228">
<img alt="Figure 11.1 – The DEP settings in Windows " height="416" src="image/Figure_11.01_B17616.jpg" width="414"/>
</div>
</div>
<p class="figure-caption">Figure 11.1 – The DEP settings in Windows</p>
<p>Software-enforced DEP<a id="_idIndexMarker801"/> operates at the higher levels of the OS, and hence, it is available on any machine that can run Windows and can protect against any attempts to ride on exception handling mechanisms. Hardware-enforced DEP<a id="_idIndexMarker802"/> uses the processor’s <strong class="bold">Execute Disable</strong> (<strong class="bold">XD</strong>) bit to mark memory locations <a id="_idIndexMarker803"/>as non-executable. Let’s take a look at the distinction between software-enforced and hardware-enforced:</p>
<div>
<div class="IMG---Figure" id="_idContainer229">
<img alt="Figure 11.2 – Two kinds of DEP: software and hardware " height="738" src="image/Figure_11.02_B17616.jpg" width="1027"/>
</div>
</div>
<p class="figure-caption">Figure 11.2 – Two kinds of DEP: software and hardware</p>
<p>So, how does this affect us as wily hackers? The whole trick is allocating memory for our code, which the program is treating like an ordinary variable. Meanwhile, we’re hoping the processor will take our word for it that the flow of execution is intended to jump to the instruction pointer address. First, let’s take a look at the randomization of locations in memory.</p>
<h2 id="_idParaDest-210"><a id="_idTextAnchor209"/>Understanding ASLR</h2>
<p>Take a stroll back down memory lane to when we worked on the stack overflow <a id="_idIndexMarker804"/>attacks. We found the vulnerable <strong class="source-inline">strcpy()</strong> function in our code, we stuffed the buffer with nonsense characters and deliberately overflowed it, and we checked our debugger and found that EIP had been overwritten with our nonsense. With careful payload crafting, we could find the precise location in memory where we needed to place the pointer to our NOP sled to, ultimately, result in the execution of shellcode. Now, recall that we used gdb’s examine (<strong class="source-inline">x</strong>) tool to identify the exact location in memory where the EIP lies. Therefore, we could map out the stack and <em class="italic">reliably</em> land on top of that instruction pointer with each run of the process.</p>
<p>Note that I emphasized “reliably.” Modern operating systems such as Windows allow for multiple programs to be open at once, and they all have massive amounts of addressable memory available to them—and by massive, I mean more than can be physically fit in a piece of RAM. Part of the operating system’s job is to figure out which portions of memory are less important so that they can be stored on the hard drive and brought into play via paging as needed. So, the program sees a large continuous block of memory space that is actually <em class="italic">virtual</em>, and the memory management unit manages the layer of abstraction that hides the physical reality behind the curtain:</p>
<div>
<div class="IMG---Figure" id="_idContainer230">
<img alt="Figure 11.3 – The abstraction between virtual memory and its physical basis " height="375" src="image/Figure_11.03_B17616.jpg" width="679"/>
</div>
</div>
<p class="figure-caption">Figure 11.3 – The abstraction between virtual memory and its physical basis</p>
<p>Enter ASLR. The<a id="_idIndexMarker805"/> name is quite descriptive—the layout of the program’s nuts and bolts in virtual address space is moved around each time the program is run. This includes things such as libraries and the stack and heap. Sure, finding the places in memory where we can do our dirty deeds required good ole’ fashioned trial and error (a hacker’s greatest technique), but once discovered, they would remain consistent. ASLR destroys that for us by making targeting locations in memory a game of chance.</p>
<p>I haven’t talked about libraries, and such a subject deserves its own massive book. Let’s have a quick refresher, though. Imagine the namesake, your local public library. It’s a place of <em class="italic">shared resources</em>—you can go take out a book to use the information inside it and then return it for someone else to use. Libraries are collections of resources for programs that can be reused. For example, the tasks of reading information out of files and writing data back into files need code to tell the computer how to do them, but they’re tasks that many different programs will need to do. So, instead of reinventing the wheel for every program, the numerous programs can all use the libraries that contain those functions. It’s possible to have your libraries included with your code when you compile your program—this uses more memory, but it will, understandably, run faster. These are static libraries. The more common method is dynamic libraries, which are linked when you run the program.</p>
<h2 id="_idParaDest-211"><a id="_idTextAnchor210"/>Demonstrating ASLR on Kali Linux with C</h2>
<p>We can watch<a id="_idIndexMarker806"/> ASLR in action on our native Kali Linux since it’s enabled by default. We’re going to type up a quick C program that merely prints the current location pointed to by ESP. </p>
<p>Fire up <strong class="source-inline">vim stackpoint.c</strong> to create the blank file, and punch out the following:</p>
<div>
<div class="IMG---Figure" id="_idContainer231">
<img alt="Figure 11.4 – A quick C program to print the location of ESP " height="96" src="image/Figure_11.04_B17616.jpg" width="356"/>
</div>
</div>
<p class="figure-caption">Figure 11.4 – A quick C program to print the location of ESP</p>
<p>That wasn’t so bad. Now compile it with <strong class="source-inline">gcc -o stackpoint stackpoint.c</strong>, and execute it a few times. You’ll see that the stack pointer bounces around with each run of the program:</p>
<div>
<div class="IMG---Figure" id="_idContainer232">
<img alt="Figure 11.5 – Our stack pointer program in action with randomization " height="272" src="image/Figure_11.05_B17616.jpg" width="253"/>
</div>
</div>
<p class="figure-caption">Figure 11.5 – Our stack pointer program in action with randomization</p>
<p>This is what virtual memory randomization looks like. Check out the stark contrast between the<a id="_idIndexMarker807"/> outputs when we run this same program after disabling ASLR:</p>
<div>
<div class="IMG---Figure" id="_idContainer233">
<img alt="Figure 11.6 – Our stack pointer program after we disable randomization  " height="258" src="image/Figure_11.06_B17616.jpg" width="439"/>
</div>
</div>
<p class="figure-caption">Figure 11.6 – Our stack pointer program after we disable randomization </p>
<p>With that demonstration, let’s introduce the basic concepts of ROP.</p>
<h1 id="_idParaDest-212"><a id="_idTextAnchor211"/>Introducing ROP</h1>
<p>So, now we’re seeing<a id="_idIndexMarker808"/> two distinct countermeasures that work together to make the lives of the bad guys more difficult. We’re taking away the predictability necessary to find the soft spots of the vulnerable program when loaded in memory, and we’re filing down the areas of memory where execution is allowed to the bare minimum. In other words, DEP/NX and ASLR take a big and stationary target and turn it into a tiny moving target. Hopefully, the hacker in you is already brainstorming the security assumptions of these protection mechanisms. Think of it this way—we’re setting certain regions of memory as non-executable. However, this is a program, so some instructions have to be executed. We’re randomizing the address space so that it’s hard to predict where to find certain structures, but there’s a flow of execution. There <em class="italic">has</em> to be a way to find everything needed to get the job done. ROP takes advantage of this reality. Let’s take a look at how it does this.</p>
<h2 id="_idParaDest-213"><a id="_idTextAnchor212"/>Borrowing chunks and returning to libc – turning the code against itself</h2>
<p>When we introduced buffer overflow attacks, we exploited the vulnerability in our homegrown C program—the presence of the infamous <strong class="source-inline">strcpy()</strong> function. As this function will pass any sized input into the fixed-size<a id="_idIndexMarker809"/> buffer, we know that it’s just a matter of research to find the right input to overflow the instruction pointer with an arbitrary value. We have control over where to send the flow of execution, so where do we send it? Well, to our injected shellcode, silly. We’re making two huge assumptions to pull this off—that we can get a chunk of arbitrary code into memory and that we can convince the processor to actually execute those instructions. Let’s suppose those two feats aren’t an option—do we pack up and go home, leaving this juicy <strong class="source-inline">strcpy()</strong> function just sitting there? Without those two assumptions, we can still overwrite the return address. We can’t point at our injected shellcode, but we can point at some other instruction that’s already there. This is the heart and soul of the whole concept: borrowing chunks of code from within the program itself and using returns to do it. Before you take low-level dives into the dark world of assembly, you might have intuited that a program designed to load a web page will only contain code that loads a web page. You, the esteemed hacker, understand that programs of all complexity levels are doing fairly simple things at the lowest levels. Your friendly web browser and my dangerous backdoor shellcode share the same language and the same low-level activities of moving things in and out of temporary storage boxes and telling the processor where the next chunk of work is located.</p>
<p>Okay, so we’re borrowing code from inside the vulnerable program to do something for us. It sounds as though very small programs that hardly do anything would have far less code to rope into our scheme. I can hear the programmers in the back row shouting at me: <em class="italic">don’t forget about libraries!</em> Remember, even tiny little programs that are only useful for the demos in this book need complex code to do the things we take for granted. For example, take <strong class="source-inline">printf()</strong>. How would the program know how to actually print information on the screen? Try to create a C program with the <strong class="source-inline">printf()</strong> function but without the <strong class="source-inline">&lt;#include stdio.h&gt;</strong> line at the top. What happens? That’s right—it won’t compile:</p>
<div>
<div class="IMG---Figure" id="_idContainer234">
<img alt="Figure 11.7 – Forgetting our input/output preprocessing directive " height="93" src="image/Figure_11.07_B17616.jpg" width="708"/>
</div>
</div>
<p class="figure-caption">Figure 11.7 – Forgetting our input/output preprocessing directive</p>
<p>Bear in mind that the <strong class="source-inline">include</strong> preprocessing directive literally includes the defined chunk of code. Even two or three lines of code will, when compiled, be full of goodies. These goodies aren’t just any tasty treats—they’re shared DNA among C programs. The headers at the top of your C code reference the C standard library (<strong class="source-inline">libc</strong>). The <strong class="source-inline">libc</strong> standard library contains things such as type definitions and macros, but it also contains the functions for a whole gamut of tasks that are often taken for granted. What’s important to note here is that multiple functions can come from the same library. Tying this all together, one possibility for the attacker when overwriting that return address is to point at some function that’s in memory precisely because the functionality was pulled in with the <strong class="source-inline">include</strong> directive. Being the standard library for the C language, <strong class="source-inline">libc</strong> is the obvious target; it’ll be linked to almost any program, even the simplest ones, and it will contain<a id="_idIndexMarker810"/> powerful functionality for us to leverage. These attacks are dubbed <strong class="bold">return-to-libc</strong> attacks.</p>
<p>The return-to-libc technique gets us around that pesky no-execute defense. The arbitrary code that we’ve just dumped into the stack is residing in non-executable space; on the other hand, the <strong class="source-inline">libc</strong> functions are elsewhere in memory. Returning to them gives the attacker access to powerful functions without the need for our own shellcode. There is one issue with this approach: memory layout randomization or ASLR. The actual location of these handy <strong class="source-inline">libc</strong> functions was easy to determine until ASLR came along. In this chapter, the hands-on lab is going to look at a variation of the <strong class="source-inline">return-to-libc</strong> method.</p>
<p class="callout-heading">It Still Has to Work – ASLR and Offsets</p>
<p class="callout">Keep in mind that although ASLR will randomize the base address, the program still needs to work—that is, it needs to be able to find the locations of its numerous bits and pieces. Therefore, ASLR simply can’t change the <em class="italic">distance</em> from one place to another—the offsets. Sometimes, a breed of vulnerability called <em class="italic">memory leaks</em> can inform the attacker about the randomized memory layout, and from there, adding the offset to the desired function can yield the correct location in memory—even though it’s been randomized!</p>
<p>As you can see, ROP is a breed of attack, and there are different ways of approaching this technique. Proper treatment of the variations of this concept is beyond the scope of this book, so we’ll be taking a look at a basic demonstration.</p>
<h2 id="_idParaDest-214"><a id="_idTextAnchor213"/>The basic unit of ROP – gadgets</h2>
<p>The x86 instruction set that we’re working with is, sometimes, described as <em class="italic">dense</em>. A <em class="italic">single</em> byte instruction can have significant power; for example, <strong class="source-inline">lodsb</strong> loads a byte from memory while incrementing a pointer. What about a program with only a handful of bytes in it? Well, we won’t have a tremendous number of options available. But what about any program linked to the C standard library? There’s enough inherent instruction power to let the attacker get away with just about anything. We can turn the code against itself.</p>
<p>When a function is called, its instructions are pushed onto the stack on top of the return address so that the execution can proceed where it left off with the procedure call. During a buffer overflow, we overwrite the return address to control the flow of execution. Now, imagine that we’ve overwritten the return address so that it points to some instructions that end in a return. That points to some other instructions ending in a return, which points to<a id="_idIndexMarker811"/> some other instructions that end in a—you get the idea. These individual pieces of code are <a id="_idIndexMarker812"/>called <strong class="bold">gadgets</strong>. Typically, a gadget is short but always ends in an instruction that sends the execution somewhere else. We chain these together to create arbitrary functionality—all without injection.</p>
<p>Hopefully, you have a core understanding of what we’re up against—now we need to examine the standard toolset for this job.</p>
<h2 id="_idParaDest-215"><a id="_idTextAnchor214"/>Getting cozy with our tools – MSFrop and ROPgadget</h2>
<p>Enough lecturing—let’s take a peek inside the two tools that you’ll likely use the most when developing ROP exploits. In the spirit of taking Kali Linux to the limit, we’ll explore MSFrop. This<a id="_idIndexMarker813"/> tool is excellent for assisted research of the gadgets in a target binary. It will find them for you and even output them in a friendly way so that you can review them. However, the tool that we really put on our lab coats for is ROPgadget.</p>
<h3>Metasploit Framework’s ROP tool – MSFrop</h3>
<p>We are used to <strong class="source-inline">msfvenom</strong>, which is <a id="_idIndexMarker814"/>standalone but still a part of Metasploit. MSFrop is different—it needs to be run from the MSF console. Let’s fire up <strong class="source-inline">msfconsole</strong> followed by <strong class="source-inline">msfrop</strong> to start getting familiar with this nifty gadget hunter:</p>
<p class="source-code"># msfconsole</p>
<p class="source-code">msf6 &gt; msfrop</p>
<p>This will just display the help page outlining the options. Let’s step through them and get an idea of MSFrop’s power:</p>
<ul>
<li><strong class="source-inline">--depth</strong> is, essentially, a <a id="_idIndexMarker815"/>measure of how deep into the code your search for gadgets will go. Since a gadget ends with a return instruction, the <strong class="source-inline">depth</strong> flag finds all the returns and works backward from that point. Depth is the number of bytes we’re willing to search from a given return.</li>
<li><strong class="source-inline">--search</strong> is for when we’re hunting for particular bytes in our gadgets. This flag takes a regular expression as a search query; one of the most common regular expressions is <strong class="source-inline">\x</strong> to signify hexadecimal numbers.</li>
<li><strong class="source-inline">--nocolor</strong> is just aesthetics; it removes the display colors for piping your output to other tools.</li>
<li><strong class="source-inline">--export</strong> is, along with <strong class="source-inline">depth</strong>, a pretty standard parameter of MSFrop, especially at higher depths. This puts the gadgets into a CSV file for your review when the Terminal <a id="_idIndexMarker816"/>window gets old.</li>
</ul>
<p>Now we’ll examine the other big player in the world of ROP: ROPgadget.</p>
<h3>Your sophisticated ROP lab – ROPgadget</h3>
<p>I’ll be blunt—I think<a id="_idIndexMarker817"/> MSFrop is more of an <em class="italic">honorable mention</em> when we’re comparing ROP tools. It’s great that Metasploit Framework has the sophistication to serve as a solid one-stop shop for hacking, and knowing that we can study gadgets in a binary without leaving the MSF console is handy. But my favorite dedicated tool is the Python-coded ROPgadget. It’s a breeze to install inside our Kali box with <strong class="source-inline">pip</strong>. If you don’t have <strong class="source-inline">pip</strong> already installed, get that done with <strong class="source-inline">apt install python3-pip</strong>. Then, ROPgadget is a single step away:</p>
<div>
<div class="IMG---Figure" id="_idContainer235">
<img alt="Figure 11.8 – The installation of ROPgadget with pip " height="35" src="image/Figure_11.08_B17616.jpg" width="324"/>
</div>
</div>
<p class="figure-caption">Figure 11.8 – The installation of ROPgadget with pip</p>
<p>Let’s take a look at the options available to us, leaving out a couple of the processor-specific commands:</p>
<ul>
<li><strong class="source-inline">--binary</strong> specifies<a id="_idIndexMarker818"/> our target, which can be in ELF format, PE format, Mach-object format, and raw.</li>
<li><strong class="source-inline">--opcode</strong> searches for the defined opcodes in the executable segments of the binary, while <strong class="source-inline">--string</strong> searches for a given string in the readable segments of the binary. One use for <strong class="source-inline">--string</strong> is to look at specific functions, such as <strong class="source-inline">main()</strong>.</li>
<li><strong class="source-inline">--memstr</strong> is your lifeline for borrowing characters from your target binary. Let’s suppose that you want to copy the ASCII characters, <strong class="source-inline">sh</strong>, into the buffer without injecting them. You pass the <strong class="source-inline">--memstr "sh"</strong> argument and ROPgadget will search for <strong class="source-inline">\x73</strong> and <strong class="source-inline">\x68</strong> in memory.</li>
<li><strong class="source-inline">--depth</strong> means the same thing here as it does in MSFrop. Once a <strong class="source-inline">ret</strong> is found, this parameter is how many bytes back we’ll be searching for gadgets.</li>
<li><strong class="source-inline">--only</strong> and <strong class="source-inline">--filter</strong> are the instruction filters. <strong class="source-inline">--only</strong> will hide everything but the specified instructions; <strong class="source-inline">--filter</strong> will show everything but the specified instructions.</li>
<li><strong class="source-inline">--range</strong> specifies a range of memory addresses to limit our gadget search. Without this option, the entire binary will be searched. </li>
<li><strong class="source-inline">--badbytes</strong> means exactly what you think it means, my weary shellcoder. Just when you thought that by borrowing code, you could escape the trouble of bytes that shatter both our shellcode and our dreams, experienced ROP engineers will run into this occasionally. It really doesn’t matter where the bytes are coming from; the break happens during execution. There’s another factor to bear in mind, too—the actual exploit code itself. In this chapter, we’ll be working with Python to generate our payload. We’ll be using the powerful <strong class="source-inline">struct</strong> module to pack binary data into strings that are then handled like any ordinary string variable by Python. Remember <strong class="source-inline">--badbytes</strong> when you’re sitting there with a broken script; it might be what you’re looking for.</li>
<li><strong class="source-inline">--rawArch</strong> and <strong class="source-inline">--rawMode</strong> are used for defining 32-bit and 64-bit architectures and modes.</li>
<li><strong class="source-inline">--re</strong> takes a regular expression (for example, <strong class="source-inline">\x35</strong>).</li>
<li><strong class="source-inline">--offset</strong> takes a hex value as an offset for calculating gadget addresses.</li>
<li><strong class="source-inline">--ropchain</strong> is a wonderful coup de grace option that generates the Python exploit code for us. It isn’t as easy as throwing it into a <strong class="source-inline">.py</strong> file and executing it; we need to know exactly how it’s being passed to the vulnerable program.</li>
<li><strong class="source-inline">--console</strong> is for interactive gadget hunting. Essentially, it brings up a Terminal window within ROPgadget for conducting specific searches. We’ll take a look at it later.</li>
<li><strong class="source-inline">--norop</strong>, <strong class="source-inline">--nojop</strong>, and <strong class="source-inline">--nosys</strong> disable the search engines for specific gadget types—return-oriented, jump-oriented, and system call instruction gadgets, respectively. When you’re trying to understand the full complement of gadgets available to you, you’ll generally want to avoid these options; they’re only for fine-tuned attacks.</li>
<li>By default, duplicate gadgets are suppressed; you can use <strong class="source-inline">--all</strong> to see everything. This is handy for gathering all of the memory addresses associated with your binary’s gadgets.</li>
<li><strong class="source-inline">--dump</strong> is, essentially, an <strong class="source-inline">objdump -x</strong> object for your gadgets; this will display the<a id="_idIndexMarker819"/> disassembled gadgets and then their raw bytes.</li>
</ul>
<p>There are several other great ROP programs available, but ROPgadget should get just about any of your projects done. Let’s prepare to take it out for a test drive by preparing our vulnerable executable.</p>
<h2 id="_idParaDest-216"><a id="_idTextAnchor215"/>Creating our vulnerable C program without disabling the protections</h2>
<p>The full breadth of <a id="_idIndexMarker820"/>ROP attacks deserves more space than we can offer here, so let’s build a small and relatively simple demonstration for an x86 Linux target environment. Fire up <strong class="source-inline">vim buff.c</strong> to prepare a new C file in the Vim editor. Type in the following familiar code:</p>
<div>
<div class="IMG---Figure" id="_idContainer236">
<img alt="Figure 11.9 – The tried-and-true vulnerable program " height="293" src="image/Figure_11.09_B17616.jpg" width="515"/>
</div>
</div>
<p class="figure-caption">Figure 11.9 – The tried-and-true vulnerable program</p>
<p>Now we can compile our fancy new program. But let’s try something different.</p>
<h2 id="_idParaDest-217"><a id="_idTextAnchor216"/>No PIE for you – compiling your vulnerable executable without ASLR hardening</h2>
<p>Hit <em class="italic">Esc</em> followed by <strong class="source-inline">:wq!</strong> to save and quit Vim; then, compile your executable. This time, let’s introduce Clang. The differences between GCC and Clang are outside the scope of this discussion, and similar to the editor war, you’ll find solid arguments on either side. Clang is <a id="_idIndexMarker821"/>more<a id="_idIndexMarker822"/> lightweight, and the compiled code it produces is a little “cleaner” for the purposes of our lab (it also runs natively on Windows). Fire it up and compile your new C program with the following command:</p>
<div>
<div class="IMG---Figure" id="_idContainer237">
<img alt="Figure 11.10 – Disabling PIE hardening at compilation " height="45" src="image/Figure_11.10_B17616.jpg" width="291"/>
</div>
</div>
<p class="figure-caption">Figure 11.10 – Disabling PIE hardening at compilation</p>
<p>Recall <a id="_idIndexMarker823"/>that when we originally created a <em class="italic">vulnerable C program</em>, the focus of its vulnerability was in the code (specifically, by using the infamous <strong class="source-inline">strcpy()</strong> function). This time, we’re using vulnerable code and compiling the executable with a vulnerable option enabled: <strong class="source-inline">-no-pie</strong>. When a <strong class="bold">Position Independent Executable</strong> (<strong class="bold">PIE</strong>) loads up in an ASLR environment, the kernel loads all the<a id="_idIndexMarker824"/> code and assigns random virtual addresses (except for the entry point, of course). Typically, security-sensitive executables are PIEs, but as you can see, this won’t necessarily be the case. In some distros—notably, Kali Linux—you have to <a id="_idIndexMarker825"/>explicitly disable compiling a PIE with Clang or GCC.</p>
<p class="callout-heading">Walk Before You Run – Disabling PIE</p>
<p class="callout">Similar to what we did with stack protection in <a href="B17616_10_Final_VK_ePub.xhtml#_idTextAnchor187"><em class="italic">Chapter 10</em></a>, <em class="italic">Shellcoding – The Stack</em>, this demonstration disables a package hardening strategy that could be found in secure environments: PIEs. However, unlike the absence of DEP and ASLR, software with absolute addresses is still common in some enterprise environments.</p>
<p>Now that we have our lab executable, let’s understand the low-level mechanisms we are going to compromise.</p>
<h2 id="_idParaDest-218"><a id="_idTextAnchor217"/>Generating an ROP chain</h2>
<p>If you recall the <a id="_idIndexMarker826"/>humble vulnerable C programs we wrote earlier, this time around, you’ll notice something different. We’re already familiar with the <strong class="source-inline">strcpy()</strong> function, but in this program, we have the <strong class="source-inline">system()</strong> function. A part of the C standard library, <strong class="source-inline">system()</strong> will pass a command to the host to be executed.</p>
<p>We can grab individual bytes out of our program’s own code, link them together with returns, and pass whatever bytes we want to <strong class="source-inline">system()</strong>. The potential is there, but we have the problem of figuring out where <strong class="source-inline">system()</strong> is located. Let’s take the spirit of return-to-libc in a different direction.</p>
<h1 id="_idParaDest-219"><a id="_idTextAnchor218"/>Getting hands-on with the return-to-PLT attack</h1>
<p>I say this about a lot of topics, but the <strong class="bold">Procedure Linkage Table</strong> (<strong class="bold">PLT</strong>) and<a id="_idIndexMarker827"/> the <strong class="bold">Global Offset Table</strong> (<strong class="bold">GOT</strong>) are subjects that deserve their own book. However, we’ll try to <a id="_idIndexMarker828"/>run through a crash course to understand how we’re going to get around memory space randomization. Our executable is not a position-independent executable thanks to our <strong class="source-inline">-no-pie</strong> compilation configuration, so the actual location of global structures in the program wasn’t known at compile time. The GOT is literally a table of addresses used by the executable during runtime to convert PIE addresses into absolute ones. At runtime, our executable needs its shared libraries; these are loaded and linked using the dynamic linker during the bootstrapping process. That is when the GOT is updated.</p>
<p>Since the addresses are <a id="_idIndexMarker829"/>dynamically linked at runtime, the compiler doesn’t really know whether the addresses in our non-position-independent code will be resolved from the GOT. So, with the <strong class="source-inline">-no-pie</strong> specification, the compiler does its usual thing of generating a call instruction; this is interpreted by the linker to determine absolute destination addresses and updates the PLT. Now I know what you’re thinking—the PLT and GOT kinda sound like the same thing. They’re similar concepts, and the GOT helps the position-independent programs maintain their hard-earned independence. But we have a dynamically-linked, non-position-independent executable. Here’s a simple distinction—the GOT is used for converting <em class="italic">address calculations</em> into absolute destination addresses, whereas the PLT is used for converting our <em class="italic">function calls</em> into absolute destinations.</p>
<p>Now, let’s consider the return-to-PLT moniker. We’re setting up those ROP chains with our returns pointing to particular places to send the flow; in this scenario, we’re directing flow to the PLT function call and, thus, removing any need for address knowledge at runtime. Our linker is an unwitting accomplice to the crime.</p>
<h2 id="_idParaDest-220"><a id="_idTextAnchor219"/>Extracting gadget information for building your payload</h2>
<p>Now, we’ll step<a id="_idIndexMarker830"/> through ROP chain and exploit generation. The return-to-PLT part is easy to figure out with <strong class="source-inline">gdb</strong>. It’s also easy to use ROPgadget for finding the bytes that we’re going to use to construct our chain. But what about writing into the program’s memory? First, let’s figure out where everything is.</p>
<h3>Finding the .bss address</h3>
<p>We need to<a id="_idIndexMarker831"/> work with the program’s design to write data somewhere. We can use the <strong class="source-inline">.bss</strong> section of our executable for this task, as <strong class="source-inline">.bss</strong> is a place to put variables that don’t have any value just yet. Essentially, it’s space set aside for these variables; therefore, it won’t occupy space within the object file. For our purposes here, we just need to know where it is. Use the <strong class="source-inline">info file</strong> command in <strong class="source-inline">gdb</strong> to get a list of the sections with their ranges and take down the initial address of <strong class="source-inline">.bss</strong>:</p>
<p class="source-code"># gdb buff</p>
<p class="source-code">(gdb) info file</p>
<p>Here’s an example of a memory map from these commands:</p>
<div>
<div class="IMG---Figure" id="_idContainer238">
<img alt="Figure 11.11 – File information in gdb " height="542" src="image/Figure_11.11_B17616.jpg" width="482"/>
</div>
</div>
<p class="figure-caption">Figure 11.11 – File information in gdb</p>
<p>In our <a id="_idIndexMarker832"/>example, we’ll write down <strong class="source-inline">0x0804c028</strong> for <strong class="source-inline">.bss</strong>. Now, we’ll look for the pieces that will allow us to jump around the program’s code.</p>
<h3>Finding a pop pop ret structure</h3>
<p>The <strong class="source-inline">strcpy()</strong> function pops off stack pointer offsets for source and destination arguments and then returns; therefore, the glue in our chain is a <strong class="source-inline">pop pop ret</strong> machine<a id="_idIndexMarker833"/> instruction structure. Thankfully, this is easy for ROPgadget’s <strong class="source-inline">search</strong> function. First, get into the interactive console mode, load the gadgets, and then conduct a search for the relevant structures. You’ll get a lot of hits, but you’re looking for a <strong class="source-inline">pop pop ret</strong> structure and then copying its address:</p>
<p class="source-code"># ROPgadget --binary buff --depth 5 –console</p>
<p class="source-code">(ROPgadget)&gt; load</p>
<p class="source-code">(ROPgadget)&gt; search pop ; pop ; ret</p>
<p>The preceding command should produce the result shown in the following screenshot:</p>
<div>
<div class="IMG---Figure" id="_idContainer239">
<img alt="Figure 11.12 – Finding the pop pop ret gadgets in our program " height="296" src="image/Figure_11.12_B17616.jpg" width="507"/>
</div>
</div>
<p class="figure-caption">Figure 11.12 – Finding the pop pop ret gadgets in our program</p>
<p>Note the depth<a id="_idIndexMarker834"/> of 5 bytes. Remember, that means we’re searching backward from a given return instruction by 5 bytes to find the gadgets. But we’re not done – we need to find the locations of the <strong class="source-inline">system</strong> and <strong class="source-inline">strcpy</strong> functions.</p>
<h3>Finding addresses for the system@plt and strcpy@plt functions</h3>
<p>Our <strong class="source-inline">main()</strong> function needs <a id="_idIndexMarker835"/>to call <strong class="source-inline">system()</strong> and <strong class="source-inline">strcpy()</strong>. This is a no-PIE<a id="_idIndexMarker836"/> target, so we’re looking for the addresses corresponding to <strong class="source-inline">&lt;system@plt&gt;</strong> and <strong class="source-inline">&lt;strcpy @plt&gt;</strong>. Use the <strong class="source-inline">disas</strong> command in <strong class="source-inline">gdb</strong> to investigate the <strong class="source-inline">main()</strong> function:</p>
<p class="source-code"># gdb buff</p>
<p class="source-code">(gdb) disas main</p>
<p>Remember that we’re using <strong class="source-inline">strcpy()</strong> to copy our chosen bytes into memory and <strong class="source-inline">system()</strong> to make an actual system command:</p>
<div>
<div class="IMG---Figure" id="_idContainer240">
<img alt="Figure 11.13 – Identifying the locations for system@plt and strcpy@plt " height="343" src="image/Figure_11.13_B17616.jpg" width="456"/>
</div>
</div>
<p class="figure-caption">Figure 11.13 – Identifying the locations for system@plt and strcpy@plt</p>
<p>At this point, we<a id="_idIndexMarker837"/> have four addresses in our notes. Now we just need to find the characters that<a id="_idIndexMarker838"/> represent our command. Thankfully, they’re already present in the program.</p>
<h3>Finding target characters in memory with ROPgadget and Python</h3>
<p>The question of <a id="_idIndexMarker839"/>what specific command you’ll try to pass to <strong class="source-inline">system()</strong> is for you to <a id="_idIndexMarker840"/>decide. In our actual demo, I’m just launching <strong class="source-inline">sh</strong>. However, there’s potential for remote compromise here. Take the following <strong class="source-inline">netcat</strong> command as an example:</p>
<p class="source-code"><strong class="bold">nc -e /bin/sh -lvnp 1066</strong></p>
<p>This will set up a session with <strong class="source-inline">sh</strong> and pass it to a local listener on port <strong class="source-inline">1066</strong>. All we need are the precise locations in the vulnerable program where we can find the characters needed to construct this line. This sounds daunting, but ROPgadget is here to save us a lot of time with the <strong class="source-inline">--memstr</strong> flag. Naturally, we only need a single memory address per character, so it’d be cleanest to just pass a string of the unique characters in our <strong class="source-inline">bash</strong> command. Use Python for this task, look slick, and impress your friends. Start the interactive interpreter with <strong class="source-inline">python3</strong> and then run this command:</p>
<p class="source-code">''.join(set('nc -e /bin/sh -lvnp 1066'))</p>
<p>This should spit<a id="_idIndexMarker841"/> out a clean one-per-unique-character result that you can then<a id="_idIndexMarker842"/> pass to ROPgadget, as shown in the following screenshot:</p>
<div>
<div class="IMG---Figure" id="_idContainer241">
<img alt="Figure 11.14 – A clean way to handle repeated characters " height="147" src="image/Figure_11.14_B17616.jpg" width="631"/>
</div>
</div>
<p class="figure-caption">Figure 11.14 – A clean way to handle repeated characters</p>
<p>Use <strong class="source-inline">exit()</strong> to close the interpreter, and then pass the result of that command as an argument to <strong class="source-inline">--memstr</strong>:</p>
<div>
<div class="IMG---Figure" id="_idContainer242">
<img alt="Figure 11.15 – Memory locations for each byte " height="423" src="image/Figure_11.15_B17616.jpg" width="503"/>
</div>
</div>
<p class="figure-caption">Figure 11.15 – Memory locations for each byte</p>
<p>For our lab, we’ll<a id="_idIndexMarker843"/> keep it simple—let’s just find the characters for <strong class="source-inline">sh;</strong> and<a id="_idIndexMarker844"/> see whether we can pass that to <strong class="source-inline">system</strong>. Finally, let’s look at how it comes together.</p>
<h2 id="_idParaDest-221"><a id="_idTextAnchor220"/>Go, go, gadget ROP chain – bringing it together for the exploit</h2>
<p>We’re so close, but there’s one last variable to figure out—our offset to the return address. This is more of the traditional overflow research for injecting shellcode. So, back we go into the debugger.</p>
<h3>Finding the offset to return with gdb</h3>
<p>Our chain starts with a <strong class="source-inline">strcpy()</strong> function. We’ve overwritten EIP before, which tells the processor where to find the next instruction (why, in a grand field of NOPs, of course). In this case, we’re <a id="_idIndexMarker845"/>adjusting where we’ll <em class="italic">return</em> to, essentially spoofing the calling frame. Therefore, we need to overflow deeply enough to overwrite the stack base pointer EBP. Once we find this sweet spot, we can send the flow to our first <strong class="source-inline">strcpy()</strong> function by overwriting it with our <strong class="source-inline">strcpy@plt</strong> address:</p>
<div>
<div class="IMG---Figure" id="_idContainer243">
<img alt="Figure 11.16 – The calling frame and current frame layout " height="794" src="image/Figure_11.16_B17616.jpg" width="538"/>
</div>
</div>
<p class="figure-caption">Figure 11.16 – The calling frame and current frame layout</p>
<p>At this point, this should simply be a review for you. We’re firing up <strong class="source-inline">gdb</strong> and executing the <strong class="source-inline">run</strong> command with the test input. The easiest way to do this is with a Python call; for example, within <strong class="source-inline">gdb</strong>, and with our target executable loaded: <strong class="source-inline">run $(python -c 'print "z" * 1028 + "AAAA"')</strong>. We understand that this will load up 1,028 z’s -- hexadecimal <strong class="source-inline">0x7a</strong>—and then 4 A’s -- hexadecimal <strong class="source-inline">0x41</strong>. So, we’ll know we landed on the sweet spot when we see that we pushed <strong class="source-inline">0x41414141</strong> into EBP: </p>
<div>
<div class="IMG---Figure" id="_idContainer244">
<img alt="Figure 11.17 – Examining memory after the expected segfault " height="439" src="image/Figure_11.17_B17616.jpg" width="633"/>
</div>
</div>
<p class="figure-caption">Figure 11.17 – Examining memory after the expected segfault</p>
<p>In this case, let’s check out the value of EBP. What’s our offset? Once you’ve figured that out, let’s look at how it might be conveyed via Python.</p>
<h3>Writing the Python exploit</h3>
<p>Finally, we can bring<a id="_idIndexMarker846"/> it together. Again, we’re testing <strong class="source-inline">sh;</strong> in this exploit. Let’s step through what’s going on:</p>
<div>
<div class="IMG---Figure" id="_idContainer245">
<img alt="Figure 11.18 – The exploit in Python " height="402" src="image/Figure_11.18_B17616.jpg" width="356"/>
</div>
</div>
<p class="figure-caption">Figure 11.18 – The exploit in Python</p>
<p>Hopefully, it’s clear that this <a id="_idIndexMarker847"/>is pretty repetitive—once you figure out the chain, it’s fairly trivial to construct longer ones. Bear in mind that because of how Python 3 handles types, we’re just using Python 2 with this example. You can upgrade it for Python 3 as long as you convert your string into bytes first.</p>
<p>Note we’ve imported <strong class="source-inline">pack()</strong> from the <strong class="source-inline">struct</strong> module. This function allows us to work with raw binary within Python by treating it like any ordinary string. If you’re feeling particularly masochistic, you can just pass the regex representation of the packed bytes directly to the program as an argument. I have a feeling you’ll try this way first. There are two arguments—the byte ordering and type, and the data itself. The <strong class="source-inline">&lt;</strong> character is important for any Intel exploit—that’s our little-endian ordering.</p>
<p>The location of the <strong class="source-inline">strcpy()</strong> function and our <strong class="source-inline">pop pop ret</strong> structure are declared first, as they’re used with each chain link. After that, the pattern is pretty easy:</p>
<ol>
<li>Enough fluff (1,028 bytes of the character <strong class="source-inline">z</strong>) to reach the return.</li>
<li>Overwrite with the address of <strong class="source-inline">strcpy()</strong> and return to <strong class="source-inline">pop pop ret</strong>. Note that the <strong class="source-inline">pop pop</strong> structure isn’t really important to us; the bytes have been copied into memory and we’re hitting the return. Rinse and repeat.</li>
<li>Nab the first byte representing the character in our command and place it in <strong class="source-inline">.bss</strong>, byte by byte, using <strong class="source-inline">strcpy()</strong> and <strong class="source-inline">pop pop ret</strong> to return, thus keeping the chain going.</li>
<li>End with a junk terminator and make that call to <strong class="source-inline">system()</strong>, pointing back at the base address of <strong class="source-inline">.bss</strong>. At this point, starting at that base address, <strong class="source-inline">sh</strong> should reside<a id="_idIndexMarker848"/> in memory. If all goes as planned, <strong class="source-inline">system()</strong> will execute <strong class="source-inline">sh.</strong></li>
</ol>
<p>The keywords are—<em class="italic">if all goes as planned</em>. A real target environment isn’t going to look like your lab, and there are numerous factors that can cause this attack to fail. It requires fine-tuning, but in a world where large enterprises are clinging to legacy applications, we see these attacks and their variants today. Hopefully, this introduction will springboard you into deeper research on all things ROP.</p>
<h1 id="_idParaDest-222"><a id="_idTextAnchor221"/>Summary</h1>
<p>For a couple of years now, some security professionals have been sounding the death knell of ROP. It’s considered old and unreliable, and new technology promises to mitigate even a carefully constructed exploit with shadow registers that track returns during an execution flow. Then again, Windows XP has been dead for several years, but anyone spending time in large production environments today is bound to see it still clinging for life, running legacy applications.</p>
<p>Today, a significant effort in many organizations is not replacing XP but rather indirect mitigation via the network or third-party software controlling the execution of code. ROP is still relevant for the time being, even if just to verify that it doesn’t work in your client’s environment. The unique nature of this attack renders it particularly dangerous, despite its current signs of aging.</p>
<p>In this chapter, we reviewed DEP and ASLR as theoretical concepts and demonstrated these technologies in action on Linux. We introduced ROP and two primary tools of the trade: MSFrop and ROPgadget. We typed up a C program with a critical vulnerability and left the default protections intact. The remainder of the chapter was spent covering the fundamentals of ROP, return-to-PLT, return-to-libc, and gadget discovery and review. We explored how to bring the pieces together for a functioning exploit.</p>
<p>In the next chapter, we’ll wrap up our shellcoding review by diving into the world of antivirus evasion. Instead of bypassing stack protection mechanisms, we’ll learn how to piggyback our code inside an injected executable, and we’ll learn how to pass our shellcode to a script interpreter. We’ll get hands-on with PowerShell to learn how to live off the land and take advantage of PowerShell’s privileged position in the Windows operating system.</p>
<h1 id="_idParaDest-223"><a id="_idTextAnchor222"/>Questions</h1>
<p>Answer the following questions to test your knowledge of this chapter:</p>
<ol>
<li value="1">Name the two types of DEP in Windows.</li>
<li>Define <strong class="source-inline">libc</strong>.</li>
<li>How many bytes long can a gadget be prior to its return?</li>
<li><strong class="source-inline">gcc -no-pie</strong> disables ______________ hardening. </li>
<li>What’s the difference between the PLT and the GOT?</li>
<li>What’s a quick and easy way to find <strong class="source-inline">system@plt</strong> with gdb?</li>
<li>Why won’t the <strong class="source-inline">pack("&gt;I", 0x0804a02c)</strong> function work in the ROP context on an x86 processor? </li>
</ol>
<h1 id="_idParaDest-224"><a id="_idTextAnchor223"/>Further reading</h1>
<p>For more information regarding the topics that were covered in this chapter, take a look at the following resources:</p>
<ul>
<li>Black Hat presentation on ROP: <a href="https://www.blackhat.com/presentations/bh-usa-08/Shacham/BH_US_08_Shacham_Return_Oriented_Programming.pdf">https://www.blackhat.com/presentations/bh-usa-08/Shacham/BH_US_08_Shacham_Return_Oriented_Programming.pdf</a></li>
<li>Presentation on ROP by the creator of ROPgadget: <a href="http://shell-storm.org/talks/ROP_course_lecture_jonathan_salwan_2014.pdf">http://shell-storm.org/talks/ROP_course_lecture_jonathan_salwan_2014.pdf</a> </li>
</ul>
</div>
</div></body></html>