- en: '*Chapter 11*: Shellcoding – Bypassing Protections'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When I’m in a conversation with friends and family about airport security, a
    quip I often hear is *maybe we should just ban the passengers*. Though this is
    obviously facetious, let’s think about it for a moment—no matter what we do to
    screen everyone walking onto an airplane, we have to allow at least some people
    through the gates, particularly the pilots. There’s a clear divide between the
    malicious outsider with no good intention and the trusted insider who, by virtue
    of their role, must be given the necessary access to get some work done. Let’s
    think of the malicious outsiders trying to get on the plane as shellcode, and
    the trusted pilot who runs the show as a legitimate native binary. With perfect
    security screenings guaranteeing that no malicious individual can walk onto a
    plane, you will still have to trust that the pilot isn’t corrupted by an outside
    influence; that is, their power is being leveraged to execute a malicious deed.
  prefs: []
  type: TYPE_NORMAL
- en: Welcome to the concept of **return-oriented programming** (**ROP**), where the
    world we live in is a paradise in which no shellcode can be injected and executed,
    but we’ve figured out how to leverage the code that’s already there to do our
    dirty work. We’re going to learn how combining the density of the x86 instruction
    set with a good old-fashioned buffer vulnerability in a program allows us to construct
    almost any arbitrary functionality. We’ll take a break from injecting bad code
    and learn how to turn the good code against itself.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the core defense concepts, such as **data execution prevention**
    (**DEP**) and **address space layout randomization** (**ASLR**)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Learning how to examine machine code and memory to identify instructions that
    we can leverage for our purposes, called **gadgets**
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding the different types of ROP-based attacks
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Exploring the tools used by hackers to pull off ROP attacks
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Writing and attacking a vulnerable C program
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For ROP, you will require the following:'
  prefs: []
  type: TYPE_NORMAL
- en: 32-bit Kali Linux 2021.3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: ROPgadget
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: DEP and ASLR – the intentional and the unavoidable
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'So far, we’ve only mentioned these concepts in passing: DEP (which is also
    called NX for no-execute) and ASLR. I’m afraid we can’t put them off forever.
    I think I hear a couple of hackers at the back saying, *good! It took the impact
    out of the demonstrations when we had to disable basic protection to make the
    attack work*. Fair enough. When we introduced a basic buffer overflow in [*Chapter
    10*](B17616_10_Final_VK_ePub.xhtml#_idTextAnchor187), *Shellcoding – The Stack*,
    we explicitly disabled ASLR. (To be fair, Windows 7 comes out of the box like
    that.) This is all by design, though—we can’t understand the core concept without,
    first, taking a step back. These protection mechanisms are *responses* to the
    attacks we’ve demonstrated. But look at me, going off on a tangent again without
    defining these simple concepts.'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding DEP
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Do you remember where we stuff our shellcode? The answer is inside the stack
    or the heap, which is memory set aside for a thread of execution. When a function
    is running, space is allocated for variables and other data needed to get the
    work done; in other words, these are areas that are not intended to contain executable
    code. Picking a spot in memory to store a number but then later being told, *hey,
    remember that spot in memory? Let’s execute whatever’s sitting there*, should
    be suspicious. But don’t forget that processors are incredible, lightning-fast,
    and dumb. They will do what they’re told. This simple design of executing whatever
    is sitting at the location pointed to by the instruction pointer is what the shellcoding
    hacker exploits.
  prefs: []
  type: TYPE_NORMAL
- en: 'Enter DEP. The basic premise of DEP is to monitor whether the location that
    the instruction pointer is referencing has been explicitly marked as executable.
    If it isn’t, an access violation occurs. Windows has two types of DEP—*software-enforced* and *hardware-enforced*.
    The following screenshot shows what the DEP settings look like on the Windows
    interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.1 – The DEP settings in Windows ](image/Figure_11.01_B17616.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11.1 – The DEP settings in Windows
  prefs: []
  type: TYPE_NORMAL
- en: 'Software-enforced DEP operates at the higher levels of the OS, and hence, it
    is available on any machine that can run Windows and can protect against any attempts
    to ride on exception handling mechanisms. Hardware-enforced DEP uses the processor’s
    **Execute Disable** (**XD**) bit to mark memory locations as non-executable. Let’s
    take a look at the distinction between software-enforced and hardware-enforced:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.2 – Two kinds of DEP: software and hardware ](image/Figure_11.02_B17616.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11.2 – Two kinds of DEP: software and hardware'
  prefs: []
  type: TYPE_NORMAL
- en: So, how does this affect us as wily hackers? The whole trick is allocating memory
    for our code, which the program is treating like an ordinary variable. Meanwhile,
    we’re hoping the processor will take our word for it that the flow of execution
    is intended to jump to the instruction pointer address. First, let’s take a look
    at the randomization of locations in memory.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding ASLR
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Take a stroll back down memory lane to when we worked on the stack overflow
    attacks. We found the vulnerable **strcpy()** function in our code, we stuffed
    the buffer with nonsense characters and deliberately overflowed it, and we checked
    our debugger and found that EIP had been overwritten with our nonsense. With careful
    payload crafting, we could find the precise location in memory where we needed
    to place the pointer to our NOP sled to, ultimately, result in the execution of
    shellcode. Now, recall that we used gdb’s examine (**x**) tool to identify the
    exact location in memory where the EIP lies. Therefore, we could map out the stack
    and *reliably* land on top of that instruction pointer with each run of the process.
  prefs: []
  type: TYPE_NORMAL
- en: 'Note that I emphasized “reliably.” Modern operating systems such as Windows
    allow for multiple programs to be open at once, and they all have massive amounts
    of addressable memory available to them—and by massive, I mean more than can be
    physically fit in a piece of RAM. Part of the operating system’s job is to figure
    out which portions of memory are less important so that they can be stored on
    the hard drive and brought into play via paging as needed. So, the program sees
    a large continuous block of memory space that is actually *virtual*, and the memory
    management unit manages the layer of abstraction that hides the physical reality
    behind the curtain:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.3 – The abstraction between virtual memory and its physical basis
    ](image/Figure_11.03_B17616.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11.3 – The abstraction between virtual memory and its physical basis
  prefs: []
  type: TYPE_NORMAL
- en: Enter ASLR. The name is quite descriptive—the layout of the program’s nuts and
    bolts in virtual address space is moved around each time the program is run. This
    includes things such as libraries and the stack and heap. Sure, finding the places
    in memory where we can do our dirty deeds required good ole’ fashioned trial and
    error (a hacker’s greatest technique), but once discovered, they would remain
    consistent. ASLR destroys that for us by making targeting locations in memory
    a game of chance.
  prefs: []
  type: TYPE_NORMAL
- en: I haven’t talked about libraries, and such a subject deserves its own massive
    book. Let’s have a quick refresher, though. Imagine the namesake, your local public
    library. It’s a place of *shared resources*—you can go take out a book to use
    the information inside it and then return it for someone else to use. Libraries
    are collections of resources for programs that can be reused. For example, the
    tasks of reading information out of files and writing data back into files need
    code to tell the computer how to do them, but they’re tasks that many different
    programs will need to do. So, instead of reinventing the wheel for every program,
    the numerous programs can all use the libraries that contain those functions.
    It’s possible to have your libraries included with your code when you compile
    your program—this uses more memory, but it will, understandably, run faster. These
    are static libraries. The more common method is dynamic libraries, which are linked
    when you run the program.
  prefs: []
  type: TYPE_NORMAL
- en: Demonstrating ASLR on Kali Linux with C
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We can watch ASLR in action on our native Kali Linux since it’s enabled by default.
    We’re going to type up a quick C program that merely prints the current location
    pointed to by ESP.
  prefs: []
  type: TYPE_NORMAL
- en: 'Fire up **vim stackpoint.c** to create the blank file, and punch out the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.4 – A quick C program to print the location of ESP ](image/Figure_11.04_B17616.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11.4 – A quick C program to print the location of ESP
  prefs: []
  type: TYPE_NORMAL
- en: 'That wasn’t so bad. Now compile it with **gcc -o stackpoint stackpoint.c**,
    and execute it a few times. You’ll see that the stack pointer bounces around with
    each run of the program:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.5 – Our stack pointer program in action with randomization ](image/Figure_11.05_B17616.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11.5 – Our stack pointer program in action with randomization
  prefs: []
  type: TYPE_NORMAL
- en: 'This is what virtual memory randomization looks like. Check out the stark contrast
    between the outputs when we run this same program after disabling ASLR:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.6 – Our stack pointer program after we disable randomization  ](image/Figure_11.06_B17616.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11.6 – Our stack pointer program after we disable randomization
  prefs: []
  type: TYPE_NORMAL
- en: With that demonstration, let’s introduce the basic concepts of ROP.
  prefs: []
  type: TYPE_NORMAL
- en: Introducing ROP
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So, now we’re seeing two distinct countermeasures that work together to make
    the lives of the bad guys more difficult. We’re taking away the predictability
    necessary to find the soft spots of the vulnerable program when loaded in memory,
    and we’re filing down the areas of memory where execution is allowed to the bare
    minimum. In other words, DEP/NX and ASLR take a big and stationary target and
    turn it into a tiny moving target. Hopefully, the hacker in you is already brainstorming
    the security assumptions of these protection mechanisms. Think of it this way—we’re
    setting certain regions of memory as non-executable. However, this is a program,
    so some instructions have to be executed. We’re randomizing the address space
    so that it’s hard to predict where to find certain structures, but there’s a flow
    of execution. There *has* to be a way to find everything needed to get the job
    done. ROP takes advantage of this reality. Let’s take a look at how it does this.
  prefs: []
  type: TYPE_NORMAL
- en: Borrowing chunks and returning to libc – turning the code against itself
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When we introduced buffer overflow attacks, we exploited the vulnerability
    in our homegrown C program—the presence of the infamous **strcpy()** function.
    As this function will pass any sized input into the fixed-size buffer, we know
    that it’s just a matter of research to find the right input to overflow the instruction
    pointer with an arbitrary value. We have control over where to send the flow of
    execution, so where do we send it? Well, to our injected shellcode, silly. We’re
    making two huge assumptions to pull this off—that we can get a chunk of arbitrary
    code into memory and that we can convince the processor to actually execute those
    instructions. Let’s suppose those two feats aren’t an option—do we pack up and
    go home, leaving this juicy **strcpy()** function just sitting there? Without
    those two assumptions, we can still overwrite the return address. We can’t point
    at our injected shellcode, but we can point at some other instruction that’s already
    there. This is the heart and soul of the whole concept: borrowing chunks of code
    from within the program itself and using returns to do it. Before you take low-level
    dives into the dark world of assembly, you might have intuited that a program
    designed to load a web page will only contain code that loads a web page. You,
    the esteemed hacker, understand that programs of all complexity levels are doing
    fairly simple things at the lowest levels. Your friendly web browser and my dangerous
    backdoor shellcode share the same language and the same low-level activities of
    moving things in and out of temporary storage boxes and telling the processor
    where the next chunk of work is located.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Okay, so we’re borrowing code from inside the vulnerable program to do something
    for us. It sounds as though very small programs that hardly do anything would
    have far less code to rope into our scheme. I can hear the programmers in the
    back row shouting at me: *don’t forget about libraries!* Remember, even tiny little
    programs that are only useful for the demos in this book need complex code to
    do the things we take for granted. For example, take **printf()**. How would the
    program know how to actually print information on the screen? Try to create a
    C program with the **printf()** function but without the **<#include stdio.h>**
    line at the top. What happens? That’s right—it won’t compile:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.7 – Forgetting our input/output preprocessing directive ](image/Figure_11.07_B17616.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11.7 – Forgetting our input/output preprocessing directive
  prefs: []
  type: TYPE_NORMAL
- en: Bear in mind that the **include** preprocessing directive literally includes
    the defined chunk of code. Even two or three lines of code will, when compiled,
    be full of goodies. These goodies aren’t just any tasty treats—they’re shared
    DNA among C programs. The headers at the top of your C code reference the C standard
    library (**libc**). The **libc** standard library contains things such as type
    definitions and macros, but it also contains the functions for a whole gamut of
    tasks that are often taken for granted. What’s important to note here is that
    multiple functions can come from the same library. Tying this all together, one
    possibility for the attacker when overwriting that return address is to point
    at some function that’s in memory precisely because the functionality was pulled
    in with the **include** directive. Being the standard library for the C language,
    **libc** is the obvious target; it’ll be linked to almost any program, even the
    simplest ones, and it will contain powerful functionality for us to leverage.
    These attacks are dubbed **return-to-libc** attacks.
  prefs: []
  type: TYPE_NORMAL
- en: 'The return-to-libc technique gets us around that pesky no-execute defense.
    The arbitrary code that we’ve just dumped into the stack is residing in non-executable
    space; on the other hand, the **libc** functions are elsewhere in memory. Returning
    to them gives the attacker access to powerful functions without the need for our
    own shellcode. There is one issue with this approach: memory layout randomization
    or ASLR. The actual location of these handy **libc** functions was easy to determine
    until ASLR came along. In this chapter, the hands-on lab is going to look at a
    variation of the **return-to-libc** method.'
  prefs: []
  type: TYPE_NORMAL
- en: It Still Has to Work – ASLR and Offsets
  prefs: []
  type: TYPE_NORMAL
- en: Keep in mind that although ASLR will randomize the base address, the program
    still needs to work—that is, it needs to be able to find the locations of its
    numerous bits and pieces. Therefore, ASLR simply can’t change the *distance* from
    one place to another—the offsets. Sometimes, a breed of vulnerability called *memory
    leaks* can inform the attacker about the randomized memory layout, and from there,
    adding the offset to the desired function can yield the correct location in memory—even
    though it’s been randomized!
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, ROP is a breed of attack, and there are different ways of approaching
    this technique. Proper treatment of the variations of this concept is beyond the
    scope of this book, so we’ll be taking a look at a basic demonstration.
  prefs: []
  type: TYPE_NORMAL
- en: The basic unit of ROP – gadgets
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The x86 instruction set that we’re working with is, sometimes, described as
    *dense*. A *single* byte instruction can have significant power; for example,
    **lodsb** loads a byte from memory while incrementing a pointer. What about a
    program with only a handful of bytes in it? Well, we won’t have a tremendous number
    of options available. But what about any program linked to the C standard library?
    There’s enough inherent instruction power to let the attacker get away with just
    about anything. We can turn the code against itself.
  prefs: []
  type: TYPE_NORMAL
- en: When a function is called, its instructions are pushed onto the stack on top
    of the return address so that the execution can proceed where it left off with
    the procedure call. During a buffer overflow, we overwrite the return address
    to control the flow of execution. Now, imagine that we’ve overwritten the return
    address so that it points to some instructions that end in a return. That points
    to some other instructions ending in a return, which points to some other instructions
    that end in a—you get the idea. These individual pieces of code are called **gadgets**.
    Typically, a gadget is short but always ends in an instruction that sends the
    execution somewhere else. We chain these together to create arbitrary functionality—all
    without injection.
  prefs: []
  type: TYPE_NORMAL
- en: Hopefully, you have a core understanding of what we’re up against—now we need
    to examine the standard toolset for this job.
  prefs: []
  type: TYPE_NORMAL
- en: Getting cozy with our tools – MSFrop and ROPgadget
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Enough lecturing—let’s take a peek inside the two tools that you’ll likely use
    the most when developing ROP exploits. In the spirit of taking Kali Linux to the
    limit, we’ll explore MSFrop. This tool is excellent for assisted research of the
    gadgets in a target binary. It will find them for you and even output them in
    a friendly way so that you can review them. However, the tool that we really put
    on our lab coats for is ROPgadget.
  prefs: []
  type: TYPE_NORMAL
- en: Metasploit Framework’s ROP tool – MSFrop
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We are used to **msfvenom**, which is standalone but still a part of Metasploit.
    MSFrop is different—it needs to be run from the MSF console. Let’s fire up **msfconsole**
    followed by **msfrop** to start getting familiar with this nifty gadget hunter:'
  prefs: []
  type: TYPE_NORMAL
- en: msfconsole
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: msf6 > msfrop
  prefs: []
  type: TYPE_NORMAL
- en: 'This will just display the help page outlining the options. Let’s step through
    them and get an idea of MSFrop’s power:'
  prefs: []
  type: TYPE_NORMAL
- en: '**--depth** is, essentially, a measure of how deep into the code your search
    for gadgets will go. Since a gadget ends with a return instruction, the **depth**
    flag finds all the returns and works backward from that point. Depth is the number
    of bytes we’re willing to search from a given return.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**--search** is for when we’re hunting for particular bytes in our gadgets.
    This flag takes a regular expression as a search query; one of the most common
    regular expressions is **\x** to signify hexadecimal numbers.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**--nocolor** is just aesthetics; it removes the display colors for piping
    your output to other tools.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**--export** is, along with **depth**, a pretty standard parameter of MSFrop,
    especially at higher depths. This puts the gadgets into a CSV file for your review
    when the Terminal window gets old.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Now we’ll examine the other big player in the world of ROP: ROPgadget.'
  prefs: []
  type: TYPE_NORMAL
- en: Your sophisticated ROP lab – ROPgadget
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'I’ll be blunt—I think MSFrop is more of an *honorable mention* when we’re comparing
    ROP tools. It’s great that Metasploit Framework has the sophistication to serve
    as a solid one-stop shop for hacking, and knowing that we can study gadgets in
    a binary without leaving the MSF console is handy. But my favorite dedicated tool
    is the Python-coded ROPgadget. It’s a breeze to install inside our Kali box with
    **pip**. If you don’t have **pip** already installed, get that done with **apt
    install python3-pip**. Then, ROPgadget is a single step away:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.8 – The installation of ROPgadget with pip ](image/Figure_11.08_B17616.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11.8 – The installation of ROPgadget with pip
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s take a look at the options available to us, leaving out a couple of the
    processor-specific commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '**--binary** specifies our target, which can be in ELF format, PE format, Mach-object
    format, and raw.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**--opcode** searches for the defined opcodes in the executable segments of
    the binary, while **--string** searches for a given string in the readable segments
    of the binary. One use for **--string** is to look at specific functions, such
    as **main()**.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**--memstr** is your lifeline for borrowing characters from your target binary.
    Let’s suppose that you want to copy the ASCII characters, **sh**, into the buffer
    without injecting them. You pass the **--memstr "sh"** argument and ROPgadget
    will search for **\x73** and **\x68** in memory.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**--depth** means the same thing here as it does in MSFrop. Once a **ret**
    is found, this parameter is how many bytes back we’ll be searching for gadgets.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**--only** and **--filter** are the instruction filters. **--only** will hide
    everything but the specified instructions; **--filter** will show everything but the
    specified instructions.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**--range** specifies a range of memory addresses to limit our gadget search.
    Without this option, the entire binary will be searched.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**--badbytes** means exactly what you think it means, my weary shellcoder.
    Just when you thought that by borrowing code, you could escape the trouble of
    bytes that shatter both our shellcode and our dreams, experienced ROP engineers
    will run into this occasionally. It really doesn’t matter where the bytes are
    coming from; the break happens during execution. There’s another factor to bear
    in mind, too—the actual exploit code itself. In this chapter, we’ll be working
    with Python to generate our payload. We’ll be using the powerful **struct** module
    to pack binary data into strings that are then handled like any ordinary string
    variable by Python. Remember **--badbytes** when you’re sitting there with a broken
    script; it might be what you’re looking for.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**--rawArch** and **--rawMode** are used for defining 32-bit and 64-bit architectures
    and modes.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**--re** takes a regular expression (for example, **\x35**).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**--offset** takes a hex value as an offset for calculating gadget addresses.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**--ropchain** is a wonderful coup de grace option that generates the Python
    exploit code for us. It isn’t as easy as throwing it into a **.py** file and executing
    it; we need to know exactly how it’s being passed to the vulnerable program.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**--console** is for interactive gadget hunting. Essentially, it brings up
    a Terminal window within ROPgadget for conducting specific searches. We’ll take
    a look at it later.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**--norop**, **--nojop**, and **--nosys** disable the search engines for specific
    gadget types—return-oriented, jump-oriented, and system call instruction gadgets,
    respectively. When you’re trying to understand the full complement of gadgets
    available to you, you’ll generally want to avoid these options; they’re only for
    fine-tuned attacks.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By default, duplicate gadgets are suppressed; you can use **--all** to see everything.
    This is handy for gathering all of the memory addresses associated with your binary’s
    gadgets.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**--dump** is, essentially, an **objdump -x** object for your gadgets; this
    will display the disassembled gadgets and then their raw bytes.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There are several other great ROP programs available, but ROPgadget should get
    just about any of your projects done. Let’s prepare to take it out for a test
    drive by preparing our vulnerable executable.
  prefs: []
  type: TYPE_NORMAL
- en: Creating our vulnerable C program without disabling the protections
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The full breadth of ROP attacks deserves more space than we can offer here,
    so let’s build a small and relatively simple demonstration for an x86 Linux target
    environment. Fire up **vim buff.c** to prepare a new C file in the Vim editor.
    Type in the following familiar code:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.9 – The tried-and-true vulnerable program ](image/Figure_11.09_B17616.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11.9 – The tried-and-true vulnerable program
  prefs: []
  type: TYPE_NORMAL
- en: Now we can compile our fancy new program. But let’s try something different.
  prefs: []
  type: TYPE_NORMAL
- en: No PIE for you – compiling your vulnerable executable without ASLR hardening
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Hit *Esc* followed by **:wq!** to save and quit Vim; then, compile your executable.
    This time, let’s introduce Clang. The differences between GCC and Clang are outside
    the scope of this discussion, and similar to the editor war, you’ll find solid
    arguments on either side. Clang is more lightweight, and the compiled code it
    produces is a little “cleaner” for the purposes of our lab (it also runs natively
    on Windows). Fire it up and compile your new C program with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.10 – Disabling PIE hardening at compilation ](image/Figure_11.10_B17616.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11.10 – Disabling PIE hardening at compilation
  prefs: []
  type: TYPE_NORMAL
- en: 'Recall that when we originally created a *vulnerable C program*, the focus
    of its vulnerability was in the code (specifically, by using the infamous **strcpy()**
    function). This time, we’re using vulnerable code and compiling the executable
    with a vulnerable option enabled: **-no-pie**. When a **Position Independent Executable**
    (**PIE**) loads up in an ASLR environment, the kernel loads all the code and assigns
    random virtual addresses (except for the entry point, of course). Typically, security-sensitive
    executables are PIEs, but as you can see, this won’t necessarily be the case.
    In some distros—notably, Kali Linux—you have to explicitly disable compiling a
    PIE with Clang or GCC.'
  prefs: []
  type: TYPE_NORMAL
- en: Walk Before You Run – Disabling PIE
  prefs: []
  type: TYPE_NORMAL
- en: 'Similar to what we did with stack protection in [*Chapter 10*](B17616_10_Final_VK_ePub.xhtml#_idTextAnchor187),
    *Shellcoding – The Stack*, this demonstration disables a package hardening strategy
    that could be found in secure environments: PIEs. However, unlike the absence
    of DEP and ASLR, software with absolute addresses is still common in some enterprise
    environments.'
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have our lab executable, let’s understand the low-level mechanisms
    we are going to compromise.
  prefs: []
  type: TYPE_NORMAL
- en: Generating an ROP chain
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If you recall the humble vulnerable C programs we wrote earlier, this time around,
    you’ll notice something different. We’re already familiar with the **strcpy()**
    function, but in this program, we have the **system()** function. A part of the
    C standard library, **system()** will pass a command to the host to be executed.
  prefs: []
  type: TYPE_NORMAL
- en: We can grab individual bytes out of our program’s own code, link them together
    with returns, and pass whatever bytes we want to **system()**. The potential is
    there, but we have the problem of figuring out where **system()** is located.
    Let’s take the spirit of return-to-libc in a different direction.
  prefs: []
  type: TYPE_NORMAL
- en: Getting hands-on with the return-to-PLT attack
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: I say this about a lot of topics, but the **Procedure Linkage Table** (**PLT**)
    and the **Global Offset Table** (**GOT**) are subjects that deserve their own
    book. However, we’ll try to run through a crash course to understand how we’re
    going to get around memory space randomization. Our executable is not a position-independent
    executable thanks to our **-no-pie** compilation configuration, so the actual
    location of global structures in the program wasn’t known at compile time. The
    GOT is literally a table of addresses used by the executable during runtime to
    convert PIE addresses into absolute ones. At runtime, our executable needs its
    shared libraries; these are loaded and linked using the dynamic linker during
    the bootstrapping process. That is when the GOT is updated.
  prefs: []
  type: TYPE_NORMAL
- en: Since the addresses are dynamically linked at runtime, the compiler doesn’t
    really know whether the addresses in our non-position-independent code will be
    resolved from the GOT. So, with the **-no-pie** specification, the compiler does
    its usual thing of generating a call instruction; this is interpreted by the linker
    to determine absolute destination addresses and updates the PLT. Now I know what
    you’re thinking—the PLT and GOT kinda sound like the same thing. They’re similar
    concepts, and the GOT helps the position-independent programs maintain their hard-earned
    independence. But we have a dynamically-linked, non-position-independent executable.
    Here’s a simple distinction—the GOT is used for converting *address calculations*
    into absolute destination addresses, whereas the PLT is used for converting our *function
    calls* into absolute destinations.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let’s consider the return-to-PLT moniker. We’re setting up those ROP chains
    with our returns pointing to particular places to send the flow; in this scenario,
    we’re directing flow to the PLT function call and, thus, removing any need for
    address knowledge at runtime. Our linker is an unwitting accomplice to the crime.
  prefs: []
  type: TYPE_NORMAL
- en: Extracting gadget information for building your payload
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now, we’ll step through ROP chain and exploit generation. The return-to-PLT
    part is easy to figure out with **gdb**. It’s also easy to use ROPgadget for finding
    the bytes that we’re going to use to construct our chain. But what about writing
    into the program’s memory? First, let’s figure out where everything is.
  prefs: []
  type: TYPE_NORMAL
- en: Finding the .bss address
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We need to work with the program’s design to write data somewhere. We can use
    the **.bss** section of our executable for this task, as **.bss** is a place to
    put variables that don’t have any value just yet. Essentially, it’s space set
    aside for these variables; therefore, it won’t occupy space within the object
    file. For our purposes here, we just need to know where it is. Use the **info
    file** command in **gdb** to get a list of the sections with their ranges and
    take down the initial address of **.bss**:'
  prefs: []
  type: TYPE_NORMAL
- en: gdb buff
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: (gdb) info file
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s an example of a memory map from these commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.11 – File information in gdb ](image/Figure_11.11_B17616.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11.11 – File information in gdb
  prefs: []
  type: TYPE_NORMAL
- en: In our example, we’ll write down **0x0804c028** for **.bss**. Now, we’ll look
    for the pieces that will allow us to jump around the program’s code.
  prefs: []
  type: TYPE_NORMAL
- en: Finding a pop pop ret structure
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The **strcpy()** function pops off stack pointer offsets for source and destination
    arguments and then returns; therefore, the glue in our chain is a **pop pop ret** machine
    instruction structure. Thankfully, this is easy for ROPgadget’s **search** function.
    First, get into the interactive console mode, load the gadgets, and then conduct
    a search for the relevant structures. You’ll get a lot of hits, but you’re looking
    for a **pop pop ret** structure and then copying its address:'
  prefs: []
  type: TYPE_NORMAL
- en: ROPgadget --binary buff --depth 5 –console
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: (ROPgadget)> load
  prefs: []
  type: TYPE_NORMAL
- en: (ROPgadget)> search pop ; pop ; ret
  prefs: []
  type: TYPE_NORMAL
- en: 'The preceding command should produce the result shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.12 – Finding the pop pop ret gadgets in our program ](image/Figure_11.12_B17616.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11.12 – Finding the pop pop ret gadgets in our program
  prefs: []
  type: TYPE_NORMAL
- en: Note the depth of 5 bytes. Remember, that means we’re searching backward from
    a given return instruction by 5 bytes to find the gadgets. But we’re not done
    – we need to find the locations of the **system** and **strcpy** functions.
  prefs: []
  type: TYPE_NORMAL
- en: Finding addresses for the system@plt and strcpy@plt functions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Our **main()** function needs to call **system()** and **strcpy()**. This is
    a no-PIE target, so we’re looking for the addresses corresponding to **<system@plt>**
    and **<strcpy @plt>**. Use the **disas** command in **gdb** to investigate the
    **main()** function:'
  prefs: []
  type: TYPE_NORMAL
- en: gdb buff
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: (gdb) disas main
  prefs: []
  type: TYPE_NORMAL
- en: 'Remember that we’re using **strcpy()** to copy our chosen bytes into memory
    and **system()** to make an actual system command:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.13 – Identifying the locations for system@plt and strcpy@plt ](image/Figure_11.13_B17616.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11.13 – Identifying the locations for system@plt and strcpy@plt
  prefs: []
  type: TYPE_NORMAL
- en: At this point, we have four addresses in our notes. Now we just need to find
    the characters that represent our command. Thankfully, they’re already present
    in the program.
  prefs: []
  type: TYPE_NORMAL
- en: Finding target characters in memory with ROPgadget and Python
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The question of what specific command you’ll try to pass to **system()** is
    for you to decide. In our actual demo, I’m just launching **sh**. However, there’s
    potential for remote compromise here. Take the following **netcat** command as
    an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '**nc -e /bin/sh -lvnp 1066**'
  prefs: []
  type: TYPE_NORMAL
- en: 'This will set up a session with **sh** and pass it to a local listener on port
    **1066**. All we need are the precise locations in the vulnerable program where
    we can find the characters needed to construct this line. This sounds daunting,
    but ROPgadget is here to save us a lot of time with the **--memstr** flag. Naturally,
    we only need a single memory address per character, so it’d be cleanest to just
    pass a string of the unique characters in our **bash** command. Use Python for
    this task, look slick, and impress your friends. Start the interactive interpreter
    with **python3** and then run this command:'
  prefs: []
  type: TYPE_NORMAL
- en: '''''.join(set(''nc -e /bin/sh -lvnp 1066''))'
  prefs: []
  type: TYPE_NORMAL
- en: 'This should spit out a clean one-per-unique-character result that you can then
    pass to ROPgadget, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.14 – A clean way to handle repeated characters ](image/Figure_11.14_B17616.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11.14 – A clean way to handle repeated characters
  prefs: []
  type: TYPE_NORMAL
- en: 'Use **exit()** to close the interpreter, and then pass the result of that command
    as an argument to **--memstr**:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.15 – Memory locations for each byte ](image/Figure_11.15_B17616.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11.15 – Memory locations for each byte
  prefs: []
  type: TYPE_NORMAL
- en: For our lab, we’ll keep it simple—let’s just find the characters for **sh;**
    and see whether we can pass that to **system**. Finally, let’s look at how it
    comes together.
  prefs: []
  type: TYPE_NORMAL
- en: Go, go, gadget ROP chain – bringing it together for the exploit
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We’re so close, but there’s one last variable to figure out—our offset to the
    return address. This is more of the traditional overflow research for injecting
    shellcode. So, back we go into the debugger.
  prefs: []
  type: TYPE_NORMAL
- en: Finding the offset to return with gdb
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Our chain starts with a **strcpy()** function. We’ve overwritten EIP before,
    which tells the processor where to find the next instruction (why, in a grand
    field of NOPs, of course). In this case, we’re adjusting where we’ll *return* to,
    essentially spoofing the calling frame. Therefore, we need to overflow deeply
    enough to overwrite the stack base pointer EBP. Once we find this sweet spot,
    we can send the flow to our first **strcpy()** function by overwriting it with
    our **strcpy@plt** address:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.16 – The calling frame and current frame layout ](image/Figure_11.16_B17616.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11.16 – The calling frame and current frame layout
  prefs: []
  type: TYPE_NORMAL
- en: 'At this point, this should simply be a review for you. We’re firing up **gdb**
    and executing the **run** command with the test input. The easiest way to do this
    is with a Python call; for example, within **gdb**, and with our target executable
    loaded: **run $(python -c ''print "z" * 1028 + "AAAA"'')**. We understand that
    this will load up 1,028 z’s -- hexadecimal **0x7a**—and then 4 A’s -- hexadecimal
    **0x41**. So, we’ll know we landed on the sweet spot when we see that we pushed
    **0x41414141** into EBP:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.17 – Examining memory after the expected segfault ](image/Figure_11.17_B17616.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11.17 – Examining memory after the expected segfault
  prefs: []
  type: TYPE_NORMAL
- en: In this case, let’s check out the value of EBP. What’s our offset? Once you’ve
    figured that out, let’s look at how it might be conveyed via Python.
  prefs: []
  type: TYPE_NORMAL
- en: Writing the Python exploit
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Finally, we can bring it together. Again, we’re testing **sh;** in this exploit.
    Let’s step through what’s going on:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.18 – The exploit in Python ](image/Figure_11.18_B17616.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11.18 – The exploit in Python
  prefs: []
  type: TYPE_NORMAL
- en: Hopefully, it’s clear that this is pretty repetitive—once you figure out the
    chain, it’s fairly trivial to construct longer ones. Bear in mind that because
    of how Python 3 handles types, we’re just using Python 2 with this example. You
    can upgrade it for Python 3 as long as you convert your string into bytes first.
  prefs: []
  type: TYPE_NORMAL
- en: Note we’ve imported **pack()** from the **struct** module. This function allows
    us to work with raw binary within Python by treating it like any ordinary string.
    If you’re feeling particularly masochistic, you can just pass the regex representation
    of the packed bytes directly to the program as an argument. I have a feeling you’ll
    try this way first. There are two arguments—the byte ordering and type, and the
    data itself. The **<** character is important for any Intel exploit—that’s our
    little-endian ordering.
  prefs: []
  type: TYPE_NORMAL
- en: 'The location of the **strcpy()** function and our **pop pop ret** structure
    are declared first, as they’re used with each chain link. After that, the pattern
    is pretty easy:'
  prefs: []
  type: TYPE_NORMAL
- en: Enough fluff (1,028 bytes of the character **z**) to reach the return.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Overwrite with the address of **strcpy()** and return to **pop pop ret**. Note
    that the **pop pop** structure isn’t really important to us; the bytes have been
    copied into memory and we’re hitting the return. Rinse and repeat.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Nab the first byte representing the character in our command and place it in
    **.bss**, byte by byte, using **strcpy()** and **pop pop ret** to return, thus
    keeping the chain going.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: End with a junk terminator and make that call to **system()**, pointing back
    at the base address of **.bss**. At this point, starting at that base address,
    **sh** should reside in memory. If all goes as planned, **system()** will execute
    **sh.**
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The keywords are—*if all goes as planned*. A real target environment isn’t going
    to look like your lab, and there are numerous factors that can cause this attack
    to fail. It requires fine-tuning, but in a world where large enterprises are clinging
    to legacy applications, we see these attacks and their variants today. Hopefully,
    this introduction will springboard you into deeper research on all things ROP.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For a couple of years now, some security professionals have been sounding the
    death knell of ROP. It’s considered old and unreliable, and new technology promises
    to mitigate even a carefully constructed exploit with shadow registers that track
    returns during an execution flow. Then again, Windows XP has been dead for several
    years, but anyone spending time in large production environments today is bound
    to see it still clinging for life, running legacy applications.
  prefs: []
  type: TYPE_NORMAL
- en: Today, a significant effort in many organizations is not replacing XP but rather
    indirect mitigation via the network or third-party software controlling the execution
    of code. ROP is still relevant for the time being, even if just to verify that
    it doesn’t work in your client’s environment. The unique nature of this attack
    renders it particularly dangerous, despite its current signs of aging.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we reviewed DEP and ASLR as theoretical concepts and demonstrated
    these technologies in action on Linux. We introduced ROP and two primary tools
    of the trade: MSFrop and ROPgadget. We typed up a C program with a critical vulnerability
    and left the default protections intact. The remainder of the chapter was spent
    covering the fundamentals of ROP, return-to-PLT, return-to-libc, and gadget discovery
    and review. We explored how to bring the pieces together for a functioning exploit.'
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we’ll wrap up our shellcoding review by diving into the
    world of antivirus evasion. Instead of bypassing stack protection mechanisms,
    we’ll learn how to piggyback our code inside an injected executable, and we’ll
    learn how to pass our shellcode to a script interpreter. We’ll get hands-on with
    PowerShell to learn how to live off the land and take advantage of PowerShell’s
    privileged position in the Windows operating system.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Answer the following questions to test your knowledge of this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Name the two types of DEP in Windows.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Define **libc**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How many bytes long can a gadget be prior to its return?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**gcc -no-pie** disables ______________ hardening.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What’s the difference between the PLT and the GOT?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What’s a quick and easy way to find **system@plt** with gdb?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Why won’t the **pack(">I", 0x0804a02c)** function work in the ROP context on
    an x86 processor?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For more information regarding the topics that were covered in this chapter,
    take a look at the following resources:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Black Hat presentation on ROP: [https://www.blackhat.com/presentations/bh-usa-08/Shacham/BH_US_08_Shacham_Return_Oriented_Programming.pdf](https://www.blackhat.com/presentations/bh-usa-08/Shacham/BH_US_08_Shacham_Return_Oriented_Programming.pdf)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Presentation on ROP by the creator of ROPgadget: [http://shell-storm.org/talks/ROP_course_lecture_jonathan_salwan_2014.pdf](http://shell-storm.org/talks/ROP_course_lecture_jonathan_salwan_2014.pdf)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
