- en: '*Chapter 13*: Windows Kernel Security'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第13章*：Windows内核安全'
- en: The kernel is the colonel of the operating system. It’s the software that allows
    the **Operating System** (**OS**) to link applications to hardware, translating
    application requests into instructions for the CPU. In fact, it’s hard to distinguish
    an operating system per se from its kernel; it is the heart of the OS. A bug in
    a user’s application may cause crashes, instability, slowness, and so on, but
    a bug in the kernel can crash the entire system. An even more devastating potential
    is arbitrary code execution with the highest privileges available on the OS. Kernel
    attacks are a hacker’s dream.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 内核是操作系统的“军官”。它是允许**操作系统**（**OS**）将应用程序与硬件连接的软件，将应用程序请求转化为CPU指令。实际上，很难将操作系统本身与其内核区分开；它是操作系统的核心。用户应用程序中的错误可能导致崩溃、不稳定、变慢等问题，但内核中的错误可能导致整个系统崩溃。一个更具破坏性的潜在威胁是以操作系统上最高权限执行任意代码。内核攻击是黑客的梦想。
- en: Absolutely everything in an OS works with the kernel in some form. As the core
    of the OS, the kernel requires isolation from the less-privileged processes on
    the system; without isolation, it could be corrupted, and a corrupt kernel renders
    the system unusable. This isolation is accomplished by rendering the kernel’s
    space in memory as off-limits to processes on the user side. Despite this, full
    isolation would make the computer useless for users and their applications – interfaces
    are a necessity. These interfaces create doorways for the attacker into the highest
    privilege level possible on a Windows computer.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 操作系统中的一切都以某种形式与内核协作。作为操作系统的核心，内核需要与系统中权限较低的进程隔离；如果没有隔离，内核可能会受到破坏，而被破坏的内核将导致系统无法使用。这种隔离通过将内核在内存中的空间设置为用户侧进程无法访问来实现。尽管如此，完全的隔离会使计算机对于用户和应用程序变得无用——接口是必需的。这些接口为攻击者提供了进入Windows计算机最高权限级别的大门。
- en: An in-depth discussion of the Windows NT kernel is out of scope for this chapter,
    but we’ll introduce kernel security concepts and step through a Metasploit exploit
    module against the Windows kernel to better understand how it works. We’ll provide
    a hands-on introduction to exploiting a kernel vulnerability to elevate privileges
    on a Windows target.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 对Windows NT内核的深入讨论超出了本章的范围，但我们将介绍内核安全概念，并通过一个Metasploit漏洞利用模块来演示如何攻击Windows内核，以便更好地理解它的工作原理。我们将提供一个实践入门，教你如何利用内核漏洞在Windows目标上提升权限。
- en: 'In this chapter, we’ll cover the following:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下内容：
- en: An overview of kernel concepts and attacks
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 内核概念和攻击的概述
- en: The concept of pointers to illustrate null pointer flaws
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用指针概念来说明空指针缺陷
- en: Code from the Metasploit module to exploit the CVE-2014-4113 vulnerability
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Metasploit模块中的代码，用于利用CVE-2014-4113漏洞
- en: A demonstration of leveraging this module for privilege escalation after gaining
    a foothold on a Windows 7 target
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Windows 7目标机器上获取立足点后，演示如何利用该模块进行权限提升
- en: Technical requirements
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'The technical requirements for this chapter are as follows:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的技术要求如下：
- en: Kali Linux
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Kali Linux
- en: A Windows 7 target PC or virtual machine
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一台Windows 7目标PC或虚拟机
- en: WinDbg for further debugging study (not necessary to complete the exercise)
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用于进一步调试学习的WinDbg（完成练习不必要）
- en: The IDA disassembler for analyzing binaries and drivers (not necessary to complete
    the exercise)
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用于分析二进制文件和驱动程序的IDA反汇编器（完成本练习不必要）
- en: Kernel fundamentals – understanding how kernel attacks work
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 内核基础——理解内核攻击是如何工作的
- en: A crucial philosophical point to remember is that the kernel is a computer program.
    It’s a construct that can be rather intimidating for us lowly noobs, so it helps
    to remember the true nature of the beast. The casual flaws you learn about in
    ordinary programming can all occur in kernel code. The kernel occupies memory,
    just like any ordinary program, so the potential to put something where it doesn’t
    belong and execute it exists. If this is the case, what makes the kernel so special?
    The kernel manages all low-level functions by interfacing the hardware of a computer
    and the software of an OS. There are many, many different programs running on
    a modern instance of Windows, and they all want to use one processor at the same
    time. The programs can’t decide who gets how much time, and the processor dumbly
    completes operations – it can’t decide, either. It’s the kernel that functions
    as the cop, managing all the high-level interactions with the lowest-level structures
    of the system. The next time you’re marveling at the multitasking ability of a
    computer that isn’t actually capable of multitasking, thank the kernel for providing
    that illusion to you.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 需要记住的一个重要哲学观点是，内核是一个计算机程序。它是一个构造体，对于我们这些普通的小白来说，可能会感到有些令人生畏，所以有助于记住它的真实面目。在普通编程中你学到的日常缺陷，都可能出现在内核代码中。内核占用内存，就像任何普通程序一样，因此存在将某些东西放到不该放的地方并执行的可能性。如果是这样，那内核到底有什么特别之处呢？内核通过连接计算机的硬件和操作系统的软件来管理所有低级功能。在现代Windows实例中，有许多不同的程序同时运行，它们都想使用同一个处理器。程序无法决定谁能获得多少时间，而处理器则愚蠢地完成操作——它也无法做出决定。是内核充当了警察的角色，管理所有与系统最低级结构的高层次交互。下次你对一台实际上并不具备多任务处理能力的计算机的多任务能力感到惊讶时，记得感谢内核为你提供了这一幻觉。
- en: 'Windows is an example of an OS that uses a dual-mode architecture – user and
    kernel (sometimes called user and supervisor). Thus, the memory space is split
    into two halves, and user mode cannot access kernel space. Kernel mode, on the
    other hand, has the highest authority and can access any part of the system and
    hardware. The kernel is ultimately the mediator between the actual hardware and
    the OS. In Windows, the interface with hardware is provided by the **Hardware
    Abstraction Layer** (**HAL**), which, as the name suggests, creates a layer of
    abstraction to, for instance, normalize differences in hardware. Kernel mode drivers
    provide interfaces for applications requesting access to hardware; even something
    taken for granted such as an application wishing to display data on the screen
    must work with a kernel mode driver. The beauty of these structures is they create
    a layer of abstraction and a single familiar environment for applications to work
    with. A Windows developer doesn’t need to worry about the different monitors that
    may be displaying their program to the user:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: Windows是一个使用双模式架构的操作系统示例——用户模式和内核模式（有时称为用户模式和监督模式）。因此，内存空间被分为两部分，用户模式无法访问内核空间。另一方面，内核模式具有最高的权限，可以访问系统和硬件的任何部分。内核最终是实际硬件与操作系统之间的中介。在Windows中，硬件的接口由**硬件抽象层**（**HAL**）提供，顾名思义，它创建了一个抽象层，旨在规范硬件差异。例如，内核模式驱动程序为请求访问硬件的应用程序提供接口；甚至像应用程序希望在屏幕上显示数据这样的事情，也必须与内核模式驱动程序合作。这些结构的美妙之处在于它们为应用程序提供了一个抽象层和一个单一的熟悉环境。Windows开发人员不需要担心可能会显示其程序的不同显示器：
- en: '![Figure 13.1 – How Windows interacts with hardware ](image/Figure_13.1_B17616.jpg)'
  id: totrans-18
  prefs: []
  type: TYPE_IMG
  zh: '![图13.1 – Windows如何与硬件交互](image/Figure_13.1_B17616.jpg)'
- en: Figure 13.1 – How Windows interacts with hardware
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.1 – Windows如何与硬件交互
- en: Kernel attack vectors
  id: totrans-20
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 内核攻击向量
- en: 'The security implications of the kernel are both profound in the sense of potential
    impact and the extremely low-level activity happening within the kernel, and also
    straightforward in the sense that the kernel is software written by people (say
    no more). Some attack vectors that we consider when examining the kernel concept
    are as follows:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 内核的安全性问题既深远（潜在影响巨大）也简单明了（因为内核是由人编写的软件，细节无需多说）。在检查内核概念时，我们考虑的一些攻击向量如下：
- en: '**APIs**: If the kernel doesn’t allow some means for applications to access
    its functionality, there’s no point in a computer and we might as well all go
    home. The potential exists via the APIs for arbitrary code to be executed in kernel
    mode, giving an attacker’s shellcode all the access it needs for total compromise.'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**API**：如果内核不允许某些方式让应用程序访问其功能，那么计算机就没有意义，我们还不如回家去。通过API，潜在的恶意代码可能在内核模式下执行，使攻击者的shellcode获得完全访问权限，从而实现完全的攻击。'
- en: '**Paddling upstream from hardware**: If you examine the design of the Windows
    OS, you’ll notice that you can get intimate with the kernel in a more direct way
    from the hardware side of the system hierarchy. Malicious driver design can exploit
    the mechanisms that map the hardware device into virtual memory space.'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**从硬件向上划水**：如果你检查Windows操作系统的设计，你会注意到，你可以从系统层次结构的硬件侧更直接地接触内核。恶意驱动程序的设计可以利用将硬件设备映射到虚拟内存空间的机制。'
- en: '**Undermining the boot process**: The OS has to be brought up at boot time,
    and this is a vulnerable time for the system. If the boot flow can be arbitrarily
    controlled, it may be possible to attack the kernel before various self-protections
    are initialized.'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**破坏引导过程**：操作系统需要在启动时加载，这时是系统的一个脆弱时刻。如果引导流程可以被任意控制，可能在各种自我保护机制初始化之前，就能够攻击内核。'
- en: '**Rootkits**: A kernel-mode rootkit in Windows typically looks like a kernel-mode
    driver. Successful coding of such malware is a very delicate balancing act due
    to the nature of the kernel’s code; couple that with modern protections such as
    driver signing, and this is getting harder and harder to pull off. It isn’t impossible
    though, and regardless, older OSs are still a reality in many environments. It’s
    important for the pen tester to be aware of the attacks that the security industry
    likes to describe as *on their way out the door*.'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Rootkit**：Windows中的内核模式rootkit通常表现为内核模式驱动程序。成功编写这种恶意软件是一项非常精细的平衡工作，因为内核代码的性质；再加上现代的保护措施，如驱动程序签名，使得这种攻击越来越难以实现。然而，这并非不可能，且无论如何，老旧操作系统在许多环境中仍然存在。渗透测试人员需要意识到那些安全行业喜欢描述为*正在退出历史舞台*的攻击方式。'
- en: The kernel’s role as a time cop
  id: totrans-26
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 内核作为时间警察的角色
- en: There are various pieces of magic that a modern OS needs to perform, and the
    kernel is the magician. One example is context switching, which is a technique
    that allows numerous processes to share a single CPU. Context switching is the
    actual work of putting a running thread on hold and storing it in memory, getting
    another thread up and running with CPU resources, and then putting the second
    thread on hold and storing it in memory before recalling the first thread. There’s
    no way around the fact that this takes time to do, so some of the latency in a
    processor is found in context switching; one of the innovations in OSs is developing
    ways to cut this time down as much as possible.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 现代操作系统需要执行各种“魔法”，而内核就是魔术师。一个例子是上下文切换，这是一种允许多个进程共享单个CPU的技术。上下文切换的实际工作是将正在运行的线程挂起并存储到内存中，调度另一个线程使用CPU资源运行，然后将第二个线程挂起并存储到内存中，再调回第一个线程。无法避免的是，这个过程需要时间，因此处理器的一部分延迟就来自上下文切换；操作系统的一个创新是在尽可能减少这一时间。
- en: Of course, we’re rarely fortunate enough to have to worry about just two little
    threads trying to run on the same processor – there are often dozens waiting,
    so the task of prioritizing becomes necessary. Prioritizing threads is a part
    of the work of the scheduler. The scheduler decides who gets what slice of time
    with the processor and when. What if a process doesn’t want to give up its time
    with the processor? In a cooperative multitasking OS, the process needs to be
    finished with resources before they will be released. On the other hand, in a
    preemptive multitasking OS, the scheduler can interrupt a task and resume it later.
    I’m sure you can imagine the security implications of an OS that’s unable to context
    switch with a thread that refuses to relinquish resources. Thankfully, modern
    OSs are typically preemptive. In fact, in the case of Windows, the kernel itself
    is preemptive – this simply means that even tasks running in kernel mode can be
    interrupted.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，我们很少有幸运的机会需要担心仅有两个小线程试图在同一处理器上运行——通常有几十个线程在等待，所以需要优先级管理。线程优先级是调度器的工作之一。调度器决定谁在什么时间片段内使用处理器。如果一个进程不愿意放弃它与处理器的时间呢？在合作式多任务操作系统中，进程需要完成资源的使用才会释放资源。另一方面，在抢占式多任务操作系统中，调度器可以中断任务，并稍后恢复它。你可以想象一下，一个操作系统如果无法与一个拒绝释放资源的线程进行上下文切换会带来怎样的安全隐患。幸运的是，现代操作系统通常是抢占式的。实际上，在Windows操作系统中，内核本身就是抢占式的——这意味着即使是内核模式下运行的任务也可以被中断。
- en: 'Even young children can grasp one of the fundamental rules of existence – events
    don’t always happen at once, and you often have to wait for something to happen.
    You have to go to school for a whole week before the fun of the weekend starts.
    Even at the extraordinarily small scale of the tiny slices of time used in context
    switching and scheduling, sometimes we have to wait around for something to happen
    before we can proceed. Programmers and reverse engineers alike will see these
    time-dependent constructs in code:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 即使是年幼的孩子也能理解存在的基本规则之一——事件并不总是同时发生，你通常需要等待某件事情发生。你必须上整整一周的学，才能迎来周末的乐趣。即使是在上下文切换和调度所用的极其微小的时间片尺度上，我们有时也需要等待某件事情发生才能继续前进。程序员和逆向工程师都会在代码中看到这些时间依赖的构造：
- en: Grab the value of the **VAR** variable; use an **if**/**then** statement to
    establish a condition based on this fetched value.
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 获取**VAR**变量的值；使用**if**/**then**语句根据获取的值建立条件。
- en: Grab the value of the **VAR** variable; use it in a function according to the
    condition(s) established in *step 1*.
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 获取**VAR**变量的值；根据*第1步*中建立的条件在函数中使用该值。
- en: Grab the value of the **VAR** variable; use it in a function according to the
    condition(s) established in *step 1* and *step 2*, and so on.
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 获取**VAR**变量的值；根据*第1步*和*第2步*中建立的条件在函数中使用该值，依此类推。
- en: Imagine if we could create a condition that would cause these dependencies to
    occur out of their prescribed order. For example, what if I could cause *step
    2* to happen first? In this case, the code is expecting a condition to have been
    established already. An attacker may thus trigger an exploit by racing against
    the established order – this is called a **race condition**.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下，如果我们能创建一个条件，使得这些依赖关系按照预定顺序发生。例如，如果我能让*第2步*先发生呢？在这种情况下，代码期望某个条件已经建立。攻击者可能通过与已建立的顺序竞争来触发漏洞——这就是**竞态条件**。
- en: It’s just a program
  id: totrans-34
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它只是一个程序
- en: From a security perspective, one of the most crucial points to understand about
    the kernel is that it’s technically a program made up of code. The real distinction
    between a flaw in the kernel and a flaw in code on the user side is the privilege;
    any piece of code running at the kernel level can own the system because the kernel *is* the
    system.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 从安全角度来看，理解内核最关键的一点是，它本质上是由代码组成的程序。内核中的缺陷与用户端代码中的缺陷的真正区别在于权限；任何在内核级别运行的代码都可以拥有整个系统，因为内核*就是*系统。
- en: Crashing the kernel results in an irrecoverable situation (namely, it requires
    a reboot), whereas crashing a user application just requires restarting the application
    – so, exploring kernel attacks is more precarious and there is far less room for
    mistakes. It’s still just a computer program, though. I emphasize this because
    we can understand the kernel attack in this chapter from a programmer’s perspective.
    The kernel is written in a mix of assembly and C (which is useful due to its low-level
    interface ability), so let’s take a look at a basic programming concept from a
    C and assembly point of view before we dive into exploiting our Windows target.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
- en: Pointing out the problem – pointer issues
  id: totrans-37
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Programming languages make use of different data types: numeric types such
    as integers, Boolean types to convey true and false, sets and arrays as composite
    data types, and so on. Pointers are yet another kind of data type – a reference.
    References are values that refer to data indirectly. For example, suppose I have
    a book with a map of each of the states of the United States on each page. If
    someone asks me where I live, I could say *page 35* – an indirect reference to
    the data (the state map) on that particular page. References as a data type are,
    in themselves, simple, but the datum to which a reference refers can itself be
    a reference. Imagine the complexity that is possible with this cute little object.'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
- en: Dereferencing pointers in C and assembly
  id: totrans-39
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Pointers, as a reference data type, are considered low-level because their
    values are used as memory addresses. A pointer points at a datum, and the actual
    memory address of the datum is therefore the value of the pointer. The action
    of using the pointer to access the datum at the defined memory address is called **dereferencing**.
    Let’s take a look at a sample C program that plays around with pointers and dereferencing,
    and then a quick peek at the assembly of the compiled program:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '[PRE1]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '[PRE2]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '[PRE3]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '[PRE4]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '[PRE5]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '[PRE6]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '[PRE7]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '[PRE8]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '[PRE9]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '[PRE10]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '[PRE11]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The compiled program generates this output:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.2 – The output of our pointer program ](image/Figure_13.2_B17616.jpg)'
  id: totrans-54
  prefs: []
  type: TYPE_IMG
- en: Figure 13.2 – The output of our pointer program
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
- en: Our following assembly examples are 64-bit (hence, for example, **RBP**), but
    the concepts are the same. However, we’re sticking with Intel syntax despite working
    in Linux, which uses AT&T syntax – this is to stay consistent with the previous
    chapter’s introduction to assembly. Remember, source and destination operands
    are reversed in AT&T notation!
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
- en: 'Take a look at what happens at key points in the assembled program. Declaring
    the **x** integer causes a spot in memory to be allocated for it. **int x = 10;**
    looks like this in assembly:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Thus, the **10** value is moved into the **4**-byte location at the base pointer,
    minus **20**. Easy enough. (Note that the actual size of the memory allocated
    for our variable is defined here – **DWORD**. A double word is 32 bits, or 4 bytes,
    long.) But now, check out what happens when we get to **int *point = &x;** where
    we declare the int pointer, ***point**, and assign it the actual memory location
    of **x**:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '[PRE14]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The **lea** instruction means **load effective address**. Here, the **RAX**
    register is the destination, so what’s really being said here is to put the address
    of the minus **20** base pointer into the **RAX** register. Next, the value in
    **RAX** is moved to the quadword of memory (8 bytes) at the minus **8** base pointer.
    So far, we set aside 4 bytes of memory at the minus **20** base pointer and placed
    the **10** integer there. Then, we took the 64-bit address of this integer’s location
    in memory and placed that value into memory at the minus **8** base pointer. In
    short, the **x** integer is now at **RBP - 20**, and the address at **RBP - 20**
    is now stored as a pointer in **RBP - 8**.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
- en: 'When we dereference the pointer with **int deref = *point;**, we see this in
    assembly:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '[PRE16]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '[PRE17]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'To understand these instructions, let’s quickly review the registers. Remember
    that **EAX** is a 32-bit register in IA-32 architecture; it’s an extension of
    the 16-bit **AX**. In x64 architecture, **RAX** is a 64-bit register, but remember
    that being backward-compatible, it follows the same principle – **RAX** is an
    extension of **EAX**:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.3 – 64-bit registers ](image/Figure_13.3_B17616.jpg)'
  id: totrans-68
  prefs: []
  type: TYPE_IMG
- en: Figure 13.3 – 64-bit registers
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
- en: The square brackets, **[ ]**, distinguish the contents of a memory location
    or register. So first, we’re putting the quadword value pointed to by **RBP -
    8** into the **RAX** register, then we’re loading the **DWORD** value that **RAX**
    is pointing to into the **EAX** register, and finally, the **DWORD** in **EAX**
    is placed in a **DWORD**-sized chunk of the memory at the minus **12** base pointer.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
- en: Remember that **RBP - 8** contained the address of our integer, **x**. So, as
    you can see in the assembly code, we managed to get that integer stored in another
    place in memory by pointing to a pointer that was pointing at our integer.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
- en: Understanding NULL pointer dereferencing
  id: totrans-72
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now that we’ve reviewed pointer basics, we can define NULL pointer dereferencing
    – it’s when a program uses a pointer to access the memory location to which it
    points (dereference), but the pointer’s value is NULL. If you try to recall from
    our introduction to shellcoding, our program tried to access **0x7a7a7a7a** when
    we overwrote the return with the ASCII letter **z**, so in the case of a NULL
    pointer, an invalid location in memory is trying to be accessed. The difference
    is that we aren’t overwriting the pointer value with arbitrary bytes; it’s NULL
    – an address that simply doesn’t exist. The result is always some sort of a fault,
    but the resulting behavior can be unpredictable. With this being the case, why
    are we concerned with NULL pointer dereferencing?
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
- en: I know what the hacker in you is saying, *it’s pretty obvious that exploiting
    a NULL pointer dereference vulnerability results in a denial of service*. Perhaps,
    grasshopper, but it’s a little more complicated than that. For one, the memory
    addresses starting at **0x00000000** may or may not be mapped – that is, if a
    NULL pointer’s value is literally zero, it may be possible to end up in a legitimate
    memory location. If it isn’t a valid memory location, we get a crash; but if it
    is valid, and there’s some tasty shellcode waiting there, then we have ourselves
    code execution. Another scenario to consider is that the pointer is not properly validated before
    being dereferenced. The actual value may not be NULL in this case, but the attack
    is effectively the same. For our analysis, we’ll pick on a well-known Windows
    vulnerability from 2014 – CVE-2014-4113.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
- en: Probably the most common way of referring to known vulnerabilities is with their
    **Common Vulnerabilities and Exposures** (**CVE**) designation. The CVE is a catalog
    of software-based threats sponsored by the US federal government. Vulnerabilities are
    defined as flaws that can give an attacker direct access to systems or data, whereas
    an exposure is a flaw that allows indirect access to systems or data. The CVE
    convention is **CVE-<year>-<ID number>**.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
- en: The Win32k kernel-mode driver
  id: totrans-76
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: CVE-2014-4113 is also known by its Microsoft security bulletin designation,
    MS14-058\. It is an **Elevation of Privilege** (**EoP**) vulnerability in the
    kernel-mode driver **Win32k.sys**. I don’t know if the name **Win32k.sys** makes
    this apparent, but a bug in this particular driver is very bad news for a Windows
    system.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
- en: The **Win32k.sys** driver is the kernel side of some core parts of the Windows
    subsystem. Its main functionality is the GUI of Windows; it’s responsible for
    window management. Any program that needs to display something doesn’t talk to
    graphics hardware directly. Instead, it interfaces via the **Graphics Device Interface**
    (**GDI**), which is managed by **Win32k.sys**. User mode window management talks
    to **Win32k.sys** through User32 DLLs from the **Client/Server Runtime Subsystem**
    (**CSRSS**) user-side service. Drivers provide access for entities to their functionality
    via entry points, and **Win32k.sys** has about 600 of them. This highly complex
    interaction and core functionality make security a bit of a nightmare for something
    like **Win32k.sys**.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '**Win32k.sys** 驱动程序是 Windows 子系统某些核心部分的内核端。它的主要功能是 Windows 的图形用户界面（GUI）；负责窗口管理。任何需要显示内容的程序都不会直接与图形硬件交互。相反，它通过
    **图形设备接口**（**GDI**）进行接口，而 **Win32k.sys** 负责管理该接口。用户模式的窗口管理通过 **Client/Server Runtime
    Subsystem**（**CSRSS**）用户端服务中的 User32 DLL 与 **Win32k.sys** 进行通信。驱动程序通过入口点提供对其功能的访问，**Win32k.sys**
    大约有 600 个这样的入口点。这个高度复杂的交互和核心功能使得像 **Win32k.sys** 这样的组件在安全性方面成为一场噩梦。'
- en: 'This is a highly simplified depiction of the place of **Win32k.sys** in the
    Windows kernel and its relationship to userland:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个极其简化的图示，展示了 **Win32k.sys** 在 Windows 内核中的位置及其与用户空间的关系：
- en: '![Figure 13.4 – Win32k.sys interaction with the kernel ](image/Figure_13.4_B17616.jpg)'
  id: totrans-80
  prefs: []
  type: TYPE_IMG
  zh: '![图 13.4 – Win32k.sys 与内核的交互](image/Figure_13.4_B17616.jpg)'
- en: Figure 13.4 – Win32k.sys interaction with the kernel
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 图 13.4 – Win32k.sys 与内核的交互
- en: 'Note that this depiction also physically relates to memory, as userland is
    the lower portion of memory (at the top of the figure), and kernel land occupies
    the upper portion. **0x00000000** to **0x7FFFFFFF** is user space, and application
    virtual memory spaces occupy certain regions within it; the remainder, **0x80000000**
    to **0xFFFFFFFF**, is the almighty kernel. Windows design is not dumb – you can’t
    just arbitrarily execute something in kernel land:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，这个图示在物理上也与内存相关，因为用户空间位于内存的下半部分（图示的顶部），而内核空间占据上半部分。**0x00000000** 到 **0x7FFFFFFF**
    是用户空间，应用程序的虚拟内存空间占据其中的某些区域；剩余部分 **0x80000000** 到 **0xFFFFFFFF** 是强大的内核空间。Windows
    的设计并不傻——你不能随意在内核空间执行某些操作：
- en: '![Figure 13.5 – Exploiting Win32k.sys ](image/Figure_13.5_B17616.jpg)'
  id: totrans-83
  prefs: []
  type: TYPE_IMG
  zh: '![图 13.5 – 利用 Win32k.sys](image/Figure_13.5_B17616.jpg)'
- en: Figure 13.5 – Exploiting Win32k.sys
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 图 13.5 – 利用 Win32k.sys
- en: What we hope to accomplish is tricking code running in kernel mode to execute
    our payload within user space. We don’t need to trespass in the kernel’s backyard
    to get something running with the kernel’s high privileges.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望实现的目标是通过在内核模式下运行的代码来执行我们在用户空间中的有效载荷。我们不需要进入内核的“后院”就能让某些操作在内核的高权限下执行。
- en: Passing an error code as a pointer to xxxSendMessage()
  id: totrans-86
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 传递一个错误代码作为 xxxSendMessage() 的指针
- en: There’s a lot of complexity in **Win32k.sys**, and we don’t have time to even
    scratch the surface, so let’s hone in on the vulnerable structures that we will
    be attacking with our module in the next section. Remember that **Win32k.sys**
    is largely responsible for window management, including handling requests from
    applications to output something to a display. There’s a function inside **Win32k.sys**
    called **xxxMNFindWindowFromPoint()** that is used to identify the window that
    is occupying a particular location on the screen (a point, given in *X* and *Y*
    coordinates). This function will return the memory address of a C++ structure
    called **tagWND** (**WND** means window; this is all window management), but if
    there’s an error, the function returns error codes – **-1** and **-5**. In a classic
    programming oversight, the caller of this function does check for the return of
    **-1**, but there isn’t a check for **-5**. As long as the zero flag isn’t set
    when the following simple comparison is executed – **cmp ebx,0FFFFFFFFh** – the
    program happily continues, knowing that it has a valid memory pointer returned
    from the called function. The invalid pointer vulnerability is born.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s take a look at the flow of execution through **Win32k.sys** with IDA.
    In my IDA session with the driver, I identify **sub_BF8B959D** as the **xxxSendMessage()**
    function (**sub** stands for subroutine). The critical moment is visible in **loc_BF9392D8** (**loc**
    for location in memory):'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '[PRE19]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The value in the **EBX** register is checked against the **-1** value (note
    the hexadecimal value is a signed integer; hence **0xFFFFFFFF** is equal to **-1**). **jnz**
    jumps if the zero flag is not set; remember, that’s just assembly talk for a jump
    to the specified location if the two compared values are *not* the same.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
- en: Let’s do a quick review of conditional jumps in assembly. The principles of
    *jump if zero* or *jump if not zero* refer to the result of a comparison. Suppose
    you have the **x** and **y** variables. It’s a plain logical statement that **x
    - x = 0**. Therefore, if **x - y = 0**, then we know that **x = y**. **jnz** and
    **jz** will check the zero flag in the flags register to check the result of the
    comparison.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
- en: 'So, if the value in **EBX** is not **-1**, then we jump to **loc_BF9392EB**:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '[PRE21]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '[PRE22]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '[PRE23]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '[PRE24]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Let’s take a look at this in IDA.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.6 – A crucial test in IDA ](image/Figure_13.6_B17616.jpg)'
  id: totrans-100
  prefs: []
  type: TYPE_IMG
- en: Figure 13.6 – A crucial test in IDA
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
- en: 'Recall that in my specific IDA session here, **sub_BF8B959D** is the **xxxSendMessage**
    function. The simplest way to put this is that **xxxSendMessage** will be called
    if **EBX** contains anything other than **-1**. The **-5** value is not checked
    against **EBX** before the call. By returning **-5** into the flow at this point,
    we can pass it to the **xxxSendMessage** function as a parameter. **-5** represented
    as a hexadecimal value looks like **0xFFFFFFFB**. In this particular parameter,
    **xxxSendMessage** is expecting a pointer. If the exploit works, execution will
    try to jump to the memory location, **0xFFFFFFFB**. Part of the exploit’s job
    is to land us on the NULL page with an offset. The exploit will have already mapped
    some space in the NULL page before this point, so ultimately, execution jumps
    to shellcode waiting in user space. (As is often the case, Windows allows NULL
    page mapping for backward-compatibility reasons.) Now, I know what the hacker
    in you is saying: *It seems like disabling NULL page mapping would stop this attack
    right in its tracks*. A job well done as you’d be right, and Microsoft thought
    of that – NULL page mapping is disabled by default, starting in Windows 8.'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
- en: There aren’t enough pages to do a deep dive into this particular vulnerability,
    but I hope I’ve given you enough background to try this out – get on your vulnerable
    Windows 7 VM and nab the driver (it’s in **System32**), open it up in IDA, and
    follow the flow of execution. See if you can understand what’s happening in the
    other functions in play here. Try keeping a running map of the registers and their
    values, and use the **push** and **pop** operations to understand the stack in
    real time. IDA is the perfect tool for this analysis. I have a feeling you’ll
    be hooked.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
- en: Metasploit – exploring a Windows kernel exploit module
  id: totrans-104
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now that we have a little background, we’re going to watch the attack in action
    with Metasploit. The exploit module specific to this vulnerability is called **exploit/windows/local/ms14_058_track_popup_menu**
    (recall that MS14-058 is the Microsoft security bulletin designation for this
    flaw). Note that this exploit falls under the **local** subcategory. The nature
    of this flaw requires that we are able to execute a program as a privileged user
    – this is a local attack, as opposed to a remote attack. Sometimes, you’ll see
    security publications discuss local exploits with phrases such as *the risk is
    limited by the fact that the attacker must be local to the machine*. The pen tester
    in you should be chuckling at this point because you know that the context of
    distinguishing local from remote essentially removes the human factor sitting
    at the keyboard. If we can convince the user to take some action, we’re as good
    as local. These local attacks can become remotely controlled with just a little
    finesse.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we get to the fun stuff, let’s examine the Metasploit module in detail
    so that we understand how it works. As always, we need to take a look at the **include**
    lines so that we can review the functionality that’s being imported into this
    module:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '[PRE26]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '[PRE27]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '[PRE28]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: '[PRE29]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: '[PRE30]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: '[PRE31]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: '[PRE32]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: So, we have several Windows post-exploit modules loaded here: **File**, **Priv**,
    **Process**, **FileInfo**, and **ReflectiveDLLInjection**. I won’t bog you down
    by dumping the code from all five post modules here, but you should always consider
    a proper review of the included modules as a requirement. Recall that the **include**
    statement makes those modules mixins whose parameters are directly referenceable
    within this parent module.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
- en: Back to the parent module – we’re going to skip over the first two defined methods, **initialize(info={})**
    and **check**. You will remember that the **info** initialization provides useful
    information for the user, but this isn’t necessary for the module to function.
    The most practical purpose of this is making keywords available to the search
    function within **msfconsole**. The **check** method is also not strictly necessary,
    but it makes this module available to the compatibility checking functionality
    of Metasploit. When a target is selected, you can load an exploit and check whether
    the target is probably vulnerable. Personally, I find the check functionality
    to be nifty and potentially a timesaver, but in general, I would never recommend
    relying on it.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, at long last – the **exploit** method. Please note that the method starts
    with some error checking that we’re skipping over; it makes sure we aren’t already
    **SYSTEM** (just in case you’re still racing after crossing the finish line!),
    and it checks that the session host architecture and the options-defined architecture
    match:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: '[PRE34]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: '[PRE35]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: '[PRE36]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: '[PRE37]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: '[PRE38]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: '[PRE39]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: '[PRE40]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: '[PRE41]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: '[PRE42]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: The method starts with an attempt to launch Notepad. Note that the **{'Hidden'
    => true}** argument is passed to **execute**. This ensures that Notepad will execute
    but the friendly editor window won’t actually appear for the user (which would
    certainly tip off the user that something is wrong). We then handle the successful
    launch of Notepad and nab the process ID for the next stage of the exploit; alternatively,
    **rescue** comes to the rescue to handle the failure to launch Notepad and instead
    nabs the currently open process for the next stage.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
- en: DLLs are the Windows implementation of the shared library model. They are executable
    code that can be shared by programs. For all intents and purposes, they should
    be regarded as executables. The main difference from EXE files is that DLLs require
    an entry point that is provided by a running program. From a security perspective,
    DLLs are very dangerous because they are loaded in the memory space of the calling
    process, which means they have the same permissions as the running process. If
    we can inject a malicious DLL into a privileged process, this is pretty much game
    over.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
- en: 'And now, our big finale – reflective DLL injection. DLLs are meant to be loaded
    into the memory space of a process, so DLL injection is simply forcing this with
    our chosen DLL. However, since a DLL is an independent file in its own right,
    DLL injection typically involves pulling the DLL’s code off of the disk. Reflective DLL
    injection allows us to source code straight out of memory. Let’s take a look at
    what our module does with reflective DLL injection in the context of our **Win32k.sys**
    exploit:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: '[PRE44]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: '[PRE45]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: '[PRE46]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: '[PRE47]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: '[PRE48]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: '[PRE49]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: '[PRE50]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: '[PRE51]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: '[PRE52]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: '[PRE53]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: '[PRE54]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: '[PRE55]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: '[PRE56]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: '[PRE57]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: '[PRE58]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'Let’s examine this step by step and skip over the status printouts:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
- en: First, the **if...else** **target.arch.first == ARCH_X86** statement. This is
    self-explanatory – the module is pulling an exploit DLL from the Metasploit **Data\Exploits**
    folder, and this check allows for the architecture to be targeted correctly.
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**library_path** allows the module to find and load the exploit DLL from the
    attacker’s local disk. I hope your creative side has kicked in and you just realized
    that you could modify this module to point at any DLL you like.'
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**exploit_mem, offset = inject_dll_into_process()** is the first slap across
    the target’s face. Note that **inject_dll_into_process()** is defined in the included
    **ReflectiveDLLInjection** module. This particular method takes the target process
    and the DLL’s local path as arguments and then returns an array with two values
    – the allocated memory address and the offset. Our module takes these returned
    values and stores them as **exploit_mem** and **offset** respectively.'
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**payload_mem = inject_into_process()** is the second slap across the target’s
    face. **payload.encoded** is our shellcode (encoded as needed). This method returns
    only one value – the location of the shellcode in the target process’s memory.
    So, as you can see, at this point in our attack, **payload_mem** is now the location
    in our target’s memory where our shellcode begins.'
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'If those first two instance methods for DLL injection were the slaps in the
    face, then **process.thread.create(exploit_mem + offset, payload_mem)** is our
    coup de grâce. We’re passing two parameters to **process.thread.create()**: first, **exploit_mem**
    with our offset added to it, and then the location of our shellcode in memory,
    **payload_mem**.'
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: So, why are we injecting a DLL into a process? The vulnerable kernel-mode driver,
    **Win32k.sys**, has more than 600 entry points that allow its functionality to
    be accessed; it handles a lot of useful tasks. As previously covered in this chapter,
    **Win32k.sys** is responsible for window management. **Win32k.sys** represents
    a necessary evil of this OS design – the blend of its needed power and accessibility
    to user-mode programs.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
- en: Practical kernel attacks with Kali
  id: totrans-154
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have enough background to sit down with Kali and fire off our attack at a
    vulnerable Windows target. At this point, you should fire up your Windows 7 VM.
    However, we’re doing two stages in this demonstration because the attack is local.
    So far, we’ve been examining attacks that get us in. This time, we’re already
    in. To the layperson, this sounds like the game is already won, but don’t forget
    that modern OSs are layered. There was a golden age when remote exploits landed
    you full **SYSTEM** privilege on a target Windows box. These days, this kind of
    remote exploit is a rare thing indeed. The far more likely scenario for today’s
    pen tester is that you’ll get some code executed, a shell pops up, and you feel
    all-powerful – until you realize that you only have the privileges of the lowly
    user of the computer who needs permission from the administrator to install software.
    You have your *foothold* – now, you need to escalate your privileges so that you
    can get some work done.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
- en: An introduction to privilege escalation
  id: totrans-156
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The kernel attack described in this chapter is an example of privilege escalation
    – we’re attacking a flaw on the kernel side after allocating memory on the user side
    and injecting code into it. Accordingly, did you notice the big difference between
    the module we just reviewed and the remote attacks we examined in previous chapters?
    That’s right – there was no option for specifying a target IP address. This is
    a local attack; the only IP address you’ll define is the return of your reverse
    TCP connection to the handler.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
- en: To complete this demo, you’ll need to establish the foothold first! As we’re
    challenging you with a little self-study in order to follow along, we’re sticking
    with our old-school Windows 7 target.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
- en: New OS, Old Problems – the Vulnerable OEM Driver
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
- en: Once you’re comfortable with the theory and practice on the older Windows 7,
    start exploring modern kernel exploits with Metasploit. Check out the amazing
    post module called **dell_memory_protect**. A driver provided by Dell on their
    laptops called **DBUtilDrv2.sys** had a critical kernel-level write-what-where
    vulnerability in versions 2.5 and 2.7\. Metasploit allows us to conduct the *bring
    your own vulnerable driver* attack on any Windows box, Dell or otherwise. The
    driver is easy to find online, so grab it, use the module to install it and disable
    LSA protections, and enjoy your **SYSTEM** access. Extra credit goes to those
    who tear apart the driver in IDA!
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
- en: Escalating to SYSTEM on Windows 7 with Metasploit
  id: totrans-161
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: At this point, you’ve just received your Meterpreter connection back from the
    target – your foothold payload did the trick. We command **getuid** to see where
    we stand. Hmm – the username **FrontDesk** comes back. It doesn’t concern us that
    this user may or may not be an administrator; what’s important is that it isn’t
    **SYSTEM**, the absolute highest privilege possible. Even an administrator can’t
    get away with certain things – that account is still considered user mode.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
- en: 'I type **background** to send my Meterpreter session into the background so
    that I can work at the **msf** prompt. Although the multi/handler exploit is still
    in use, I can simply replace it. This time, we prepare our kernel attack with
    **use exploit/windows/local/ms14_058_track_popup_menu**:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.7 – Managing our foothold in Metasploit ](image/Figure_13.7_B17616.jpg)'
  id: totrans-164
  prefs: []
  type: TYPE_IMG
- en: Figure 13.7 – Managing our foothold in Metasploit
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
- en: 'In our screenshot examples, we aren’t displaying the options available to us;
    so, try that out with **show options**. When you establish the exploit and run
    this command, you’ll see the **sessions** option. This is specific to the Meterpreter
    sessions you’ve already established. Out in the field, you may have a foothold
    on dozens of machines; use this option to direct this attack at a specific session.
    At the **msf** prompt, use **sessions -l** to identify the session you need. **sessions
    -i <id>** will take you back into a session, so you can issue **getuid** to verify
    your privilege:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.8 – Launching the attack inside our established session ](image/Figure_13.8_B17616.jpg)'
  id: totrans-167
  prefs: []
  type: TYPE_IMG
- en: Figure 13.8 – Launching the attack inside our established session
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
- en: This can be a little confusing to set up, as you’re just coming back from configuring
    your handler with a payload. You need to set the payload to be used by the kernel
    exploit. In my example, I’m issuing **set payload windows/meterpreter/reverse_tcp**
    to create a connect-back Meterpreter shellcode payload.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
- en: 'When you’re ready, fire off **run** and cross your fingers. This is an interesting
    attack; by its nature, the escalation could fail without killing your session.
    You’ll see everything on your screen suggesting a successful exploit, complete
    with a new Meterpreter session indicating that the shellcode was indeed executed
    – and yet, **getuid** will show the same user as before. This is why the module
    author put in the fingers-crossed status message, **hopefully privileged**:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.9 – Exploit complete – we are now SYSTEM ](image/Figure_13.9_B17616.jpg)'
  id: totrans-171
  prefs: []
  type: TYPE_IMG
- en: Figure 13.9 – Exploit complete – we are now SYSTEM
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
- en: In our demo, our Windows 7 Ultimate host was indeed vulnerable. We are now running
    as **SYSTEM**. Game over.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-174
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we explored Windows kernel attacks. First, we reviewed the
    theory behind how the kernel works and what attackers try to leverage to pull
    off these attacks. Included in this theoretical discussion was a review of the
    low-level management role of the kernel and the security implications of these
    tasks, including scheduling interrupts. We picked a vulnerability type, the NULL
    or invalid pointer dereference vulnerability, and studied it in detail to understand
    how exploiting the kernel in this way gives the attacker full control of the system.
    We started with a review of pointers in C code and then examined the compiled
    assembly instructions to understand how the processor deals with the pointer concept.
    This review prepared us to understand what NULL pointers are and how they can
    cause problems in software. We then introduced a specific kernel-mode driver,
    **Win32k.sys**, and did a low-level review of its pointer flaw. We wrapped up
    this discussion with a review of the Metasploit exploit module, designed to attack
    this particular kernel-mode driver. Finally, we wrapped up the chapter with a
    hands-on demonstration of escalating privileges from an initial foothold by leveraging
    this attack against the vulnerable kernel-mode driver.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we’ll wrap up the programming fundamentals with a review
    of fuzzing. In this book, you’ve already played around with fuzzing and may not
    even be aware of it. We’ll review the underlying principles and get hands-on with
    fuzz testing.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  id: totrans-177
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Answer the following questions to test your knowledge of this chapter:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
- en: The ______ rests between the NT kernel and hardware.
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A ______ kernel can interrupt kernel-mode threads; cooperative OSs must wait
    for the thread to finish.
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In C, the ampersand operator before a variable references __________.
  id: totrans-181
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How many DWORDS fit into three quadwords?
  id: totrans-182
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**AX** is the lower ________ of the 64-bit **RAX**.'
  id: totrans-183
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: It is not possible to dereference an invalid pointer – true or false?
  id: totrans-184
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: My hexadecimal-to-decimal calculator says that **ffffffff** is equal to 4,294,967,295. Why
    does the **xxxSendMessage()** function think it’s **-1**?
  id: totrans-185
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What’s the difference between DLL injection and reflective DLL injection?
  id: totrans-186
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Further reading
  id: totrans-187
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For more information regarding the topics that were covered in this chapter,
    take a look at the following resources:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
- en: Source code for HackSys Extreme Vulnerable Driver ([https://github.com/hacksysteam/HackSysExtremeVulnerableDriver](https://github.com/hacksysteam/HackSysExtremeVulnerableDriver))
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Windows SDK download for installing the debugger ([https://developer.microsoft.com/en-us/windows/downloads/windows-10-sdk](https://developer.microsoft.com/en-us/windows/downloads/windows-10-sdk))
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
