<html><head></head><body>
<div id="sbo-rt-content"><div id="_idContainer298">
<h1 id="_idParaDest-259"><em class="italic"><a id="_idTextAnchor258"/>Chapter 14</em>: Fuzzing Techniques</h1>
<p>What is fuzzing? You’ve already done some fuzzing as part of our exercises elsewhere in this book. When we were exploring our vulnerable C programs, we would fire up the GNU Debugger and watch the state of the registers as we threw more and more data at the user prompt. We were modifying our input with each iteration and trying to cause a crash or at least some anomalous behavior. The inputs to the program can be malformed in some sense – an invalid format, adding unexpected or invalid characters, or simply providing too much data. The fuzzing target doesn’t even have to be a program – it could be a network service implementing some particular protocol, or even the encoder that generates a file in a particular format, such as a PDF or JPG. If you’ve ever worked in software development, then the idea should be immediately familiar. Fuzzing can find flaws that could negatively impact the user experience, but for security practitioners, it’s a way to find exploitable flaws. </p>
<p>In this chapter, we’re going to dive deeper into fuzzing as an exploit research methodology. We’ll explore two real-world programs with overflow vulnerabilities, but we won’t reveal any specifics. It’ll be up to us to discover the facts needed to write a working exploit for the programs. </p>
<p>In this chapter, we will cover the following topics:</p>
<ul>
<li>Mutation fuzzing over the network against a server</li>
<li>Writing Python fuzzers for both client and server testing</li>
<li>Debugging the target programs to monitor memory during fuzzing</li>
<li>Using offset discovery tools to find the right size for our payloads</li>
</ul>
<h1 id="_idParaDest-260"><a id="_idTextAnchor259"/>Technical requirements</h1>
<p>For this chapter, you will need the following:</p>
<ul>
<li>Kali Linux</li>
<li>A 32-bit Windows 7 testing VM with WinDbg installed</li>
<li>Taof for Windows</li>
<li>nfsAxe FTP Client version 3.7 for Windows</li>
<li>3Com Daemon version 2r10 for Windows</li>
</ul>
<h1 id="_idParaDest-261"><a id="_idTextAnchor260"/>Network fuzzing – mutation fuzzing with Taof proxying</h1>
<p>So far, this book<a id="_idIndexMarker972"/> has been exploring attacking perspectives that can be applied in the field. Fuzzing, on <a id="_idIndexMarker973"/>the other hand, is not an attack in the usual sense of the word. It’s a testing methodology; for example, QA engineers fuzz user interfaces all the time. So, when do we leverage fuzzing as pen testers? As an<a id="_idIndexMarker974"/> example, suppose you’ve just completed some reconnaissance against your client’s systems. You find a service exposed to the internet and discover that it reveals its full version information in a banner grab. You would not want to start fuzzing this service on the production network, but you could get your hands on a copy and install it in your lab using the information you have acquired from the target. We’re going to take a look at some network fuzzing that you may just end up doing in your hotel room after the first couple of days with your client.</p>
<p>As the<a id="_idIndexMarker975"/> name suggests, mutation fuzzing takes a given set of data and mutates it piece by piece. We’re going to do something similar here with a special tool designed to make a true artist out of you. Taof is written in Python, so once you have the dependencies, it can be run in Linux. For this demonstration, I’m going to run it in Windows.</p>
<p>In our demo, we’re running the target FTP server on its own Windows 7 host and the proxy fuzzer on a separate host. However, you can do the same testing with a single host if you don’t have access to two Windows 7 VMs.</p>
<h2 id="_idParaDest-262"><a id="_idTextAnchor261"/>Configuring the Taof proxy to target the remote service</h2>
<p>Let’s start by<a id="_idIndexMarker976"/> configuring the target service. This is simple with our demonstration: just execute 3Com Daemon and it <a id="_idIndexMarker977"/>will start its servers automatically. On the left-hand side, you’ll see the different services; select <strong class="bold">FTP Server</strong> and then check the status window on the right-hand side to confirm that the service is listening on port <strong class="source-inline">21</strong>. In our demonstration, we can see that the listener has detected the<a id="_idIndexMarker978"/> locally <a id="_idIndexMarker979"/>assigned address; that is, <strong class="source-inline">192.168.108.189</strong>. Now, we know where to point the proxy:</p>
<div>
<div class="IMG---Figure" id="_idContainer275">
<img alt="Figure 14.1 – 3CDaemon ready for requests " height="693" src="image/Figure_14.01_B17616.jpg" width="1399"/>
</div>
</div>
<p class="figure-caption">Figure 14.1 – 3CDaemon ready for requests</p>
<p>Now, we can switch over to Taof and click <strong class="bold">Data retrieval</strong> and then <strong class="bold">Network Settings</strong>. You can leave the local server address at <strong class="source-inline">0.0.0.0</strong> but set the port to whatever you like and remember it for connecting to the proxy in the next step. Punch in the IP address and port from the 3Com Daemon status window into <strong class="bold">Remote settings</strong>:</p>
<div>
<div class="IMG---Figure" id="_idContainer276">
<img alt="Figure 14.2 – Taof proxy configuration " height="984" src="image/Figure_14.02_B17616.jpg" width="670"/>
</div>
</div>
<p class="figure-caption">Figure 14.2 – Taof proxy configuration</p>
<p>Once you click <strong class="bold">OK</strong>, you’ll be<a id="_idIndexMarker980"/> able to <a id="_idIndexMarker981"/>verify your settings before clicking <strong class="bold">Start</strong>. At this point, the proxy is running.</p>
<h2 id="_idParaDest-263"><a id="_idTextAnchor262"/>Fuzzing by proxy – generating legitimate traffic</h2>
<p>The idea is<a id="_idIndexMarker982"/> simple – Taof is functioning as an ordinary proxy server now, handling our traffic to and from the remote service on our behalf. This is so that Taof can learn what expected traffic looks like before the mutation fuzzing phase. Now, we can simply connect to the proxy with any FTP client. In our example, using the built-in FTP client and specifying the remote address as <strong class="source-inline">127.0.0.1</strong> and port as <strong class="source-inline">1066</strong> connected us to the server listening at <strong class="source-inline">192.168.108.189</strong> on port <strong class="source-inline">21</strong>.</p>
<p>In today’s age, working <a id="_idIndexMarker983"/>with insecure protocols in a Windows lab can be frustrating if you have Windows Firewall running in a default configuration. You may need to disable it for these tests.</p>
<p>We’re looking to send normal authentication data, so go ahead and try logging in as <strong class="source-inline">administrator</strong>, <strong class="source-inline">guest</strong>, <strong class="source-inline">pickles</strong> – whatever you like. It doesn’t matter because we want to fuzz the authentication process. When you’ve sent some data, stop the Taof proxy and return to the <strong class="bold">Request</strong> window. You’ll see a <strong class="bold">Request List</strong>, where each item has associated contents. Browse the requests to get an idea of what happened. It’s also a good idea to check out the 3Com Daemon’s status window to see how the requests were handled.</p>
<p>Now, let’s identify where the mutations will take place by setting fuzzing points. Select a request from the list, depending on what you’re trying to test. In our example, we want to mess around with authentication, so I’ve chosen the moment my client sent the <strong class="source-inline">USER pickles</strong> command. Once selected, click <strong class="bold">Set fuzzing points</strong>:</p>
<div>
<div class="IMG---Figure" id="_idContainer277">
<img alt="Figure 14.3 – Picking fuzzing points from the list of captured requests " height="949" src="image/Figure_14.03_B17616.jpg" width="616"/>
</div>
</div>
<p class="figure-caption">Figure 14.3 – Picking fuzzing points from the list of captured requests</p>
<p>If you’re <a id="_idIndexMarker984"/>like me, you<a id="_idIndexMarker985"/> probably think that Taof doesn’t look like much when you first power it up. They put the real juicy bits down here in the <strong class="bold">Fuzz Request</strong> dialog box. (I always felt that way about Cain – a humble GUI with remarkable power under the hood. But I digress.) In this box, we can see the raw binary request in hexadecimal representation, along with the ASCII form that would have appeared at the application level. Try highlighting<a id="_idIndexMarker986"/> portions of the request – the <strong class="bold">From</strong> and <strong class="bold">To</strong> boxes identify the range in character position of your fuzzing point. Also, note that there are four<a id="_idIndexMarker987"/> kinds of tests we can perform – let’s leave the three overflows enabled: </p>
<div>
<div class="IMG---Figure" id="_idContainer278">
<img alt="Figure 14.4 – Configuring the fuzzing request " height="791" src="image/Figure_14.04_B17616.jpg" width="514"/>
</div>
</div>
<p class="figure-caption">Figure 14.4 – Configuring the fuzzing request</p>
<p>On a hunch, I’m going to start with the full field: <strong class="source-inline">0</strong> to <strong class="source-inline">14</strong>. In our example, I just want to skip the finesse and break the service. Click <strong class="bold">Add</strong>, then <strong class="bold">OK</strong>, then <strong class="bold">Fuzzing</strong>:</p>
<div>
<div class="IMG---Figure" id="_idContainer279">
<img alt="Figure 14.5 – Watching our target succumb to one of the fuzzing requests " height="826" src="image/Figure_14.05_B17616.jpg" width="772"/>
</div>
</div>
<p class="figure-caption">Figure 14.5 – Watching our target succumb to one of the fuzzing requests</p>
<p>Tango down! We <a id="_idIndexMarker988"/>can see <strong class="source-inline">+ Buffer overflows</strong> on the screen, followed by repeated attempts<a id="_idIndexMarker989"/> to contact the server, but to no avail. We know there’s a buffer overflow vulnerability in this FTP server. However, we have no idea how to exploit it. At this point, we need a tool that will send payloads to crash the service in a manner that allows us to recover the offset to EIP. I know what the hacker in you is saying – <em class="italic">why not write it up in Python?</em> Phew, I’m glad to hear you say that.</p>
<h1 id="_idParaDest-264"><a id="_idTextAnchor263"/>Hands-on fuzzing with Kali and Python</h1>
<p>This is just <a id="_idIndexMarker990"/>my opinion, but I consider writing our own scripts for fuzzing to be a necessity. Any programming language will allow us to construct special payloads, but Python is a personal favorite for interfacing with sockets and files. Let’s try to understand what’s happening behind the scenes with the protocol in play, and then construct Python scripts that can interact in expected ways. The targets will happily accept our payloads if our scripts can talk the talk. Let’s take a look at the vulnerable server first.</p>
<h2 id="_idParaDest-265"><a id="_idTextAnchor264"/>Picking up where Taof left off with Python – fuzzing the vulnerable FTP server</h2>
<p>We configured Taof to fuzz on the <strong class="source-inline">USER anonymous</strong> request that was sent to 3Com Daemon, and we <a id="_idIndexMarker991"/>watched it crash. We know what both ends saw, but we need to understand what happened on the network. There’s no better tool than Wireshark for this task. Set up a sniffing session and then run the test again. Filter out the FTP communication and take a look at the conversation:</p>
<div>
<div class="IMG---Figure" id="_idContainer280">
<img alt="Figure 14.6 – Tracking the FTP conversation with Wireshark " height="177" src="image/Figure_14.06_B17616.jpg" width="971"/>
</div>
</div>
<p class="figure-caption">Figure 14.6 – Tracking the FTP conversation with Wireshark</p>
<p>Note that after the three-way TCP handshake is completed and the connection has been established, the very first communication comes from the server in the form of an FTP 220 message. The client fires back the <strong class="source-inline">USER anonymous</strong> request and, as expected from any FTP server, a 331 comes back. After the <strong class="source-inline">PASS</strong> command, we get a 230 (if the server allows anonymous logins, of course). Don’t fall asleep on me – this particular sequence is important for us because we’re constructing the socket in Python. As you may recall from <a href="B17616_08_Final_VK_ePub.xhtml#_idTextAnchor145"><em class="italic">Chapter 8</em></a>, <em class="italic">Python Fundamentals</em>, we connected to a server with our newly created socket and initiated the communication.</p>
<p>We have <a id="_idIndexMarker992"/>to tell our script to wait for the server’s greeting before we send anything. What’s going to save us a lot of time is the fact that our fuzzer crashed the server with the <strong class="source-inline">USER anonymous</strong> request – that’s only the second packet in the established session! Thus, we can get away with one tiny little script – 10 lines, in my case. (Forget the final status message and put the fuzzing payload into the <strong class="source-inline">webclient.send()</strong> function, and you’re down to eight lines.) Let’s take a look:</p>
<pre class="source-code">#!/usr/bin/python </pre>
<pre class="source-code">import socket </pre>
<pre class="source-code">webhost = "192.168.63.130" </pre>
<pre class="source-code">webport = 21 </pre>
<pre class="source-code">fuzz = '\x7a' * 10 </pre>
<pre class="source-code">webclient = socket.socket(socket.AF_INET, socket.SOCK_STREAM) </pre>
<pre class="source-code">webclient.connect((webhost, webport)) </pre>
<pre class="source-code">webclient.recv(512) </pre>
<pre class="source-code">webclient.send("USER anonymous" + fuzz) </pre>
<pre class="source-code">print("\n\n*** Payload sent! ***\n\n")</pre>
<p>This adorable little program should look familiar. The difference here is very simple:</p>
<ul>
<li>Our first order of business, immediately after establishing the TCP session, is to <em class="italic">receive</em> a message from the server. Note that no variable has been set up for it; we’re simply telling the script to receive a maximum of 512 bytes but we’re not provisioning a way to read the received message.</li>
<li>We send exactly what the server expects: a <strong class="source-inline">USER anonymous</strong> request. We’re building a<a id="_idIndexMarker993"/> fuzzer, though, so we concatenate the string stored in <strong class="source-inline">fuzz</strong>.</li>
</ul>
<p>Now, I was considering telling you about the logs that Taof creates in its home directory so that you can see the details of what the fuzzer did and when it detected a crash – but I won’t. I’ll leave it to you to find out what inputs it takes to crash the server.</p>
<h2 id="_idParaDest-266"><a id="_idTextAnchor265"/>Exploring with boofuzz</h2>
<p>Taof is great for lightweight<a id="_idIndexMarker994"/> and visual fuzzing tasks, but since we’re already playing with Python, we need to dive deeper with a modern tool: <strong class="bold">boofuzz</strong>. The mighty Sulley fuzzing framework is no longer supported, so boofuzz is a fork and successor of the original. The name honors its origins: Sulley got its name from the lovable blue monster from <em class="italic">Monsters, Inc.</em> as he is exceptionally fuzzy. (Or is he furry? That’s a debate for another book.) Sulley meets a sweet little girl from the human world and, not knowing her real name, dubs her <em class="italic">Boo</em> due to her penchant for jump scares. Sulley’s character takes on a bit of a fatherly role, so the creators felt it appropriate that the successor to the Sulley fuzzing framework is called boofuzz. Remember this little pop culture tidbit for your next trivia night. </p>
<p>The main thing to know about boofuzz is that it isn’t a separate program like Taof; it’s a module that you import into your script, and you <em class="italic">teach</em> it how to interact with your target using its built-in <em class="italic">grammar</em>. Thus, naturally, your Python script that incorporates boofuzz’s power will start with the following line:</p>
<pre class="source-code">from boofuzz import *</pre>
<p>I can already hear the hacker in you: <em class="italic">We could build generators that will spit out the appropriate boofuzz-speaking script for our task!</em> Indeed you can, and there are great examples online. If you want to practice with HTTP, for example, go check out Boo-Gen. It will take an ordinary HTTP request as input and spit out a boofuzz script for the target HTTP service. For now, we’ll just experiment with FTP, but hopefully, the sheer power is obvious to you.</p>
<p>It goes without saying, but since boofuzz is written in Python, it’s incredibly versatile (no need to switch back to your Windows attacking box) and easy to fetch within Kali. Let’s get that done now. Keep in mind that you need Python 3’s <strong class="source-inline">pip</strong> for this:</p>
<pre class="source-code">apt update &amp;&amp; apt install python3-pip</pre>
<pre class="source-code">pip install boofuzz</pre>
<p>And that’s all there<a id="_idIndexMarker995"/> is to it. Getting boofuzz couldn’t be easier – but some people complain about the difficulty for beginners to get used to it. So, let’s look at the basics of boofuzz grammar.</p>
<h2 id="_idParaDest-267"><a id="_idTextAnchor266"/>Impress your teachers – using boofuzz grammar</h2>
<p>Just like every C program<a id="_idIndexMarker996"/> must have a <strong class="source-inline">main()</strong> function, every boofuzz script must have a <strong class="source-inline">session</strong> object. Every fuzz session needs a target, and any target needs the connection type defined; this can be done with the <strong class="source-inline">target</strong> and <strong class="source-inline">connection</strong> objects, respectively. Every boofuzz script is a Russian nesting doll of objects that defines our connection type and target inside our session. It will look something like this:</p>
<pre class="source-code"><strong class="source-inline">session = Session(</strong></pre>
<pre class="source-code"><strong class="source-inline">target = Target(</strong></pre>
<pre class="source-code"><strong class="source-inline">connection = TCPSocketConnection("[IP address]", [port])))</strong></pre>
<p>You’ll probably be using the <strong class="source-inline">TCPSocketConnection()</strong> class for most tasks, but you have other options such as UDP, raw sockets, and even serial connections.</p>
<p>When people complain about boofuzz’s relative difficulty for beginners, I imagine this has less to do with the module itself and more to do with the <em class="italic">protocol definition</em> required in each script. We need to teach boofuzz how to fuzz our target protocol. As you can imagine, this makes boofuzz a definitive resource for anyone working on proprietary protocols! For now, let’s take a look at FTP. Note that we’re going to point at the target FTP service running at <strong class="source-inline">192.168.108.211</strong>:</p>
<div>
<div class="IMG---Figure" id="_idContainer281">
<img alt="Figure 14.7 – A boofuzz script for testing against FTP " height="740" src="image/Figure_14.07_B17616.jpg" width="785"/>
</div>
</div>
<p class="figure-caption">Figure 14.7 – A boofuzz script for testing against FTP</p>
<p>Each of these<a id="_idIndexMarker997"/> is a message definition – we’re defining <strong class="source-inline">USER</strong>, <strong class="source-inline">PASS</strong>, and <strong class="source-inline">STOR</strong> in this example, and each definition has children that dictate the actual contents of the message. We’ll invoke these definitions with the <strong class="source-inline">session</strong> object we made previously and then invoke <strong class="source-inline">session.fuzz()</strong>:</p>
<div>
<div class="IMG---Figure" id="_idContainer282">
<img alt="Figure 14.8 – Invoking the fuzz " height="146" src="image/Figure_14.08_B17616.jpg" width="375"/>
</div>
</div>
<p class="figure-caption">Figure 14.8 – Invoking the fuzz</p>
<p>Once you kick off your <a id="_idIndexMarker998"/>new script with Python 3, your terminal window will simply explode:</p>
<div>
<div class="IMG---Figure" id="_idContainer283">
<img alt="Figure 14.9 – Boofuzz in action from the command line " height="726" src="image/Figure_14.09_B17616.jpg" width="1003"/>
</div>
</div>
<p class="figure-caption">Figure 14.9 – Boofuzz in action from the command line</p>
<p>Gah! What is happening? This is boofuzz in action and verbosely keeping you informed of every step. Surely, we’ll need some kind of bird’s-eye view. With all of this noise, you may have missed it, but the very first line in this log is <strong class="source-inline">Info: Web interface can be found at http://localhost:26000</strong>. Well, thank goodness for that. Let’s check it out while the fuzzer is doing its work.</p>
<div>
<div class="IMG---Figure" id="_idContainer284">
<img alt="Figure 14.10 – Boofuzz in action from the control page " height="449" src="image/Figure_14.10_B17616.jpg" width="1017"/>
</div>
</div>
<p class="figure-caption">Figure 14.10 – Boofuzz in action from the control page</p>
<p>With that, we’ve seen <a id="_idIndexMarker999"/>the power and utility of boofuzz. As we’ve seen, the tool assumes you know what you’re doing and you understand the protocol. Perhaps you have a Wireshark dump of some proprietary protocol in a SCADA environment? boofuzz is one of the rare treats that will allow you to build a comprehensive fuzzing test from a simple Pythonic description of the target’s protocol.</p>
<p>Let’s wrap up the client’s perspective of the fuzzable server and look at what a server sees when talking with a fuzzable client. </p>
<h2 id="_idParaDest-268"><a id="_idTextAnchor267"/>The other side – fuzzing a vulnerable FTP client</h2>
<p>We can run our<a id="_idIndexMarker1000"/> fuzzer as a client to test against a service, but let’s keep an open mind – we can fuzz any mechanism that takes our input. Though the client initiates a conversation with a server, the client still takes input as part of its role in the conversation. Taof allowed us to play the client to fuzz a service – this time, we’re testing a client, so we need to run a service that provides the fuzzing input.</p>
<p>We already know that the nfsAxe FTP client version 3.7 for Windows is vulnerable. Now, let’s play the role of a vulnerability discoverer and fuzz this client. We have our Windows 7 testing box ready to go, and the nfsAxe client is installed. Go ahead and fire up the client, and take a look around:</p>
<div>
<div class="IMG---Figure" id="_idContainer285">
<img alt="Figure 14.11 – Configuring the vulnerable FTP client " height="783" src="image/Figure_14.11_B17616.jpg" width="905"/>
</div>
</div>
<p class="figure-caption">Figure 14.11 – Configuring the vulnerable FTP client</p>
<p>Note that we <a id="_idIndexMarker1001"/>can specify session credentials, or select <strong class="bold">Anonymous</strong> to cause the client to log in immediately with <strong class="source-inline">anonymous:guest</strong> (provided that the server supports it). We’ll test against this behavior to make things easier. So, we know that we need an FTP server, but it needs to respond to any input, regardless of its validity, because the objective is to put data back and see what happens inside the client. What better way to get this done than with a Python script that mimics an FTP server?</p>
<h2 id="_idParaDest-269"><a id="_idTextAnchor268"/>Writing a bare-bones FTP fuzzer service in Python</h2>
<p>Back in <a href="B17616_08_Final_VK_ePub.xhtml#_idTextAnchor145"><em class="italic">Chapter 8</em></a>, <em class="italic">Python Fundamentals</em>, we<a id="_idIndexMarker1002"/> built a server skeleton with nothing more than a core socket and listening port functionality. We also introduced a quick way to run something forever (well, until an event such as an interrupt) – <strong class="source-inline">while True</strong>. We’ll do something a little different for our <a id="_idIndexMarker1003"/>fuzzing FTP server because we need to mimic the appearance of a legitimate FTP server that’s communicating with the client. We’ll also introduce the <strong class="source-inline">try/except</strong> construct in Python so that we can handle errors and interrupts.</p>
<p>Fire up <strong class="source-inline">vim fuzzy.py</strong> and type out the following program:</p>
<pre class="source-code">#!/usr/bin/python3 </pre>
<pre class="source-code">import socket </pre>
<pre class="source-code">import sys </pre>
<pre class="source-code">host_ip = '0.0.0.0' </pre>
<pre class="source-code">host_port = 21 </pre>
<pre class="source-code">try: </pre>
<pre class="source-code">    i = int(input("\n\nHow many bytes of fuzz?\n\n:")) </pre>
<pre class="source-code">except ValueError: </pre>
<pre class="source-code">    print("\n\n* Exception: Byte length must be an integer *")</pre>
<pre class="source-code">    sys.exit(0) </pre>
<pre class="source-code">fuzz = b"\x7a" * i </pre>
<pre class="source-code">try: </pre>
<pre class="source-code">    server = socket.socket(socket.AF_INET, socket.SOCK_STREAM) </pre>
<pre class="source-code">    server.bind((host_ip, host_port)) </pre>
<pre class="source-code">    server.listen(1) </pre>
<pre class="source-code">    print("\n\n** Phuzzy Phil's FuzzTP **\nServer is up.\nListening at %s on port %d" % (host_ip, host_port))</pre>
<pre class="source-code">    print("Fuzzing exploit length: %d bytes" % len(fuzz))</pre>
<pre class="source-code">    client, address = server.accept() </pre>
<pre class="source-code">    print("Connection accepted from FTP client %s, remote port %d" % (address[0], address[1]))</pre>
<pre class="source-code">    client.send(b"220 Connected to FuzzTP Server by Phuzzy Phil\r\n") </pre>
<pre class="source-code">    client.recv(1024) </pre>
<pre class="source-code">    client.send(b"331 OK\r\n") </pre>
<pre class="source-code">    client.recv(1024) </pre>
<pre class="source-code">    client.send(b"230 OK\r\n") </pre>
<pre class="source-code">    client.recv(1024) </pre>
<pre class="source-code">    client.send(b"220 %s\r\n" % fuzz)</pre>
<pre class="source-code">    print("\n\nFuzz payload sent! Closing connection, exiting server.\n")</pre>
<pre class="source-code">    server.close() </pre>
<pre class="source-code">    client.close() </pre>
<pre class="source-code">except socket.error as error: </pre>
<pre class="source-code">    print("* Error *\n\nDetails:" + str(error))</pre>
<pre class="source-code">    server.close() </pre>
<pre class="source-code">    client.close() </pre>
<pre class="source-code">    sys.exit(1) </pre>
<pre class="source-code">except KeyboardInterrupt: </pre>
<pre class="source-code">    print("\n\n* Keyboard interrupt received *\n")</pre>
<pre class="source-code">    server.close() </pre>
<pre class="source-code">    client.close() </pre>
<pre class="source-code">    sys.exit(1)</pre>
<p>Fun, right? Okay, let’s see<a id="_idIndexMarker1004"/> what we did here:</p>
<ul>
<li>The first <strong class="source-inline">try/except</strong> section allows the user to define the fuzzing payload. Note that we take input with <strong class="source-inline">int(raw_input())</strong>. If the returned value from <strong class="source-inline">raw_input()</strong> is a string, then <strong class="source-inline">int()</strong> will return a value error, which we can handle with <strong class="source-inline">except ValueError</strong>. This is just some pretty code, so it isn’t necessary, and for a pen tester on a time crunch, I’m sure you’ll just define the byte length directly in the code and modify it with Vim as you see fit.</li>
<li>We declare<a id="_idIndexMarker1005"/> the fuzzing payload as <strong class="source-inline">fuzz</strong> with <strong class="source-inline">\x7a</strong> as the byte. Use whatever you like, but I’ve been pretty sleepy lately, so I’m sticking with <em class="italic">z</em>. I can’t get <em class="italic">z</em>’s in real life; I may as well stuff them into vulnerable buffers.</li>
<li>Now comes the familiar part for anyone used to sockets in Python – we create a socket with <strong class="source-inline">socket.socket(socket.AF_INET, socket.SOCK_STREAM)</strong> and call it <strong class="source-inline">server</strong>. From there, we use <strong class="source-inline">server.bind()</strong> and <strong class="source-inline">server.listen()</strong> to stand up our server. Note that I’m passing <strong class="source-inline">1</strong> to <strong class="source-inline">server.listen()</strong>; we’re just testing with a single client, so <strong class="source-inline">1</strong> is all that is necessary.</li>
<li>If you connect to our fuzzy little server with an FTP client or netcat, you’ll see a conversation with FTP server response codes. Now, you can see that we’re just faking – we’re taking a kilobyte of responses and just tossing them in the trash, working our way up to sending the payload.</li>
<li>We wrap up with two <strong class="source-inline">except</strong> sections for handling errors or <em class="italic">Ctrl</em> + <em class="italic">C</em>.</li>
</ul>
<p>The trap is set – now, let’s see what happens when the vulnerable client unwittingly processes our fuzzing payload.</p>
<h2 id="_idParaDest-270"><a id="_idTextAnchor269"/>Crashing the target with the Python fuzzer</h2>
<p>Without <a id="_idIndexMarker1006"/>further ado, fire up your fuzzer, configure it to send 256 bytes, and then switch over to your Windows 7 tester. Open the nfsAxe FTP client, select <strong class="bold">Anonymous</strong> access, and punch in Kali’s IP address for <strong class="bold">Host ID</strong>.</p>
<p>Connect and watch the results:</p>
<div>
<div class="IMG---Figure" id="_idContainer286">
<img alt="Figure 14.12 – The test server’s perspective – payload sent " height="573" src="image/Figure_14.12_B17616.jpg" width="960"/>
</div>
</div>
<p class="figure-caption">Figure 14.12 – The test server’s perspective – payload sent</p>
<p>Okay, so that was a little boring, but it worked. The payload was received by the client and displayed in the status window:</p>
<p class="figure-caption">...</p>
<div>
<div class="IMG---Figure" id="_idContainer287">
<img alt="Figure 14.13 – The vulnerable client’s perspective – payload received " height="79" src="image/Figure_14.13_B17616.jpg" width="471"/>
</div>
</div>
<p class="figure-caption">Figure 14.13 – The vulnerable client’s perspective – payload received</p>
<p>Just for fun, execute the <a id="_idIndexMarker1007"/>fuzzer again, but this time send 4,000 bytes. What does the client do?</p>
<div>
<div class="IMG---Figure" id="_idContainer288">
<img alt="Figure 14.14 – The vulnerable client has crashed! " height="195" src="image/Figure_14.14_B17616.jpg" width="630"/>
</div>
</div>
<p class="figure-caption">Figure 14.14 – The vulnerable client has crashed!</p>
<p>Winner, winner, chicken dinner! We just need to prepare our exploit and we’ll be on our way to arbitrary code execution. But wait – I hear the hacker in you now. <em class="italic">We know that the buffer is bigger than 256 bytes and smaller than 4,000 bytes. Will we have to manually find the sweet spot across 3,744 bytes?</em> You are wise beyond your years but fear not. We <a id="_idIndexMarker1008"/>could simply generate a long string of characters in a defined pattern, pass it as our fuzz payload, look for the characters that end up written over the EIP on the client side, identify that 4-byte pattern in the fuzz payload, and calculate the offset. We could do this by hand, but those friendly folks over at Metasploit have already thought of this one.</p>
<h1 id="_idParaDest-271"><a id="_idTextAnchor270"/>Fuzzy registers – the low-level perspective</h1>
<p>The fuzzing research we’ve done so far was effective in discovering the fact that these two FTP programs <a id="_idIndexMarker1009"/>are vulnerable to overflows. Now, we need to understand what’s happening behind the scenes by watching the stack as we send fuzz payloads. Of course, this will be done with a debugger. Since we’re on Windows in this lab, we’ll fire up WinDbg and attach it to the vulnerable software PID. Since we’ve just finished toying around with the nfsAxe client, I’ll assume that’s still up and ready to go in your lab. Keep your 3Com Daemon lab handy, though, because the principles are the same. Let’s go down the rabbit hole with Metasploit’s offset discovery duo: <strong class="source-inline">pattern_create</strong> and <strong class="source-inline">pattern_offset</strong>.</p>
<h2 id="_idParaDest-272"><a id="_idTextAnchor271"/>Calculating the EIP offset with the Metasploit toolset</h2>
<p>Head <a id="_idIndexMarker1010"/>on <a id="_idIndexMarker1011"/>over to the <strong class="source-inline">tools</strong> directory in Metasploit with <strong class="source-inline">cd /usr/share/metasploit-framework/tools/exploit</strong>. First, let’s<a id="_idIndexMarker1012"/> generate a 4,000-byte payload, as we know that’s enough bytes to overwrite critical parts of memory:</p>
<div>
<div class="IMG---Figure" id="_idContainer289">
<img alt="Figure 14.15 – Generating the pattern payload " height="74" src="image/Figure_14.15_B17616.jpg" width="870"/>
</div>
</div>
<p class="figure-caption">Figure 14.15 – Generating the pattern payload</p>
<p>After a couple of seconds, a new text file will appear in your <strong class="source-inline">home</strong> directory. If you open it up, you’ll see 4,000 bytes of junk. Don’t be so fast to judge, though – it’s a specially crafted string that the offset finder, <strong class="source-inline">pattern_offset.rb</strong>, will use to find where our sweet spot lies.</p>
<p>Now, open <a id="_idIndexMarker1013"/>your fuzzer <a id="_idIndexMarker1014"/>with Vim again, comment out the lines that take input, and set the <strong class="source-inline">fuzz</strong> variable. Add <a id="_idIndexMarker1015"/>the following line after the comment lines:</p>
<pre class="source-code">with open("fuzz.txt") as fuzzfile:</pre>
<pre class="source-code">    fuzz = bytes(fuzzfile.read().rstrip("\n"), "utf-8")</pre>
<p>Note that <strong class="source-inline">rstrip()</strong> simply trims the new line from the end of the file:</p>
<div>
<div class="IMG---Figure" id="_idContainer290">
<img alt="Figure 14.16 – Modifying the server to deliver our special payload " height="269" src="image/Figure_14.16_B17616.jpg" width="863"/>
</div>
</div>
<p class="figure-caption">Figure 14.16 – Modifying the server to deliver our special payload</p>
<p>Save your modified fuzzer and execute it again. You’ll notice that the payload is now 4,000 bytes long. But hold your horses – let’s not fire off the FTP client just yet (we already know it’ll crash). As we reviewed in <a href="B17616_08_Final_VK_ePub.xhtml#_idTextAnchor145"><em class="italic">Chapter 8</em></a>, <em class="italic">Python Fundamentals</em>, let’s link our FTP client to WinDbg – while the nfsAxe client is running, open WinDbg and hit <em class="italic">F6</em> to attach to a running process. Find the <strong class="source-inline">ftp.exe</strong> process and attach to it:</p>
<div>
<div class="IMG---Figure" id="_idContainer291">
<img alt="Figure 14.17 – Attaching to the vulnerable client in WinDbg " height="296" src="image/Figure_14.17_B17616.jpg" width="559"/>
</div>
</div>
<p class="figure-caption">Figure 14.17 – Attaching to the vulnerable client in WinDbg</p>
<p>Now, you’re<a id="_idIndexMarker1016"/> ready to <a id="_idIndexMarker1017"/>connect to the fuzzer. After the 4,000 bytes are received by the client, it crashes – but we can see <a id="_idIndexMarker1018"/>that the EIP register is overwritten with <strong class="source-inline">0x43387143</strong>. The manual fuzzer in you is anticipating something such as <strong class="source-inline">0x41414141</strong> or <strong class="source-inline">0x7a7a7a7a</strong>, but don’t forget that we’re using a unique pattern to find our offset, as shown here:</p>
<div>
<div class="IMG---Figure" id="_idContainer292">
<img alt="Figure 14.18 – Viewing register contents after the crash " height="159" src="image/Figure_14.18_B17616.jpg" width="949"/>
</div>
</div>
<p class="figure-caption">Figure 14.18 – Viewing register contents after the crash</p>
<p>I know what the hacker in you is saying right now – <em class="italic">we’re on an Intel processor, so that’s a little-endian EIP address, isn’t it?</em> Not bad, young apprentice. This means that <strong class="source-inline">0x43387143</strong> is actually <strong class="source-inline">43 71 38 43</strong>. Doing a quick lookup on a hexadecimal ASCII table shows us the <strong class="source-inline">Cq8C</strong> pattern. Hold on to that value for the offset calculation with <strong class="source-inline">pattern_offset.rb</strong>:</p>
<pre class="source-code"># ./pattern_offset.rb --length 4000 --query Cq8C</pre>
<div>
<div class="IMG---Figure" id="_idContainer293">
<img alt="Figure 14.19 – Identifying the position of our payload that made it to EIP " height="99" src="image/Figure_14.19_B17616.jpg" width="869"/>
</div>
</div>
<p class="figure-caption">Figure 14.19 – Identifying the position of our payload that made it to EIP</p>
<p>As you can see, <strong class="source-inline">pattern_offset</strong> knows what to look for within a given length provided to <strong class="source-inline">pattern_create</strong>.</p>
<p>I know <a id="_idIndexMarker1019"/>what you’re wondering because I wondered the same thing: does the offset include the 4 bytes that overwrite the return address? In other words, if the offset is found<a id="_idIndexMarker1020"/> to be 2,064 bytes, do we<a id="_idIndexMarker1021"/> need to put in 2,060 bytes of fluff? Once again, the friendly neighborhood hackers at Metasploit considered that and decided to make it consistent. What you see is what you need in your exploit code. So, we’ll go back to our Python script one more time and multiply our junk byte by the exact offset value discovered by <strong class="source-inline">pattern_offset</strong>, and then concatenate the hex string of the memory location that execution will flow to:</p>
<pre class="source-code">fuzz = b"\x7a" * 2064 + b"\xef\xbe\xad\xde"</pre>
<p>Let’s take a look at what this looks like in our script:</p>
<div>
<div class="IMG---Figure" id="_idContainer294">
<img alt="Figure 14.20 – Testing our math " height="242" src="image/Figure_14.20_B17616.jpg" width="863"/>
</div>
</div>
<p class="figure-caption">Figure 14.20 – Testing our math</p>
<p>Fire it off one more time and watch the EIP (as well as the <strong class="bold">Exception Offset:</strong> value in the Windows error message). Congratulations! You have all the pieces needed to construct a working exploit:</p>
<div>
<div class="IMG---Figure" id="_idContainer295">
<img alt="Figure 14.21 – Payload size confirmed! " height="164" src="image/Figure_14.21_B17616.jpg" width="953"/>
</div>
</div>
<p class="figure-caption">Figure 14.21 – Payload size confirmed!</p>
<p>Our special gift is looking very pretty, but we still need to do a little math to wrap it up.</p>
<h2 id="_idParaDest-273"><a id="_idTextAnchor272"/>Shellcode algebra – turning the fuzzing data into an exploit</h2>
<p>Like a giddy<a id="_idIndexMarker1022"/> child running to buy candy, I pull up <strong class="source-inline">msfvenom</strong> to generate some shellcode. I have a Windows Meterpreter chunk of <a id="_idIndexMarker1023"/>shellcode <a id="_idIndexMarker1024"/>that tips the scales at 341 bytes. My little fuzz-and-crash script works, but with 2,064 bytes of <em class="italic">z</em> followed by the desired address. To make this work, I need to turn that into NOPs followed by shellcode. This becomes a simple matter of <em class="italic">x </em>+ <em class="italic">341</em> = <em class="italic">2,064</em>:</p>
<div>
<div class="IMG---Figure" id="_idContainer296">
<img alt="Figure 14.22 – Allowing for shellcode in the final calculation " height="214" src="image/Figure_14.22_B17616.jpg" width="918"/>
</div>
</div>
<p class="figure-caption">Figure 14.22 – Allowing for shellcode in the final calculation</p>
<p>One of the nice things about using Python for our exploits is that <strong class="source-inline">msfvenom</strong> is ready to spit out shellcode in a dump-and-go format:</p>
<div>
<div class="IMG---Figure" id="_idContainer297">
<img alt="Figure 14.23 – Incorporating the algebra in our exploit " height="90" src="image/Figure_14.23_B17616.jpg" width="851"/>
</div>
</div>
<p class="figure-caption">Figure 14.23 – Incorporating the algebra in our exploit</p>
<p>I leave it to you to get your chosen shellcode executed. Happy hunting!</p>
<h1 id="_idParaDest-274"><a id="_idTextAnchor273"/>Summary</h1>
<p>In this chapter, we introduced fuzzing as a testing methodology and an exploit research tool. We started with mutation fuzzing over the network to test an FTP server’s handling of mutated authentication requests. With this information, we developed Python scripts that automate the fuzzing process. While we were exploring Python fuzzing, we built a fuzzing server to provide input to a vulnerable FTP client. With both pieces of software, the goal was to crash them and learn what input from the fuzzer caused the crash. We wrapped up by looking at these crashes from a low-level register memory perspective. This was accomplished by attaching WinDbg to the vulnerable processes and examining memory after the crash. With Metasploit’s offset discovery tools, we demonstrated how to use debugging and fuzzing to write precise exploits.</p>
<p>In the next chapter, we will take a deeper look into the post-exploitation phase of a penetration test so that we can learn how hackers turn an initial foothold into a wide-scale compromise.</p>
<h1 id="_idParaDest-275"><a id="_idTextAnchor274"/>Questions</h1>
<p>Answer the following questions to test your knowledge of this chapter:</p>
<ol>
<li>Fuzzing is one of the more popular attacks because it results in shellcode execution. (True | False)</li>
<li>Identify the fuzzing points range 4 through 8 in this request: <strong class="source-inline">USER administrator</strong>.</li>
<li>The <strong class="bold">Exception Offset</strong> value in the Windows crash dump is the same value that can be found in __________. </li>
<li>Name Metasploit’s two tools that are used together to find the EIP offset in an overflow.</li>
<li>An attacker has just discovered that if execution lands at <strong class="source-inline">0x04a755b1</strong>, their NOP sled will be triggered and run down to their Windows shellcode. The vulnerable buffer is 2,056 bytes long and the shellcode is 546 bytes long. They use the following line of code to prepare the shellcode: <strong class="source-inline">s = '\x90' * 1510 + buf + '\x04\xa7\x55\xb1'</strong>. Why is this attack bound to fail?</li>
</ol>
<h1 id="_idParaDest-276"><a id="_idTextAnchor275"/>Further reading</h1>
<p>For more information regarding the topics that were covered in this chapter, take a look at the following resources:</p>
<ul>
<li>Taof download: <a href="https://sourceforge.net/projects/taof">https://sourceforge.net/projects/taof</a></li>
<li>nfsAxe FTP Client version 3.7 for Windows installation: <a href="http://www.labf.com/download/nfsaxe.exe">http://www.labf.com/download/nfsaxe.exe</a></li>
<li>Vulnerable 3Com Daemon for Windows installation: <a href="http://www.oldversion.com/windows/3com-daemon-2r10">http://www.oldversion.com/windows/3com-daemon-2r10</a></li>
</ul>
</div>
</div></body></html>