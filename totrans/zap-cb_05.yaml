- en: '5'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Testing of Session Management
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Welcome to [*Chapter 5*](B18829_05.xhtml#_idTextAnchor200)! In this chapter,
    we will walk you through the recipes related to session management. The topics
    covered in this chapter will showcase to you how to use OWASP ZAP to capture and
    use session tokens that can then be used in multiple types of attacks.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following recipes:'
  prefs: []
  type: TYPE_NORMAL
- en: Testing for cookie attributes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Testing for cross-site request forgery (CSRF)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Testing for logout functionality
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Testing for session hijacking
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For this chapter, you will need to install OWASP ZAP Proxy and OWASP Juice Shop
    on your machine to intercept traffic between the browser and OWASP Juice Shop.
    In addition, utilize your PortSwigger account for access to the PortSwigger Academy
    labs that will be used in this chapter’s recipes. Lastly, the use of the Mutillidae
    II Docker environment is required to complete some of the attacks.
  prefs: []
  type: TYPE_NORMAL
- en: Mutillidae setup
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Mutillidae is an open source, insecure, and vulnerable web application used
    for training and learning with various types of vulnerability to be exploited
    with hints and help. This will help you learn how to perform attacks ranging from
    easy to more complicated. You can find more information about the project at [https://owasp.org/www-project-mutillidae-ii/](https://owasp.org/www-project-mutillidae-ii/).
    We are going to be using the Docker image for the simplicity of setup.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first step is to git clone or download the GitHub repository:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[https://github.com/Nanjuan/mutillidae-docker-nes](https://github.com/Nanjuan/mutillidae-docker-nes)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Once you have downloaded the GitHub repository, navigate to that folder in
    your terminal and view the file to make sure it looks as shown in *Figure 5**.1*:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 5.1 – Downloaded Mutillidae Repository](image/Figure_05.01_B18829.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.1 – Downloaded Mutillidae Repository
  prefs: []
  type: TYPE_NORMAL
- en: 'When you are inside the Mutillidae directory, run the following Docker command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '![Figure 5.2 – Mutillidae directory](image/Figure_05.02_B18829.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.2 – Mutillidae directory
  prefs: []
  type: TYPE_NORMAL
- en: 'Once Docker has finished setting up the environment, open your browser and
    navigate to localhost. You might notice that the localhost URL will redirect to
    **localhost/database-offline.php**, as shown in *Figure 5**.3*:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 5.3 – Localhost of Mutillidae](image/Figure_05.03_B18829.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.3 – Localhost of Mutillidae
  prefs: []
  type: TYPE_NORMAL
- en: Next, press the **Click here** button in *step 1,* as shown in *Figure 5**.3*.
    This will pop up a message. Click **OK**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 5.4 – Click here message](image/Figure_05.04_B18829.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.4 – Click here message
  prefs: []
  type: TYPE_NORMAL
- en: 'After you click **OK**, the application will redirect to the Mutillidae main
    page, as shown in *Figure 5**.5*:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 5.5 – Mutillidae home page](image/Figure_05.05_B18829.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.5 – Mutillidae home page
  prefs: []
  type: TYPE_NORMAL
- en: This completes the setup.
  prefs: []
  type: TYPE_NORMAL
- en: Testing for cookie attributes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Cookies are text files stored by websites on your computer. Websites utilize
    cookies to track users’ activities, provide a personalized experience, and/or
    for session management. Therefore, in most cases, cookies contain a wealth of
    private information about users, which makes them a target for criminals.
  prefs: []
  type: TYPE_NORMAL
- en: 'Due to the sensitivity of the data that could be stored in the cookies, the
    industry has created cookie attributes to help secure the cookie’s data. Here
    are the attributes that could be set and an explanation of each one:'
  prefs: []
  type: TYPE_NORMAL
- en: '**The** **Secure attribute**:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The **Secure** attribute ensures that the cookie is sent over HTTPS to prevent
    man-in-the-middle attacks.
  prefs: []
  type: TYPE_NORMAL
- en: '**The** **HttpOnly attribute**:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The **HttpOnly** attribute is set to prevent client-side scripts from accessing
    the cookie data. This attribute is used as another layer of protection against
    cross-site scripting attacks.
  prefs: []
  type: TYPE_NORMAL
- en: '**The** **Domain attribute**:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The **Domain** attribute is used to set the scope of where the cookie can be
    used. If the domain in the request URL does not match the domain in the **Domain**
    attribute, the cookie will be invalid.
  prefs: []
  type: TYPE_NORMAL
- en: '**The** **Path attribute**:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The **Path** attribute is set to specify the path the cookie can use. If the
    path matches, then the cookie will be sent in the request.
  prefs: []
  type: TYPE_NORMAL
- en: '**The** **Expires attribute**:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The **Expires** attribute is set to specify the lifetime of the cookie.
  prefs: []
  type: TYPE_NORMAL
- en: '**The** **SameSite attribute**:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The **SameSite** attribute is set to limit sending the cookie with cross-site
    requests. This attribute is used to limit sharing cookies with third parties and
    as a protection from **cross-site request forgery** (**CSRF**) attacks. The **SameSite**
    attribute can be set to one of these values, **Strict**, **Lax**, or **None**.
    If you set the value to **None**, the cookie will be sent in cross-site requests.
    If you set the value to **Strict**, the cookie will only be sent to the site where
    it originated. If you set the value to **Lax**, the cookie will be sent if the
    URL equals the cookie’s domain, even if it was originated by a third party.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For this recipe, you will need to start ZAP and ensure that it is intercepting
    the communications between the server and your browser. In addition, you need
    a user account for the PortSwigger Academy ([portswigger.net/web-security](http://portswigger.net/web-security)).
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'By default, ZAP has rules in the Passive Scanner that alert if one of the previously
    defined attributes is not set. In this recipe, we are going to start a PortSwigger
    lab to see the cookie alert in ZAP. The following steps guide you through this
    process:'
  prefs: []
  type: TYPE_NORMAL
- en: The first step is to browse [portswigger.net/web-security](http://portswigger.net/web-security)
    and click on **All Labs** in the top navigation bar.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Once you are on the Labs page, click on **Exploiting cross-site scripting to
    steal cookies >>**, as shown in *Figure 5**.6*:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 5.6 – The PortSwigger lab](image/Figure_05.06_B18829.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.6 – The PortSwigger lab
  prefs: []
  type: TYPE_NORMAL
- en: 'Click on **Access the lab**, as shown in *Figure 5**.7*, and log in:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 5.7 – Accessing the lab](image/Figure_05.07_B18829.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.7 – Accessing the lab
  prefs: []
  type: TYPE_NORMAL
- en: 'The lab provides a vulnerable application. Once the application is opened,
    add it to the scope in ZAP by clicking on the **New Context** button in ZAP and
    choosing the application as the **Top Node** in the **New Context** window, as
    shown in *Figure 5**.8*:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 5.8 – The New Context window](image/Figure_05.08_B18829.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.8 – The New Context window
  prefs: []
  type: TYPE_NORMAL
- en: Click on the target icon to only show findings for in-scope applications.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Right-click the Contexts and click on **Spider…**, as shown in *Figure 5**.9*,
    to spider the website:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 5.9 – Spidering](image/Figure_05.09_B18829.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.9 – Spidering
  prefs: []
  type: TYPE_NORMAL
- en: Doing so will add the spider to the bottom window of ZAP if it was not there,
    and you will see the progress bar.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once the spidering is complete, click on the **Alerts** tab in the bottom window.
    You can see that ZAP discovered that this application’s cookie does not contain
    the **HttpOnly** flag and the **SameSite** attribute, as shown in *Figure 5**.10*:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 5.10 – Cookie alerts](image/Figure_05.10_B18829.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.10 – Cookie alerts
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this lab, we have seen how ZAP can be used to test for missing cookie security
    attributes. ZAP contains built-in rules to trigger an alert if a cookie does not
    contain the security cookie attributes. ZAP discovers these findings passively;
    an active scan is not required.
  prefs: []
  type: TYPE_NORMAL
- en: Testing for cross-site request forgery (CSRF)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we will cover how to perform CSRF, where we will be able to
    post a comment as a different user. The application needs to be secure as a CSRF
    vulnerability allows the attacker to take advantage and get users to change sensitive
    information without them knowing.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To prepare for this recipe, please start ZAP and Mutillidae II. Make sure that
    ZAP intercepts traffic from the Mutillidae II application. You will also need
    a testing account in Mutillidae II to post the message.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The first step is to log in to Mutillidae II with the account you created and
    navigate to the blog, and while the proxy is enabled, submit a blog post in the
    application Using the drop-down, go to OWASP 2013, then to A8 - Cross Site Request
    Forgery (CSRF), and then to Add to your Blog. With the proxy enabled, submit a
    blog post in the application:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 5.11 – The Mutillidae Add Blog page](image/Figure_05.11_B18829.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.11 – The Mutillidae Add Blog page
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.12 – Mutillidae Current Blog Entries](image/Figure_05.12_B18829.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.12 – Mutillidae Current Blog Entries
  prefs: []
  type: TYPE_NORMAL
- en: 'Go to ZAP Proxy and right click on the POST request, and click on **Generate
    Anti-CSRF** **test FORM**:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 5.13 – Generate Anti-CSRF Test FORM](image/Figure_05.13_B18829.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.13 – Generate Anti-CSRF Test FORM
  prefs: []
  type: TYPE_NORMAL
- en: 'This will open a screen with the fields and CSRF token on the page:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.14 – Blog Entry csrf-token field](image/Figure_05.14_B18829.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.14 – Blog Entry csrf-token field
  prefs: []
  type: TYPE_NORMAL
- en: 'Log in as another user in the same browser, and then on the form, we are going
    to enter a random CSRF token and the attacker blog entry:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 5.15 – Mutillidae CSRF token field manipulation](image/Figure_05.15_B18829.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.15 – Mutillidae CSRF token field manipulation
  prefs: []
  type: TYPE_NORMAL
- en: 'Notice that after clicking the **Submit** button on the ZAP anti-CSRF form,
    the page redirects to the blog page with your blog entry submitted by the anti-CSRF
    form created by ZAP Proxy:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 5.16– The CSRF payload](image/Figure_05.16_B18829.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.16– The CSRF payload
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For this recipe, you were able to submit a request without any CSRF token to
    a victim user. This is done by abusing a misconfiguration on the application code
    that allows a request to be accepted without validating the CSRF token and the
    user that is logged into the application.
  prefs: []
  type: TYPE_NORMAL
- en: Testing for logout functionality
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This recipe focuses on testing the logout mechanism of the website. The logout
    mechanism is important in applications to terminate active sessions. Some attacks,
    such as cross-site scripting and CSRF, depend on having an active session present
    for a user account. Therefore, having well-built and configured logout functionality
    to terminate active sessions after a predefined time frame or after the user logout
    can help prevent cross-site scripting and CSRF attacks.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are three elements that session termination requires and that should
    be tested for:'
  prefs: []
  type: TYPE_NORMAL
- en: The first one is a logout function. This usually appears as the logout button
    on most websites. The button should be present on all pages, and it should be
    noticeable so that the user cannot miss it when they decide to log out.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The second is the session timeout period. The session timeout period specifies
    the length of the inactivity period before a session is terminated.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The third is server-side session termination. The application must ensure that
    the session state is terminated on the server side when a user logs out or the
    timeout period has been surpassed.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To get ready for this lab, ensure that OWASP Juice Shop is running and that
    ZAP is intercepting the communications between the browser and OWASP Juice Shop.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this lab, we will test to see whether the session is terminated on the server
    side when a user has logged out. Follow these steps to see how to do this:'
  prefs: []
  type: TYPE_NORMAL
- en: Start the OWASP Juice Shop application.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Start ZAP and add OWASP Juice Shop to the scope.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open Juice Shop and go to the login page.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open ZAP and add a breakpoint by clicking on the green circle **Set break on
    all requests and responses** button. The green circle button will then turn red.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Log in as the administrator. The administrator credentials are [admin@juice-sh.op](mailto:admin@juice-sh.op)
    for the email address and **admin123** as the password.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Click the **Step** button until you see the response to the login request that
    contains the token ID, as seen in *Figure 5**.17*. Then click on **Continue**:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 5.17 – JWT token ID](image/Figure_05.17_B18829.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.17 – JWT token ID
  prefs: []
  type: TYPE_NORMAL
- en: 'In the Juice Shop application, click on **Account**, then **Orders & Payments**,
    and then click on **Order History**, as seen in *Figure 5**.18*:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 5.18 – Order History to Orders & Payment](image/Figure_05.18_B18829.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.18 – Order History to Orders & Payment
  prefs: []
  type: TYPE_NORMAL
- en: Log out of Juice Shop by clicking on **Account** and then **Logout**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Open ZAP, and in the **History** tab, search for the GET request to the following
    **/rest/order-history** URL, as shown in *Figure 5**.19*:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 5.19 – The GET request of /rest/order-history](image/Figure_05.19_B18829.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.19 – The GET request of /rest/order-history
  prefs: []
  type: TYPE_NORMAL
- en: 'Right-click the request and select **Open/Resend with Request Editor…**, as
    shown in *Figure 5**.20*:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 5.20 – Request Editor](image/Figure_05.20_B18829.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.20 – Request Editor
  prefs: []
  type: TYPE_NORMAL
- en: This will open the **Manual Request Editor**. In the request editor, you can
    edit the request.
  prefs: []
  type: TYPE_NORMAL
- en: 'Click on **Send** to resend the request:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 5.21 – Manual Request Editor Send](image/Figure_05.21_B18829.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.21 – Manual Request Editor Send
  prefs: []
  type: TYPE_NORMAL
- en: 'After sending the request, the **Response** tab will open, which will include
    the server response. You can see that the request was accepted, and the response
    included the order history of the admin user, as shown in *Figure 5**.22*:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 5.22 – Order history response](image/Figure_05.22_B18829.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.22 – Order history response
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this lab, we resent a request as the admin user after the user has already
    signed out. The request was accepted by the server, and a response was sent with
    the user’s information, which proves that even though we have logged out as the
    admin user, the application has not terminated the admin user’s session in the
    backend, which allowed us to perform unauthorized action.
  prefs: []
  type: TYPE_NORMAL
- en: There’s more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Other types of logout functionality tests, such as session timeout, can be tested
    by waiting at incremental times (i.e., 15 minutes, 30 minutes, 1 hour, 1 day).
    To test, log in to the application and set a timer. Wait at incremental times
    to hopefully obtain a successful logout. Once the time has passed, attempt to
    refresh the web application page, perform an action on the application, or resend
    a request to trigger a session timeout on applications.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A similar attack that exploits session variables is Session Puzzling or Session
    Variable Overloading. Applications that use session variables for multiple purposes
    are vulnerable to this kind of attack. The following link contains more information
    about this type of attack: [https://owasp.org/www-project-web-security-testing-guide/latest/4-Web_Application_Security_Testing/06-Session_Management_Testing/08-Testing_for_Session_Puzzling](https://owasp.org/www-project-web-security-testing-guide/latest/4-Web_Application_Security_Testing/06-Session_Management_Testing/08-Testing_for_Session_Puzzling).'
  prefs: []
  type: TYPE_NORMAL
- en: Testing for session hijacking
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we will be walking through how to hijack a session by exploiting
    a web session’s control mechanism, known as the session token, and using this
    token, aka cookie, to take over an unsuspecting user’s session. Common compromises
    are due to tokens being predictable through session sniffing, malicious JavaScript
    code (i.e., XSS, CSRF), or **machine-in-the-middle** (**MiTM**) attacks.
  prefs: []
  type: TYPE_NORMAL
- en: We will use MiTM attacks to steal a session token via a cross-site scripting
    attack and replay the stolen token on another user that will compromise their
    session, logging into that user’s authenticated Juice Shop account.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To prepare for this recipe, please start ZAP and OWASP Juice Shop. Make sure
    that ZAP intercepts traffic at the OWASP Juice Shop application home page, and
    register/create two different users.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We’ll lead you through steps on how to conduct session hijacking by utilizing
    two users in OWASP Juice Shop, capturing a session cookie or token via MiTM and
    loading this into a different user’s request, hijacking that session, and authenticating
    to a user’s account.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following steps guide you through this process:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Open ZAP’s **Manual Explore** page, enter the Juice Shop URL, and click on
    **Launch Browser**, as seen in *Figure 5**.23*:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 5.23 – Manual Explore in the Juice Shop URL](image/Figure_05.23_B18829.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.23 – Manual Explore in the Juice Shop URL
  prefs: []
  type: TYPE_NORMAL
- en: Start by going to **Account** to **Login** to **Not Yet** **a Customer**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a **User1@email.com** with any password and anything for the security
    question.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: After creating the first user, repeat *step 1* and *step 2* to create a **User2@email.com**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Log in to Juice Shop with the *User1* account.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set break on all requests and responses and refresh the logged-in web page of
    *User1*.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'This can be achieved either through the **Manual Explore** browser that was
    launched or in the Workspace Window:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.24 – Set break on all requests and responses](image/Figure_05.24_B18829.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.24 – Set break on all requests and responses
  prefs: []
  type: TYPE_NORMAL
- en: In ZAP, you will see a new tab open called **Break**, as seen in *Figure 5**.25*,
    in the **Workspace Window** that captured the *User1* session (JWT) token.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Copy all text between **token=** and **Upgrade-Insecure-Requests** from the
    request:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 5.25 – Captured session token](image/Figure_05.25_B18829.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.25 – Captured session token
  prefs: []
  type: TYPE_NORMAL
- en: Log out of *User1* and log in with *User2*.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: While logged in as *User2*, open the browser **Inspect** tool and go to the
    **Storage** tab.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the cookies’ jar, click to open the drop-down menu and select the Juice Shop
    URL.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Replace the token element of *User2* with the session token of *User1* and hit
    *Enter* on the keyboard.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Refresh the browser web page and open the **Account** menu of Juice Shop. It
    will now show *User1* as being logged in instead of *User2*, successfully hijacking
    *User1*’s session.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The act of taking control of a user’s session without the user’s knowledge or
    consent is known as session hijacking. This may be accomplished by obtaining the
    user’s **JSON Web Token** (**JWT**), a token used to authenticate users in a web
    application.
  prefs: []
  type: TYPE_NORMAL
- en: An attacker who obtains a victim’s JWT can impersonate the victim and acquire
    access to the victim’s account. This is accomplished by putting the stolen JWT
    in the HTTP header of a web application request. Because the JWT seems to be authentic
    and provided by the application, the application will treat the request as if
    it came from the victim.
  prefs: []
  type: TYPE_NORMAL
- en: Attackers can gain a victim’s JWT in a variety of ways, including phishing attacks,
    MiTM attacks, and exploiting weaknesses in the application or the victim’s device.
  prefs: []
  type: TYPE_NORMAL
- en: There’s more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: ZAP can scan for JWT token vulnerabilities by going into **Options** and scrolling
    down to the **JWT** settings within **General** | **Enable Client Configuration
    Scan**. Later, in [*Chapter 10*](B18829_10.xhtml#_idTextAnchor362), *Advanced
    Attack Techniques*, within the *Working with JSON Web Tokens* recipe, we’ll review
    how this is used and abused in ZAP. In addition, these tokens can be decoded using
    the **Encode/Decode/Hash** tool to see what is contained within, such as the header
    algorithm, username, password, token expiration, and so on. In *Chapter 12*, we’ll
    further discuss the structure of JWT tokens, how to decode them, and showcase
    attacks that can be attempted.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Consider further reading to understand session hijacking and to understand
    remediations for this type of attack:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://owasp.org/www-community/attacks/Session_hijacking_attack#](https://owasp.org/www-community/attacks/Session_hijacking_attack#)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://cheatsheetseries.owasp.org/cheatsheets/Session_Management_Cheat_Sheet.html](https://cheatsheetseries.owasp.org/cheatsheets/Session_Management_Cheat_Sheet.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://owasp.deteact.com/cheat/cheatsheets/Input_Validation_Cheat_Sheet.html](https://owasp.deteact.com/cheat/cheatsheets/Input_Validation_Cheat_Sheet.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
