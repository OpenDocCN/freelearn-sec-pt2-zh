- en: '7'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Validating (Data) Inputs – Part 2
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Here in [*Chapter 7*](B18829_07.xhtml#_idTextAnchor262), we will continue with
    input validation. We will cover **code injection**, which enables the attacker
    to insert custom code into the program that it will then run. We will then take
    a look at **command injection**, which uses pre-existing code to run commands,
    typically in the context of a shell. We’ll discuss **server-side template injection**
    (**SSTI**), which is when user input is inserted in an unsafe manner in a template,
    resulting in remote code execution on the server. Lastly, we will cover **Server-Side
    Request Forgery** (**SSRF**), which exploits the server functionality to read
    or alter internal resources.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following recipes:'
  prefs: []
  type: TYPE_NORMAL
- en: Testing for code injection
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Testing for command injection
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Testing for server-side template injection
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Testing for server-side request forgery
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For this chapter, it is required that you install OWASP ZAP and utilize your
    PortSwigger account for access to the PortSwigger Academy labs.
  prefs: []
  type: TYPE_NORMAL
- en: Testing for code injection
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Code injection is a vulnerability that involves injecting code into the application
    that is then interpreted or executed by the application. This vulnerability allows
    an attacker to get information from the backend of the application all the way
    up to fully compromising the application.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we will walk you through the *Remote code execution via web
    shell upload* PortSwigger lab to create and upload a new file via the web application
    feature that includes the code injection payload.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This lab requires a PortSwigger Academy account and ZAP to intercept requests
    and responses from the server to your browser.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this lab, you will be exposed to a vulnerable image upload feature that does
    not validate the files uploaded by users before putting them on the server’s storage.
  prefs: []
  type: TYPE_NORMAL
- en: You will exploit this flaw by uploading a simple PHP web shell and utilizing
    it to exfiltrate the contents of the **/****home/carlos/secret** file.
  prefs: []
  type: TYPE_NORMAL
- en: 'Navigate to the *Remote code execution via web shell upload* PortSwigger Academy
    lab and obtain the credentials provided in the lab description. The following
    URL points to the lab: [https://portswigger.net/web-security/file-upload/lab-file-upload-remote-code-execution-via-web-shell-upload](https://portswigger.net/web-security/file-upload/lab-file-upload-remote-code-execution-via-web-shell-upload):'
  prefs: []
  type: TYPE_NORMAL
- en: With the browser proxied to ZAP, log into the PortSwigger Academy website to
    launch the lab.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Once you launch the lab, navigate to **My Account** and log in with the **wiener**
    account, and **peter** as the password. This is also provided on the lab instruction
    page, where you click to launch the application.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: From the **My Account** page, click **Choose File** and select any image you
    have to upload. In *Figure 7**.1*, you can see I have selected an Avatar picture
    of myself and uploaded the photo. After you upload the picture, click on **back
    to my account**, and you will notice now you can see the image uploaded.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 7.1 – The My Account page](image/Figure_7.01_B18829.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.1 – The My Account page
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, check the ZAP Sites window for the request that the application used
    to obtain the avatar image from the **My Account** page, as shown in *Figure 7**.2*:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 7.2 – The avatar image request](image/Figure_7.02_B18829.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.2 – The avatar image request
  prefs: []
  type: TYPE_NORMAL
- en: 'Then right-click on the image, as shown in *Figure 7**.3*, and click on **Open/Resend
    with** **Request Editor**:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 7.3 – The Open/Resend with Request Editor option](image/Figure_7.03_B18829.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.3 – The Open/Resend with Request Editor option
  prefs: []
  type: TYPE_NORMAL
- en: 'From here, you can minimize the current **Request Editor** window to create
    a new file with the code injection payload. The file you are going to create is
    named **exploit.php**, and the code inside the file is shown as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: After you have created the payload file and saved it, go ahead and upload the
    file in the same way you uploaded the profile image.
  prefs: []
  type: TYPE_NORMAL
- en: 'Notice that once you select the **exploit.php** file to upload as the avatar
    image, the name of the file is shown before you upload the file, as shown in *Figure
    7**.4*:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 7.4 – Upload image feature](image/Figure_7.04_B18829.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.4 – Upload image feature
  prefs: []
  type: TYPE_NORMAL
- en: Once you upload the exploit file, you can go back to ZAP, and in the **Manual
    Request Editor** window that you minimized earlier, change the path at the end
    of your URL to **/files/avatars/exploit.php** and send the request. Notice that
    it returns a random generated string. This is the solution needed to complete
    the lab that demonstrates how we can read the file inside the server located in
    the same path we used for our **/****home/carlos/secret** exploit.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Congratulations! You have read a file inside a server by exploiting a code injection
    vulnerability on the application.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Code injection is a technique for injecting arbitrary code into a program or
    process to execute it. This can be done for several reasons, such as testing,
    debugging, or malevolent objectives, such as malware.
  prefs: []
  type: TYPE_NORMAL
- en: 'Code injection can happen in a variety of ways:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Buffer overflow**: A buffer overflow vulnerability happens when software
    attempts to store more data than it is meant to contain in a buffer (a temporary
    data storage space). This can overwrite nearby memory, allowing an attacker to
    execute arbitrary code.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**SQL injection**: SQL injection is a kind of code injection in which an attacker
    may send malicious SQL statements to a database server via a susceptible application.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Cross-site scripting (XSS)**: XSS is a kind of code injection in which an
    attacker injects malicious code into a web page, which is subsequently executed
    by the victim’s browser.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Remote code execution (RCE)**: RCE is a kind of code injection in which an
    attacker is able to execute code on a remote machine by exploiting a vulnerability
    in a network service or application.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Code injection can be avoided by using effective input validation and sanitization,
    safe coding techniques, and frequent security updates and patches.
  prefs: []
  type: TYPE_NORMAL
- en: Testing for command injection
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Command injection is a vulnerability that enables an attacker to execute commands
    on the application’s underlying operating system (the host). This vulnerability
    occurs when the application takes unsanitized and unvalidated user input and executes
    it in a system command. Some examples of system commands are **grep**, **exec**,
    and **system**. The system commands differ depending on the programming language
    that the application is developed with. Usually, to perform the command injection
    attack, you provide the application with the expected input and then a special
    character to execute the desired commands right after the expected input (command).
    Special characters, such as **|**, **&**, **;**, **|**, **||**, **&**, **&&**,
    and **\n** append more commands to the executed command. Using these special characters,
    you can execute more commands at the same time. The severity of the vulnerability
    is determined by the permissions granted to the application’s user account. It
    could be as critical as viewing the passwords stored in the system, exfiltrating
    data, or interacting with other systems on the network.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we will walk through the *OS command injection, simple case*
    lab in PortSwigger’s Web Security Academy and learn how to exploit the vulnerability
    of successfully triggering commands that we input.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You will need to start ZAP and ensure it intercepts the request and responses
    between your browser and the PortSwigger Academy lab.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To demonstrate how to exploit a common injection vulnerability, we are going
    to use one of PortSwigger’s Web Security Academy labs. ZAP will intercept the
    traffic, and we will modify a request to exploit the vulnerability.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following steps walk you through completing the lab and exploiting the
    vulnerability:'
  prefs: []
  type: TYPE_NORMAL
- en: Start ZAP, and in your browser, navigate to PortSwigger Academy. Log in and
    click on the **All** **Labs** button.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Scroll down to the **OS command injection** section, and click on the **OS
    command injection, simple case** lab, found at [https://portswigger.net/web-security/os-command-injection/lab-simple](https://portswigger.net/web-security/os-command-injection/lab-simple):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 7.5 – The OS command injection lab](image/Figure_7.05_B18829.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.5 – The OS command injection lab
  prefs: []
  type: TYPE_NORMAL
- en: Click on **Access the lab**, and the vulnerable application will open in a new
    tab.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add the application to the scope to limit the results you see to only the scope.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In this application, the function to check the stock level of every item shown
    is vulnerable to command injection vulnerability. Therefore, open any item, scroll
    to the bottom until you can select the **Check stock** button, as seen in *Figure
    7**.6*:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 7.6 – The Check stock button](image/Figure_7.06_B18829.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.6 – The Check stock button
  prefs: []
  type: TYPE_NORMAL
- en: 'We clicked on the button to generate the request. Now that the request has
    been sent, find it in the **History** tab of ZAP. It will be a **POST** HTTP request
    to **/product/stock**, as seen in *Figure 7**.7*:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 7.7 – A POST request to /product/stock](image/Figure_7.07_B18829.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.7 – A POST request to /product/stock
  prefs: []
  type: TYPE_NORMAL
- en: Right-click the request and click on **Open/Resend with Request Editor**, also
    known as **Manual** **Request Editor**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Manual Request Editor** will open in a new window. To exploit the vulnerability,
    add the **|** pipe symbol and a command right after **storeId=1**. For this step,
    add **|pwd**, as seen in *Figure 7**.8*, to see which directory we are in, and
    click on the **Send** button:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 7.8 – The storeId request](image/Figure_7.08_B18829.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.8 – The storeId request
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, the request we have sent with the system command has been executed,
    and now we can see that the directory we are in is **/home/peter-IkA8ei**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now, for fun, let’s create a file. Go back to the **Request** tab of **Manual
    Request Editor** and add the **|** pipe symbol and **cat > CommandInjection.txt**,
    as seen in *Figure 7**.9*. The **200** HTTP response status code tells us that
    the request was successful:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 7.9 –  The CommandInjection request](image/Figure_7.09_B18829.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.9 – The CommandInjection request
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, to see the file we have created, repeat the same steps, but this time
    add a **|** pipe symbol and the **ls** command, as seen in *Figure 7**.10*, and
    click on **Send**:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 7.10 – The ls command in request](image/Figure_7.10_B18829.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.10 – The ls command in request
  prefs: []
  type: TYPE_NORMAL
- en: 'In the response, you can see that the command was executed successfully, and
    we can see the file we have created listed, as seen in *Figure 7**.11*:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 7.11 – The executed command injection](image/Figure_7.11_B18829.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.11 – The executed command injection
  prefs: []
  type: TYPE_NORMAL
- en: This concludes this lab. In this lab, you successfully exploited a command injection
    vulnerability.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Since the application is vulnerable to command injections, it does not validate
    the user input. Therefore, we could execute system commands, see which directory
    we were in, and create files. We could also delete files if we wanted to.
  prefs: []
  type: TYPE_NORMAL
- en: Remediation measures for command injection vulnerabilities can be prevented
    by sanitizing the user’s input.
  prefs: []
  type: TYPE_NORMAL
- en: There’s more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'ZAP Active Scan can detect the command injection vulnerability. Run an active
    scan on the application, navigate to the **Alerts** tab after it has finished,
    and search for the presence of **Remote OS Command Injection**. In the alert,
    more information is provided about the vulnerability, and in the **Attack** field,
    you will see the successful payload. Using the payload observed in the **Attack**
    field, you can recreate the attack to view the password file or more. *Figure
    7**.12* is a screenshot of the alert:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.12 – The Alerts tab attack description](image/Figure_7.12_B18829.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.12 – The Alerts tab attack description
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Commix is an open source tool developed to automatically detect and exploit
    command injection vulnerability exploitation. It is also included as a tool in
    Kali Linux. To learn more about Commix, please visit the tool’s GitHub page ([https://github.com/commixproject/commix](https://github.com/commixproject/commix)).
  prefs: []
  type: TYPE_NORMAL
- en: Testing for server-side template injection
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, you will learn how to conduct a basic SSTI attack using a lab
    from PortSwigger Academy. Because of the insecure construction of an ERB template,
    the application in this lab is vulnerable to SSTI. You will learn what SSTI is
    by completing the lab. First, read the ERB documentation to learn how to run arbitrary
    code, then delete the **morale.txt** file from Carlos’s home directory.
  prefs: []
  type: TYPE_NORMAL
- en: Furthermore, you will learn how server-side templates work and how this leads
    to attackers exploiting vulnerabilities to gain control over the server.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Start up your local ZAP tool and log in to your PortSwigger Academy account,
    then go to the *Basic server-side template injection* lab at [https://portswigger.net/web-security/server-side-template-injection/exploiting/lab-server-side-template-injection-basic](https://portswigger.net/web-security/server-side-template-injection/exploiting/lab-server-side-template-injection-basic).
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A good first step toward exploitation is to fuzz the template by injecting
    a sequence of special characters commonly used in template expressions, such as
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'So when fuzzing produces an error or result, such as the use of mathematical
    equations, this will indicate that the template is vulnerable to injection as
    the server is attempting to evaluate the payload. Doing so is important in identifying
    its context before being able to exploit it:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, click **View Details** to learn more about the first product. A **GET**
    request uses the message parameter to render; then you will get the **Unfortunately
    this product is out of stock** message on the home page, as shown in *Figure 7**.13*:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 7.13 – The GET request displaying an out-of-stock message](image/Figure_7.13_B18829.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.13 – The GET request displaying an out-of-stock message
  prefs: []
  type: TYPE_NORMAL
- en: 'Looking up the ERB documentation (the *See also* section has a link to the
    documentation), you can see that the syntax for an expression is **<%= someExpression
    %>**, which is used to evaluate an expression and render the results on the page.
    You can also generate an error using the expression, which will disclose information
    that the template is using Ruby ERB. (see *Figure 7**.14*):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 7.14 – Internal Server Error disclosing Ruby ERB](image/Figure_7.14_B18829.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.14 – Internal Server Error disclosing Ruby ERB
  prefs: []
  type: TYPE_NORMAL
- en: 'Enter the URL of a test payload after **message=** containing a simple mathematical
    operation using the ERB expression syntax:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'You will notice that the math equation is solved and rendered to the page of
    the web application shown in *Figure 7**.15*. This will appear in the same place
    as before, as seen in *Figure 7**.16*. This indicates that we may have an SSTI
    vulnerability:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.15 – The math operation rendered to the web page](image/Figure_7.15_B18829.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.15 – The math operation rendered to the web page
  prefs: []
  type: TYPE_NORMAL
- en: 'Refer to the Ruby documentation and use the **system()** method. This method
    can be used to execute arbitrary operating system commands. You can test that
    the commands work with a simple Linux command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Here we can see the result of the command displayed back in the web application:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.16 – The pwd command result](image/Figure_7.16_B18829.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.16 – The pwd command result
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we can see the server is executing commands to print the current working
    directory as well as listing all files, let’s build a payload that will delete
    a file from Carlos’s directory:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Successful execution of the lab will result in a congratulations screen being
    displayed:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.17 – Lab solved](image/Figure_7.17_B18829.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.17 – Lab solved
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: If the command results in an error message or does not execute, convert the
    payload to be URL encoded, for example, **%3C%25%3D%20system%28%22ls%20-a%22%29%20%25%3E**.
  prefs: []
  type: TYPE_NORMAL
- en: 'Use the OWASP ZAP **Encode/Decode/Hash** tool or the *Ctrl + E* shortcut, as
    shown in *Figure 7**.18*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.18 – The Encode/Decode/Hash tool](image/Figure_7.18_B18829.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.18 – The Encode/Decode/Hash tool
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You can use static template files in your application thanks to template engines
    such as Smarty for PHP, Freemarker for Java, or Jinja2 for Python. The template
    engine replaces variables in the template file with actual user-provided values
    at runtime and converts the template into an HTML file that is sent to the client.
  prefs: []
  type: TYPE_NORMAL
- en: By submitting invalid syntax, a resulting error message will indicate to an
    attacker what template engine is being used and, in some cases, which version.
    This allows an attacker insight into crafting malicious payloads or invalid syntax
    into a template to execute server-side commands.
  prefs: []
  type: TYPE_NORMAL
- en: There’s more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Developers use server-side templates to preemptively load a web page with custom
    user data directly on the server. It is common for web frameworks to generate
    HTML code dynamically, where the template contains the static parts of the desired
    HTML output as well as the syntax that describes how dynamic content will be inserted.
  prefs: []
  type: TYPE_NORMAL
- en: The template engines then process template files, assisting in the fusion of
    dynamic data into web pages. When an HTTP request is received, the template engine
    generates the HTML output response.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'GitHub SSTI payloads: [https://github.com/payloadbox/ssti-payloads](https://github.com/payloadbox/ssti-payloads)'
  prefs: []
  type: TYPE_NORMAL
- en: For further reading on template frameworks, visit the followi[ng links:](https://www.smarty.net/)
  prefs: []
  type: TYPE_NORMAL
- en: '[For PHP:](https://www.smarty.net/)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Sma](https://www.smarty.net/)rty: [https://www.smarty.net/](https://www.smarty.net/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Twig: [https://twig.symfony.com/](https://twig.symfony.com/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'PHPTAL: [https://phptal.org/](https://phptal.org/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For Java:'
  prefs: []
  type: TYPE_NORMAL
- en: 'JSP/JSTL: [https://www.oracle.com/java/technologies/jstl-documentation.html](https://www.oracle.com/java/technologies/jstl-documentation.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Apache Velocity: [https://velocity.apache.org/](https://velocity.apache.org/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Apache FreeMarker: [https://freemarker.apache.org/](https://freemarker.apache.org/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Thymeleaf: [https://www.thymeleaf.org/](https://www.thymeleaf.org/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Pippo: [http://www.pippo.ro/](http://www.pippo.ro/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Groovy Server Pages** (**GSP**): [https://gsp.grails.org/latest/guide/index.html](https://gsp.grails.org/latest/guide/index.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For Python:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Jinja2: [https://pypi.org/project/Jinja2/](https://pypi.org/project/Jinja2/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Mako: [https://www.makotemplates.org/](https://www.makotemplates.org/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Tornado: [https://pypi.org/project/tornado/](https://pypi.org/project/tornado/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For Ruby:'
  prefs: []
  type: TYPE_NORMAL
- en: 'ERB: [https://ruby-doc.org/stdlib-3.1.2/libdoc/erb/rdoc/index.html](https://ruby-doc.org/stdlib-3.1.2/libdoc/erb/rdoc/index.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**system()**: [https://www.rubyguides.com/2018/12/ruby-system/](https://www.rubyguides.com/2018/12/ruby-system/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Haml: [https://rubygems.org/gems/haml/versions/5.1.2](https://rubygems.org/gems/haml/versions/5.1.2)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Slim: [https://rubygems.org/gems/slim/versions/4.1.0](https://rubygems.org/gems/slim/versions/4.1.0)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Testing for server-side request forgery
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Internal and external resources routinely interact with web applications. While
    you would expect only the intended resource to receive the data you supply, improper
    data management might result in SSRF, a kind of injection attack. A successful
    SSRF attack can grant the attacker access to restricted operations, internal services,
    or internal files within the program or the company. In this recipe, we will show
    how to perform an SSRF attack on a backend system to search for an internal IP
    address and subsequently remove the user.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Start up your local ZAP tool and log in to your PortSwigger Academy account,
    then go to the *Basic SSRF against another back-end system* lab at [https://portswigger.net/web-security/ssrf/lab-basic-ssrf-against-backend-system](https://portswigger.net/web-security/ssrf/lab-basic-ssrf-against-backend-system).
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We’ll utilize the PortSwigger Academy *Basic SSRF versus another back-end system*
    lab in this recipe. SSRF is an attack where an attacker sends malicious requests
    from a susceptible server to a target server, gaining access to otherwise restricted
    resources or information. Backend systems are the infrastructure and components
    that enable a website or application to function. These systems are often invisible
    to the end user and are in charge of functions such as data storage and processing,
    request and response management, and system integration.
  prefs: []
  type: TYPE_NORMAL
- en: 'Backend systems include the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Databases
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Application servers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Integration systems
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Backend systems, in general, are a significant aspect of a website’s or application’s
    overall architecture and are responsible for most of the behind-the-scenes work
    that allows the program to run successfully.
  prefs: []
  type: TYPE_NORMAL
- en: This lab contains a stock check feature that retrieves data from an internal
    system and then scans the internal IP address range for an admin interface, which
    is then used to remove the user Carlos.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following steps walk you through completing the lab and exploiting the
    vulnerability:'
  prefs: []
  type: TYPE_NORMAL
- en: Visit the web application and capture the traffic via a Manual or Automated
    Scan in ZAP.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Next, visit any product and click on **Check stock**, using **Break Set**,
    intercept the request, or select the path from the **Sites** window, right-clicking
    and going to **Manual Request Editor**, as seen in *Figure 7**.19*:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 7.19 – Locate stockAPI from the Sites window](image/Figure_7.19_B18829.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.19 – Locate stockAPI from the Sites window
  prefs: []
  type: TYPE_NORMAL
- en: 'Change the **stockApi** parameter value to **http://192.168.0.1:8080/admin/...**,
    which will let us access the administrator’s portal, as shown in *Figure 7**.20*:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 7.20 – The stockAPI request in Manual Request Editor](image/Figure_7.20_B18829.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.20 – The stockAPI request in Manual Request Editor
  prefs: []
  type: TYPE_NORMAL
- en: 'Highlight the final octet of the IP address (the number **1**) and right-click
    to open in **Fuzzer** (shown in *Figure 7**.21*):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 7.21 – The Fuzz stockAPI parameter value](image/Figure_7.21_B18829.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.21 – The Fuzz stockAPI parameter value
  prefs: []
  type: TYPE_NORMAL
- en: 'In **Fuzz Locations**, click **Add** twice to open a menu and switch **Type**
    to **Numberzz**. Then, fill in the following fields with the values provided:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**From**: **1**'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**To**: **255**'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Click **Add** to complete the payload (shown in *Figure 7**.22* and *Figure
    7**.23*).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Click **Start Fuzzer**:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 7.22 – Fuzzing the API endpoint](image/Figure_7.22_B18829.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.22 – Fuzzing the API endpoint
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.23 – The Numberzz payload](image/Figure_7.23_B18829.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.23 – The Numberzz payload
  prefs: []
  type: TYPE_NORMAL
- en: Click on the **Status** column in the Fuzzer **Information** window to sort
    the attack by status code. You will see an entry with a status of **200** that
    showcases there is a successful IP address for an admin page at that location.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Open the request again in **Manual Request Editor**, and change the path in
    **stockApi** to the following string:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: Convert the parameters into HTML-encoded strings.
  prefs: []
  type: TYPE_NORMAL
- en: Send the request to delete the user.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: SSRF is a form of attack in which an application that interacts with the internal/external
    network or the host itself is exploited. An example would be the mishandling of
    URL parameter factors or webhook customization, where users specify webhook handlers
    or callback URLs. Attackers can also interact with requests of another service
    to provide specific functionality. Most often, user data is sent to be processed
    by the server and, if improperly handled, can then be used to perform specific
    injection attacks.
  prefs: []
  type: TYPE_NORMAL
- en: SSRF attacks entail convincing a server to make a request to an external resource
    on the attacker’s behalf. For example, even if a **web application firewall**
    (**WAF**) is blocking regular requests, an attacker may be able to carry out an
    SSRF attack by discovering a means to circumvent the WAF.
  prefs: []
  type: TYPE_NORMAL
- en: An attacker might achieve this by utilizing a bypass method to avoid detection
    by the WAF. An attacker, for example, might use URL encoding, Unicode encoding,
    or other ways to change the look of the request in a way that the WAF does not
    identify as malicious. An attacker might also circumvent a WAF by discovering
    a weakness in the application that allows them to launch an SSRF attack.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, an attacker may discover a weakness in the application’s input
    validation that allows them to inject a URL into a form field that the server
    will execute on their behalf, as shown in *Figure 7**.24*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.24 – Diagram of an SSRF attack](image/Figure_7.24_B18829.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.24 – Diagram of an SSRF attack
  prefs: []
  type: TYPE_NORMAL
- en: There’s more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The HTTP protocol is not the only protocol where SSRF can occur. HTTP is used
    first in requests, but if an application performs a second request, it may use
    a variety of other protocols, such as FTP, SMB, SMTP, or others and/or schemes
    such as **file:/**, **data:/**, and **dict:/** and more.
  prefs: []
  type: TYPE_NORMAL
- en: In addition, SSRF is frequently used in cloud environments to gain access to
    and steal credentials or access tokens from metadata services, such as metadata
    servers in AWS or Azure environments.
  prefs: []
  type: TYPE_NORMAL
- en: Lastly, consider other attacks, such as **XML External Entity** (**XXE**) that
    can be leveraged to exploit an SSRF vulnerability.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For more information on XXE, visit *Chapter 13*.
  prefs: []
  type: TYPE_NORMAL
