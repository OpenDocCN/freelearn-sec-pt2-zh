- en: '9'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Client-Side Testing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When tackling client-side testing, the types of attacks are focused purely on
    the client (browser) and not vectors that move to exploit the server side of an
    application’s architecture. These types of attacks focus on client-side components
    of a system or application, such as the web browser or operating system. To find
    vulnerabilities and flaws, testers may employ a range of tools and methodologies,
    including manual testing, automated testing tools, and network scanners. You will
    learn to actively attack common issues, such as **document object model** **(DOM)-based
    cross-site scripting** (**XSS**), **JavaScript execution** such as disclosing
    an end user’s session cookies, **HTML injection**, where an attacker injects malicious
    code, **client-side URL redirect**, where an attacker manipulates a website or
    web application to redirect a victim’s client, **cross-origin resource sharing**,
    which exploits vulnerabilities in a web application’s security policy to access
    resources or data and **testing WebSockets**, where an attacker leverages WebSocket
    protocol flaws to intercept, tamper with, or falsify communications transmitted
    between a client and server. The purpose of client-side pen testing is to find
    and report vulnerabilities and flaws that attackers can potentially exploit. Organizations
    can improve the security of their systems and guard against possible attacks by
    detecting and fixing these vulnerabilities.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following recipes:'
  prefs: []
  type: TYPE_NORMAL
- en: Testing for DOM-based cross-site scripting
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Testing for JavaScript execution
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Testing for HTML injection
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Testing for client-side URL redirect
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Testing cross-origin resource sharing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Testing WebSockets
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For this chapter, it is required that you utilize a common browser such as Mozilla
    Firefox. You will also utilize your PortSwigger account to access the PortSwigger
    Academy labs that will be used in this chapter’s recipes.
  prefs: []
  type: TYPE_NORMAL
- en: Testing for DOM-based cross-site scripting
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This is opposed to reflected cross-site scripting, where malicious JavaScript
    is returned by the web server, or stored XSS, where attacks are permanently stored
    on the target server or database. Both of those attacks are server-side injection
    issues. When it comes to DOM XSS, it is purely client side. **DOM XSS** is an
    attack against the client (browser) DOM environment.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This lab requires a PortSwigger Academy account and ZAP to intercept requests
    and responses from the server to your browser.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this recipe, users will attack the search query tracking feature, which has
    a DOM-based XSS vulnerability. This weakness makes use of the **document.write**
    JavaScript function to output data to the web page. Then data from **location.search**,
    which can be modified using the URL, passes to the **document.write** method.
    To complete the lab, a DOM XSS attack needs to call an **alert** function.
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: Examining the page source code can be very helpful in discovering DOM XSS vulnerabilities
    that can be exploited by looking for common DOM elements that are used when creating
    attacks.
  prefs: []
  type: TYPE_NORMAL
- en: Navigate to the URL with the browser proxied to ZAP and log into the PortSwigger
    Academy website to launch the lab ([https://portswigger.net/web-security/cross-site-scripting/dom-based/lab-document-write-sink](https://portswigger.net/web-security/cross-site-scripting/dom-based/lab-document-write-sink)).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Once the lab loads, you’ll be at a main blog page with a search bar. Here, enter
    any word or letters into it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The application will attempt to look up your word and will be displayed back
    to you in single quotations. Right-click the result and select **Inspect**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'You’ll notice that your random string is placed inside an **img src** attribute,
    as shown in *Figure 9**.1*:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 9.1 – Inspect search results](image/Figure_9.1_B18829.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.1 – Inspect search results
  prefs: []
  type: TYPE_NORMAL
- en: 'Within the search bar, input a malicious **img** attribute, such as the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This HTML JavaScript will then be executed by the browser to create an alert
    popup displaying the text, **2**:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.2 – Exploited DOM XSS payload](image/Figure_9.2_B18829.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.2 – Exploited DOM XSS payload
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The DOM is a programming interface for online content that enables applications
    to alter the document’s structure, design, and content that represents the web
    page.
  prefs: []
  type: TYPE_NORMAL
- en: 'DOM-based XSS flaws often appear when any JavaScript property accepts data
    input from one of the following:'
  prefs: []
  type: TYPE_NORMAL
- en: A **source** (**location.search**) that an attacker can control
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A URL (**document.referrer**)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A user’s cookies (**document.cookie**)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A **sink** (**eval(), document.body.innerHTML**) that accepts harmful JavaScript
    functions or DOM objects
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Any of these could permit dynamic code execution leading to exploitation.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Several data sources inside the DOM are vulnerable to XSS attacks, as shown
    in the following list:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Input fields**: For example, text boxes and form fields can be vulnerable
    to XSS attacks if the user’s input is not properly sanitized before being shown
    on the website.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Query strings**: Where attackers can inject malicious code into a web page
    using the query string of a URL. This might happen if the program fails to verify
    or sanitize the query string before presenting it on the page.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Cookies**: If they are not adequately encrypted or include unsanitized user
    input, cookies might be vulnerable to XSS attacks.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Document properties**: The title and URL of a document might be vulnerable
    to XSS attacks if they are not properly sanitized before being shown on the page.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**JavaScript variables**: If they include unsanitized user input, JavaScript
    variables might be vulnerable to XSS attacks.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**HTML attributes**: HTML attributes containing unsanitized user input, such
    as the **src** attribute of an **image** tag, might be vulnerable to XSS attacks.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'jQuery is a popular JavaScript library commonly used to manipulate the DOM.
    Several jQuery functions can potentially lead to DOM-based XSS vulnerabilities
    if they are used improperly, as listed here:'
  prefs: []
  type: TYPE_NORMAL
- en: '**html()**: This function sets the HTML content of an element. If it is used
    to set the HTML content of an element to unsanitized user input, it can potentially
    lead to a DOM XSS vulnerability.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**append()**: This function inserts content at the end of an element. If it
    is used to insert unsanitized user input at the end of an element, it can potentially
    lead to a DOM XSS vulnerability.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**prepend()**: This function inserts content at the beginning of an element.
    If it is used to insert unsanitized user input at the beginning of an element,
    it can potentially lead to a DOM XSS vulnerability.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**before()**: This function inserts content before an element. If it is used
    to insert unsanitized user input before an element, it can potentially lead to
    a DOM XSS vulnerability.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**after()**: This function inserts content after an element. If it is used
    to insert unsanitized user input after an element, it can potentially lead to
    a DOM XSS vulnerability.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**text()**: This function sets the text content of an element. If it is used
    to set the text content of an element to unsanitized user input, it can potentially
    lead to a DOM XSS vulnerability.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It is important for web developers to properly sanitize all user input before
    coding with any of these functions, as well as **add()**, **animate()**, **insertAfter()**,
    **insertBefore()**, **replaceAll()**, **replaceWith()**, **wrap()**, **wrapInner()**,
    **wrapAll()**, **has()**, **constructor()**, **init()**, **index()**, **jQuery.parseHTML()**,
    and **$.parseHTML()**.
  prefs: []
  type: TYPE_NORMAL
- en: 'For other payloads, visit the following GitHub pages:'
  prefs: []
  type: TYPE_NORMAL
- en: '*PayloadsAllTheThings*: [https://github.com/swisskyrepo/PayloadsAllTheThings](https://github.com/swisskyrepo/PayloadsAllTheThings)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*SecLists*: [https://github.com/danielmiessler/SecLists/tree/master/Fuzzing/XSS](https://github.com/danielmiessler/SecLists/tree/master/Fuzzing/XSS)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*XSS Payload* *List*: [https://github.com/payloadbox/xss-payload-list](https://github.com/payloadbox/xss-payload-list)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: If downloading/cloning any of the repositories, ensure you have the right to
    install them as some lists, such as SecLists contain malicious payloads. If installed
    on a work laptop, you will likely have an endpoint detection and response solution
    or other security tool flag you for having malicious content, and someone from
    IT may be asking you why it’s on your workstation. Avoid getting in trouble.
  prefs: []
  type: TYPE_NORMAL
- en: Testing for JavaScript execution
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: JavaScript execution is the ability to inject and execute JavaScript in a website
    even if the website has some kind of protection, such as encoding certain characters.
    For many attackers, simple encoding of characters is not always a challenge; they
    find a way to bypass this encoding by creating a more complicated payload that
    is converted by the backend server as JavaScript and is allowed to run on the
    website.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This lab requires a PortSwigger academy account and ZAP to intercept requests
    and responses from the server to your browser.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this recipe, we are going to bypass an encoding mechanism to deliver our
    payload. You’ll see that we can inject JavaScript into the page and activate the
    payload because we’ll discover a way to get around the encoding method.
  prefs: []
  type: TYPE_NORMAL
- en: 'Take the following steps to get started:'
  prefs: []
  type: TYPE_NORMAL
- en: Navigate to the URL with the browser proxied to ZAP and log into the PortSwigger
    Academy website to launch the lab ([https://portswigger.net/web-security/cross-site-scripting/contexts/lab-javascript-string-angle-brackets-html-encoded](https://portswigger.net/web-security/cross-site-scripting/contexts/lab-javascript-string-angle-brackets-html-encoded)).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the application, enter any string within the **Search** field, as shown
    in *Figure 9**.3*, and then click on **Search**:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 9.3 – The web app search field](image/Figure_9.3_B18829.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.3 – The web app search field
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, go into ZAP and look at the **Sites** window. Look for the lab URL and
    click on it, as shown in *Figure 9**.4*:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 9.4 – The Sites window](image/Figure_9.4_B18829.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.4 – The Sites window
  prefs: []
  type: TYPE_NORMAL
- en: After you have selected the URL path, right-click on the drop-down menu and
    select **Open/Resend with** **Request Editor**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Look for the **search=** field in the URL (see Figure 9.5):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 9.5 – The search= field in Manual Request Editor](image/Figure_9.5_B18829.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.5 – The search= field in Manual Request Editor
  prefs: []
  type: TYPE_NORMAL
- en: 'Edit the **search=** field to set the payload to **`-alert(1)-`**, as shown
    in *Figure 9**.6*, and press **Send** to forward the request:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 9.6 – Set the payload in the search= field](image/Figure_9.6_B18829.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.6 – Set the payload in the search= field
  prefs: []
  type: TYPE_NORMAL
- en: 'Once you receive the response in **Manual Request Editor**, scroll down to
    where the code is returned within the website page, as shown in *Figure 9**.7*.
    As you will notice, the payload is not inside single quotes, but the **alert(1)**
    value is sent to the **searchTerms** object, which triggers the XSS payload in
    the browser:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 9.7 – Successful code returned](image/Figure_9.7_B18829.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.7 – Successful code returned
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: JavaScript execution vulnerabilities open the application to many common vulnerabilities,
    such as XSS and any payload created with JavaScript. JavaScript execution takes
    advantage of website vulnerabilities that allow a user control input to be returned
    to the website allowing the payload to be triggered there.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Attackers will use several techniques to help bypass protections. A common technique
    used is *URL encoding* aka *percent-encoding*, where certain characters in a URL
    or form field are replaced with their hexadecimal equivalent preceded by a percent
    symbol (**%**). For example, a very famous hacker character is the single quote
    (**'**), which is encoded as **%27**. Attackers use this technique to bypass security
    filters or to inject malicious code into a web application.
  prefs: []
  type: TYPE_NORMAL
- en: When this fails, another technique to bypass security is known as *double encoding*.
    This is when encoded values such as **%27** are encoded again to become **%2527**.
    This helps bypass filters that only check for a single encoded value.
  prefs: []
  type: TYPE_NORMAL
- en: The last technique is called *Unicode encoding*, which allows attackers to bypass
    blacklist-based input validation filters by using alternative encodings for potentially
    dangerous characters. In our same example, **%27** becomes **U+0025U+0027** or
    even further written as **U+0025U+0032U+0037**. These attacks can also become
    more complex by representing the single quote in its Unicode-encoded form as a
    full-width apostrophe (**U+FF07**) or encoded as **%EF%BC%87** in UTF-8 form.
  prefs: []
  type: TYPE_NORMAL
- en: When testing, it’s good to attempt various attacks to understand how the application
    is being protected and that fields are properly validating input or being parameterized
    in the case of SQL statements.
  prefs: []
  type: TYPE_NORMAL
- en: Testing for HTML injection
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: HTML injection is when a user has access to an **input** parameter on the web
    application and can inject arbitrary HTML code into that web page.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This lab requires a PortSwigger Academy account and ZAP to intercept requests
    and responses from the server to your browser.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this recipe, you will utilize the search blog feature, which has a vulnerability
    to DOM-based XSS. The attack will make use of an **innerHTML** assignment that
    modifies a **div** element’s HTML contents using information from **location.search**.
    The result will be performing a cross-site scripting attack that calls the **alert**
    function to finish the lab.
  prefs: []
  type: TYPE_NORMAL
- en: 'Perform the following steps to get started:'
  prefs: []
  type: TYPE_NORMAL
- en: Navigate to the URL with the browser proxied to ZAP and log into the PortSwigger
    Academy website to launch the lab ([https://portswigger.net/web-security/cross-site-scripting/dom-based/lab-innerhtml-sink](https://portswigger.net/web-security/cross-site-scripting/dom-based/lab-innerhtml-sink)).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Within the lab application, type the following HTML payload into the **Search**
    field:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Once you click **Search**, the payload will execute, as shown in *Figure 9**.8*,
    completing the lab:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 9.8 – The alert payload](image/Figure_9.8_B18829.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.8 – The alert payload
  prefs: []
  type: TYPE_NORMAL
- en: Once successful you’ll see the alert payload and the PortSwigger Academy labs
    should congratulate you. Well done!
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This works because the **src** attribute’s value (**1**) is incorrect, thus
    throwing an error. But because of the error, the **alert()** function in the payload
    is called once the **onerror** event handler is activated. The following result
    occurs whenever the client attempts to load the web page that contains the malicious
    post request that executes the payload.
  prefs: []
  type: TYPE_NORMAL
- en: When the output is not properly encoded and user input is not properly sanitized,
    this opens up the application to injection vulnerabilities, where an attacker
    is able to craft a malicious HTML page to a target that processes it. The victim’s
    browser will then parse and execute the entire crafted page since it will be unable
    to understand legitimate code, the good parts of the page, from the malicious
    HTML code.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'HTML injection works similarly to JavaScript execution as they both involve
    injecting malicious code into a web application and getting the browser to execute
    the code. HTML injection is the practice of injecting HTML code into a website,
    usually via changing input fields or URL parameters. The browser then renders
    the injected code, which may alter the website’s structure and design. Alternatively,
    JavaScript injection entails inserting JavaScript code. There are several ways
    an attacker can perform HTML injection, as seen here:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Stealing user data**: When a web page loads, an attacker might inject JavaScript
    code to steal user information, such as login credentials. For instance, the attacker
    may insert code that generates a hidden form on the website and automatically
    populates it onto a server under their control, allowing them to receive the user’s
    information. For example, this could look like the following code:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '**Redirecting users**: An attacker could inject JavaScript code into a web
    page that redirects users to a malicious website. For example, the attacker could
    inject code that changes the value of the **location** property in the browser,
    causing the user to be redirected to a phishing site that mimics a proper site:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '**Phishing**: An attacker may inject JavaScript code into a web page to direct
    users to a malicious website. For instance, the attacker may include code that
    alters the location field’s value and directs the visitor to a phishing web page
    that perfectly resembles a legitimate website:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE28]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '**SQL injection**: An attacker could insert SQL queries into a web application,
    which could give them unauthorized access to the database and allow them to extract,
    change, or remove data. For instance, the attacker may insert code that returns
    all the information from the **users** table, such as **UNION SELECT *** **FROM
    users"**:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE30]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE31]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE32]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Testing for client-side URL redirect
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: URL redirect attacks (open redirection) occur when applications allow untrusted
    user input where an attacker serves a user a hyperlink. This hyperlink then sends
    them to an external URL that’s different from the intended web page the user was
    attempting to access. In layman’s terms, it’s when an attacker sends a user from
    the current page to a new URL.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This lab requires a PortSwigger Academy account and ZAP to intercept requests
    and responses from the server to your browser.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this recipe, the lab uses **open authorization** (**OAuth**) services to
    authenticate the fake social media account. You, the attacker, will exploit a
    misconfiguration in OAuth to steal authorization tokens linked to another user’s
    account to gain access and remove a user, Carlos:'
  prefs: []
  type: TYPE_NORMAL
- en: Navigate to the URL with the browser proxied to ZAP and log into the PortSwigger
    Academy website to launch the lab ([https://portswigger.net/web-security/oauth/lab-oauth-account-hijacking-via-redirect-uri](https://portswigger.net/web-security/oauth/lab-oauth-account-hijacking-via-redirect-uri)).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'First, ensure you are capturing requests in ZAP. Then click on **My account**
    and use the credentials provided to log in via OAuth. A message on the web page
    will indicate that you are being redirected. In addition, in the URL, you will
    see that you are using OAuth (shown in *Figure 9**.9*):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 9.9 – The OAuth URL](image/Figure_9.9_B18829.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.9 – The OAuth URL
  prefs: []
  type: TYPE_NORMAL
- en: Log out by clicking **My Account** and then log back in again.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You’ll notice you are logged in immediately. This is because there is still
    an active session with the OAuth service; therefore, you don’t need to provide
    a username and password to re-authenticate.
  prefs: []
  type: TYPE_NORMAL
- en: 'In ZAP, look in the **History** tab, where the most recent OAuth request can
    be found. Begin by typing **GET /auth?client_id=[...]**. You are immediately redirected
    to **redirect_uri** after this request has been sent together with the authorization
    code in the request message (see *Figure 9**.10*):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 9.10 – Authorization request](image/Figure_9.10_B18829.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.10 – Authorization request
  prefs: []
  type: TYPE_NORMAL
- en: Right-click and open this **/auth?client_id=** request in **Manual** **Request
    Editor**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In this request (see *Figure 9**.11*), you can send any random value as the
    **redirect_uri** without causing errors. This is the parameter that you’ll use
    to create the malicious redirect URL:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 9.11 – The redirect_uri manipulation](image/Figure_9.11_B18829.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.11 – The redirect_uri manipulation
  prefs: []
  type: TYPE_NORMAL
- en: Next, input the exploit server **Uniform Resource Identifier** (**URI**) as
    **redirect_uri**. Then right-click and copy the request URL. Enter this URL into
    the browser address bar, and press enter to send the request. You’ll see the web
    page open with the default message that was in the body on the exploit server
    page; *Hello world!*.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Look back inside the exploit server’s access log, and you’ll see that there’s
    a log entry with your authorization code. This lets you know that the authorization
    code is leaking to an external domain (see *Figure 9**.12*):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 9.12 – The exploit server access log with the authorization code](image/Figure_9.12_B18829.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.12 – The exploit server access log with the authorization code
  prefs: []
  type: TYPE_NORMAL
- en: 'Now hold on to that same URL but go back to the main exploit server page and
    paste this into an iframe (see the following code snippet) of the body: **OAUTH-ID**,
    **CLIENT-ID** (the OAuth ID from when you first logged in), and **EXPLOIT-ID**
    (the ID of the exploit server) are correct:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Next, click **Store** at the bottom to upload the exploit. Once this is done,
    *do not* click **View exploit** but copy the entire URL from **src" "**, open
    a new browser tab, paste the URL into the address bar, and navigate to it. Again,
    as before, this will open an iframe that shows the exploit server web page inside.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Close the browser tab and go back to the exploit server and check the **Access
    log**. You’ll see the log shows a **GET /?code=** request with a newly generated
    code, as seen in *Figure 9**.13*. This is your code but it will allow you to understand
    whether the exploit is working:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 9.13 – The access logs of the iframe payload](image/Figure_9.13_B18829.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.13 – The access logs of the iframe payload
  prefs: []
  type: TYPE_NORMAL
- en: 'Deliver the same exploit to the victim, then go back to the **Access Log**
    and look for a newly generated code from a different IP address. Copy the victim’s
    code from the result in the log:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: If there’s a dash (**-**) at the end of the code string, be sure to copy this
    dash along with the entire code.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.14 – The victim payload response](image/Figure_9.14_B18829.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.14 – The victim payload response
  prefs: []
  type: TYPE_NORMAL
- en: '*Log out* of the entire website first and with the new captured code, craft
    a new **oauth-callback** URL and paste it into the address bar of the browser
    and navigate to it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: OAuth will auto-complete authentication and log you in as the administrator.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Go to the **Admin** panel.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Delete Carlos.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The OAuth 2.0 framework is a very common tool used for authentication, yet it
    is common for vulnerabilities to occur due to misconfigurations. One essential
    component of the OAuth flow is redirect URLs. The authorization server will direct
    the user back to the application once the user has successfully authorized a certain
    application. It is essential that the service does not reroute the customer to
    random places since the redirect URL includes crucial information.
  prefs: []
  type: TYPE_NORMAL
- en: OAuth providers are a prime target for phishing attacks since they fail to validate
    **redirect_uri** when delivering the **access_token** through the browser redirect.
  prefs: []
  type: TYPE_NORMAL
- en: In this attack, the threat actor provides the target with a URL to a trusted
    authentication portal, and by using this authentication portal, the malicious
    user can send the victim’s secret **access_token** to their controlled web server,
    which allows the attacker access to unintended resources.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Users can offer access to their resources (i.e., data or an API) to a third-party
    application using the OAuth protocol without disclosing their login information.
    The following three key elements generally make up the OAuth authentication process:'
  prefs: []
  type: TYPE_NORMAL
- en: '**The client application**: This is a third-party program that seeks to gain
    access to the user’s resources. It must be registered with the OAuth provider
    and be equipped with a client ID and secret.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**The authorization server**: This is the server responsible for managing the
    user’s resources and authenticating the user. It is normally managed by the OAuth
    provider (such as Google, Facebook, Twitter, Linkedin, Windows Live, etc.) and
    is in charge of providing client application access.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**The resource owner**: This is the user who has access to the resources that
    the client application wishes to use. The resource owner must provide the client
    application access to their resources.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The client application redirects the user to the authorization server’s login
    page during the OAuth authentication procedure. After that, the user inputs their
    login information and gives access to the client application. The authorization
    server then refers the user back to the client application, providing the client
    with an access token to access the user’s resources.
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: Additional components, such as the resource server, which stores the user’s
    resources, and the token endpoint, which gives the access token, may be included
    in some implementations of OAuth.
  prefs: []
  type: TYPE_NORMAL
- en: After a user grants access to a client application, an attacker can send them
    to a malicious website using an *OAuth redirection attack* (also called an *open
    redirection attack*). This can be accomplished by fooling the user into clicking
    on a link containing a malicious redirect URI or changing the redirect URI that
    the client application uses. The attacker can take the access token and use it
    to access the user’s resources once the user has been forcibly redirected to the
    malicious website.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is a simplified example of an attacker’s URL string that could be used
    to execute this type of attack:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: The redirect URI of the client application, the authorization endpoint of the
    legal OAuth provider, and a **query** parameter pointing to the attacker’s website
    are all included in this example’s URL string. The attacker’s website will serve
    as the redirect URI when the victim clicks the link, which causes their browser
    to submit a request with this URL string to the authentic OAuth provider’s website.
  prefs: []
  type: TYPE_NORMAL
- en: Testing cross-origin resource sharing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To understand **cross-origin resource sharing** (**CORS**) vulnerability, first,
    you have to understand the same-origin policy. The same-origin policy was created
    to restrict the ability of websites to access resources that are not from the
    source domain. Although for some websites the same-origin policy is a problem,
    many websites nowadays interact with subdomains or third-party websites that need
    cross-origin exceptions. CORS was created to resolve this issue.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This lab requires a PortSwigger Academy account and ZAP to intercept requests
    and responses from the server to your browser. The login credentials for the lab
    web application are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Username**: **wiener**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Password**: **peter**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this recipe, the lab introduces a vulnerable website with an insecure CORS
    configuration to trust all origins. To solve this, we’ll form a malicious JavaScript
    function using CORS to retrieve an administrator’s API key and then upload the
    code to the server.
  prefs: []
  type: TYPE_NORMAL
- en: 'Take the following steps to get started:'
  prefs: []
  type: TYPE_NORMAL
- en: Navigate to the URL with the browser proxied to ZAP and log into the PortSwigger
    Academy website to launch the lab
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: ([https://portswigger.net/web-security/cors/lab-basic-origin-reflection-attack](https://portswigger.net/web-security/cors/lab-basic-origin-reflection-attack)).
  prefs: []
  type: TYPE_NORMAL
- en: Fire up ZAP and ensure you use either the manual explorer and launch the Firefox
    browser or have a browser extension tool enabled for proxying the page.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Once the lab loads and you reach the homepage of the application, click **My
    Account**. Use the credentials provided to log in and access the **Account** page.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Review the history and look at the response header (see *Figure 9**.15*), which
    will have your key that was retrieved by an AJAX request to **/accountDetails**.
    Within the same response, you will see the **Access-Control-Allow-Credentials**
    header. This lets us know it may be CORS:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 9.15 – The API key response header](image/Figure_9.15_B18829.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.15 – The API key response header
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, right-click the request and open it in **Manual Request Editor**. Then
    resubmit the request with the added header (see *Figure 9**.16*):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Here, we see the **origin** header where we inputted our domain reflected back
    to us:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.16 – Added origin header](image/Figure_9.16_B18829.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.16 – Added origin header
  prefs: []
  type: TYPE_NORMAL
- en: 'You’ll see that the URL we entered as **origin** is reflected back in the **Access-Control-Allow-Origin**
    header:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 9.17 – The response header showing origin](image/Figure_9.17_B18829.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.17 – The response header showing origin
  prefs: []
  type: TYPE_NORMAL
- en: 'In the lab at the top of the browser, click **Go to exploit server** and enter
    the following payload HTML script. Be sure to replace **<random-string>** with
    your unique lab URL that generates when you first start the lab:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE38]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE39]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE40]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE41]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE42]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE43]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE44]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE45]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE46]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In *Figure 9**.18*, we see the lab header, which shows the **Go to exploit
    server** button and the **Submit solution** button to solve the lab:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.18 – Link to the exploit server](image/Figure_9.18_B18829.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.18 – Link to the exploit server
  prefs: []
  type: TYPE_NORMAL
- en: 'Click **View exploit** at the bottom of the page. This will help ensure that
    the exploit works and that you have landed on the log page with your API key in
    the URL, as shown in *Figure 9**.20*:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 9.19 – View exploit logs](image/Figure_9.19_B18829.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.19 – View exploit logs
  prefs: []
  type: TYPE_NORMAL
- en: 'Go back to the exploit server and first click **Store**, then click **Deliver
    exploit to victim** to send the exploit:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 9.20 – The Deliver exploit to victim button](image/Figure_9.20_B18829.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.20 – The Deliver exploit to victim button
  prefs: []
  type: TYPE_NORMAL
- en: 'After sending the exploit, click **Access log** to retrieve the administrator’s
    API key from the **/log?key=** log entry. For an easier way of searching, look
    at the IP address in the left column:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 9.21 – The Admin’s API key](image/Figure_9.21_B18829.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.21 – The Admin’s API key
  prefs: []
  type: TYPE_NORMAL
- en: To complete, use the **Submit solution** button that’s at the top of the lab
    web page. It can be seen from either the main lab page or when osn the exploit
    server page.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'CORS allows websites to request resources from other websites by utilizing
    HTTP headers to set the allowed origins. The headers used by CORS are **Access-Control-Allow-Origin**
    and **Access-Control-Allow-Credentials**. **Access-Control-Allow-Origin** has
    three values, which are: a wild card **(*)** that allows all origins, **<origin>**
    that specifies only one origin, and **null**, which is used for multiple reasons,
    some of them are when the website is receiving cross-origin redirects or using
    **file: protocol**. The **Access-Control-Allow-Credentials** header only takes
    a **true** value and is used to send authentication information.'
  prefs: []
  type: TYPE_NORMAL
- en: This vulnerability arises as a result of misconfiguration. Misconfiguration
    could be but is not limited to, allowing all origins or accepting all origins
    ending in a specific string, such as **zapproxy.com**. An attacker could register
    **attackersitezapproxy.com**, and this origin will be accepted.
  prefs: []
  type: TYPE_NORMAL
- en: The impact of CORS vulnerabilities depends on which header is set and the information
    that the website provides. If the **Access-Control-Allow-Credentials** is set
    to **true**, an attacker could extract authentication information from the website.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'CORS attacks can be used with other forms of attacks to exploit additional
    vulnerabilities in a targeted server. Here are some types of attacks that may
    be combined with CORS:'
  prefs: []
  type: TYPE_NORMAL
- en: '**XSS**: A CORS attack can be used by an attacker to circumvent the same-origin
    policy and inject malicious code into a website, allowing them to steal sensitive
    information from website visitors'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**CSRF**: An attacker can employ a CORS attack to fool a server into believing
    that a request is coming from a trustworthy source, allowing them to undertake
    activities on behalf of a genuine user'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Phishing**: An attacker can use a CORS attack to generate a bogus login page
    on a malicious website and then use the CORS attack to access the user’s personal
    information after their credentials are entered'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An attacker often initiates these sorts of attacks by modifying the request
    headers to fool the server into thinking the request is coming from a trustworthy
    origin, generating phony login pages, or injecting malicious code. The attacker
    must also be able to steal the authentication tokens or obtain the sensitive data
    that is being exposed.
  prefs: []
  type: TYPE_NORMAL
- en: Testing WebSockets
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: WebSockets are an ongoing, two-way channel of communication between a client
    and backend service, such as a database or an API service. WebSockets may transmit
    any number of protocols and offer server-to-client message delivery without polling
    (the process of one program or device repeatedly checking the status of other
    programs or devices).
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This lab requires a PortSwigger Academy account and ZAP to intercept requests
    and responses from the server to your browser.
  prefs: []
  type: TYPE_NORMAL
- en: Before starting the lab, within ZAP, go to **Tools**, **Options**, and scroll
    down to the **WebSockets** section. Here you must enable **Break on enabled ‘all
    request/response break buttons’**. Otherwise, you will not be able to capture
    the WebSocket request and manipulate it to complete this lab.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: WebSockets are being used to implement the live chat feature in this online
    store.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, a fictitious support representative, aka a bot, will read the
    chat message requests you send. While interpreting the responses, we’ll use a
    WebSocket message to create an **alert()** popup on the support agent’s browser.
    If successful, it will automatically complete the lab.
  prefs: []
  type: TYPE_NORMAL
- en: 'Take the following steps to get started:'
  prefs: []
  type: TYPE_NORMAL
- en: Navigate to the URL with the browser proxied to ZAP and log into the PortSwigger
    Academy website to launch the lab ([https://portswigger.net/web-security/websockets/lab-manipulating-messages-to-exploit-vulnerabilities](https://portswigger.net/web-security/websockets/lab-manipulating-messages-to-exploit-vulnerabilities)).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Within ZAP, enter the scoped URL into the manual explorer and launch the browser
    to open up Firefox. Click **Continue to** **your target**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the upper right-hand corner of the web application, click **Live chat** and
    send a random chat message.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Go to the WebSockets **History** tab in ZAP, and look for the chat message
    that you previously sent in the original WebSocket message (see *Figure 9**.22*):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 9.22 – The WebSockets History tab](image/Figure_9.22_B18829.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.22 – The WebSockets History tab
  prefs: []
  type: TYPE_NORMAL
- en: 'Back within the application, send another new message, but this time containing
    a less-than character:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Look back in the ZAP WebSocket history to find the corresponding WebSocket
    message and observe that the less-than symbol has been converted to HTML-encoded
    by the client before sending, as in *Figure 9**.23*:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 9.23 – HTML-encoded less-than character](image/Figure_9.23_B18829.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.23 – HTML-encoded less-than character
  prefs: []
  type: TYPE_NORMAL
- en: 'Again, send another chat message, but this time set a breakpoint, and while
    your message is in transit, manipulate the request to contain the following payload:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: If the **Live Chat** feature of the web application stops working or the chat
    says **Disconnected**, open a new **Live Chat** to continue the recipe.
  prefs: []
  type: TYPE_NORMAL
- en: 'The browser will trigger an alert, which will also happen on the support agent’s
    client side:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 9.24 – A JavaScript alert](image/Figure_9.24_B18829.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.24 – A JavaScript alert
  prefs: []
  type: TYPE_NORMAL
- en: 'In the first screenshot, you see the alert box pop up on the client side. Over
    in the chat message in *Figure 9**.25*, you see a blank HTML icon for the image
    tag. This is our malicious payload:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.25 – A successful attack shown in a chat](image/Figure_9.25_B18829.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.25 – A successful attack shown in a chat
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: According to RFC 6455, the WebSocket Protocol enables two-way communication
    between a client running erroneous code in an organized element and a remote host
    that has granted permission for communications from that code. This uses the origin-based
    security concept, widely utilized by online browsers. The protocol starts with
    a handshake and then layers the **Transmission Control Protocol** (**TCP**) with
    some simple message framing. This technology’s objective is to give browser-based
    applications that require two-way communication with servers a method of doing
    so without having to initiate several HTTP connections (that is, by utilizing
    **XMLHttpRequest** or **<iframe>s** and lengthy polling).
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: Some assaults may result in the loss of your connection, in which case you must
    create a new one.
  prefs: []
  type: TYPE_NORMAL
- en: 'Practically any web security flaw may occur in regard to WebSockets:'
  prefs: []
  type: TYPE_NORMAL
- en: Improper handling of user input when transferred to the server creates flaws
    such as SQL injection or **XML external entity** (**XXE**) injection
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Blind WebSocket vulnerabilities may need to be exploited through out-of-band
    (OAST) methods
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: XSS or other client-side vulnerabilities may result if attacker-controlled data
    is sent over WebSockets to other application users
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When initializing your methodology before attacking a WebSocket, look at the
    JavaScript files or the page’s source code to discover the WebSocket endpoints.
    Look for the following in the JavaScript code:'
  prefs: []
  type: TYPE_NORMAL
- en: '**wss://**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**ws://**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**websocket**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A WebSocket URL will be formatted as **wss://example.com** (**wss://** for a
    **secure socket layer** (**SSL**) connection). Similar to **https://**, and **ws://**,
    which is like **http://**.
  prefs: []
  type: TYPE_NORMAL
- en: Next, to determine whether the WebSocket endpoint is accepting connections from
    other origins within ZAP, examine the connections. Send a request from the **Manual
    Request Editor** with your origin specified in the **origin** header value. If
    the connection is successful, the server will reply with a status code **101**,
    and your requested origin will be mirrored *or* notated with a wildcard (*****)
    in the **origin** header of the response.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*RFC6455: The WebSocket* *Protocol*: [https://www.rfc-editor.org/rfc/rfc6455](https://www.rfc-editor.org/rfc/rfc6455)'
  prefs: []
  type: TYPE_NORMAL
