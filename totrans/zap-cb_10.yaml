- en: '10'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Advanced Attack Techniques
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Welcome to [*Chapter 10*](B18829_10.xhtml#_idTextAnchor362), *Advanced Attack
    Techniques*. In this chapter, we will cover some advanced attacks, such as **XML
    external entity** (**XXE**) attacks and Java deserialization, where we will explain
    and demonstrate exploiting these vulnerabilities on the testing applications.
    We will also have fun brute-forcing the password change on one of the applications,
    conducting web cache poisoning, and working with JSON Web Tokens.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following recipes:'
  prefs: []
  type: TYPE_NORMAL
- en: Performing XXE attacks
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working with JSON Web Tokens
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Performing Java deserialization attacks
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Password brute-force via password change
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Web cache poisoning
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For this chapter, you need to utilize a common browser such as Mozilla Firefox.
    You will also utilize your PortSwigger account for access to the PortSwigger Academy
    labs that will be used in this chapter’s recipes.
  prefs: []
  type: TYPE_NORMAL
- en: Performing XXE attacks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In an XXE attack, the attacker sends XML input that includes a reference to
    an external entity to an application. The XML input causes the application to
    behave in a manner that it was not intended to. Successful exploitation of an
    XXE attack can lead to an attacker viewing the content of files, exfiltrating
    data, **server-side request forgery** (**SSRF**), and remote code executions.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This lab requires a PortSwigger Academy account and ZAP to be able to intercept
    requests and responses from the server to your browser.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this lab, we will walk through performing an XXE attack to retrieve the
    contents of the **passwd** file. Please follow these instructions:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Navigate to the URL with the browser proxied to ZAP and log into the PortSwigger
    Academy website to launch the lab. The lab we will work on in this section is
    *Exploiting XXE Using External Entities to Retrieve Files*. The link to the lab
    is accessed here: [https://portswigger.net/web-security/xxe/lab-exploiting-xxe-to-retrieve-files](https://portswigger.net/web-security/xxe/lab-exploiting-xxe-to-retrieve-files).'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Start the lab, add it to the context, and click on **Show only URLs** **in Scope**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: On the lab home page, click on **View details** under any product. Then click
    on **Check stock**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Clicking on **Check stock** sends a **POST** request to the application. Let’s
    find the **POST** request. Right-click the request and select **Open/Resend with**
    **Request Editor**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Once the **Request Editor** window opens, add the following payload after the
    XML declaration and replace the product ID with the **xxe** external entity reference,
    as shown in *Figure 10**.1*. Then, click **Send**:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '![Figure 10.1 – XXE attack](image/Figure_10.1_B18829.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.1 – XXE attack
  prefs: []
  type: TYPE_NORMAL
- en: 'As you can see in the **Response** tab, the content of the **passwd** file
    is listed in the returned response, as shown in *Figure 10**.2*:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 10.2 – The passwd file](image/Figure_10.2_B18829.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.2 – The passwd file
  prefs: []
  type: TYPE_NORMAL
- en: This concludes this lab.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: An XXE attack is a type of vulnerability that can be found in applications that
    process XML input. This type of attack occurs when an attacker is able to inject
    malicious external entities into an XML document, which can then be used to compromise
    the security of the application or the underlying system.
  prefs: []
  type: TYPE_NORMAL
- en: In an XXE attack, the attacker first creates an XML document containing a reference
    to an external entity, typically a remote file or resource. The attacker then
    submits this malicious XML document to the vulnerable application, which attempts
    to process it and access the external entity. This can cause the application to
    either crash or disclose sensitive information, such as internal network addresses
    or system files.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we viewed the content of the **/etc/passwd** file by performing
    an XXE injection attack. And to perform the XXE injection attack, we changed the
    XML input by adding the **DOCTYPE** element to add the external entity that includes
    the **passwd** file path. Then the external entity was used in the **productId**
    value, which caused the application to return the **passwd** file content in the
    response, which enabled us to gather more information about the accounts in the
    system.
  prefs: []
  type: TYPE_NORMAL
- en: Working with JSON Web Tokens
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**JSON Web Tokens** (**JWTs**) are used for authentication, session handling,
    and authorization of data between systems. JWT vulnerabilities are usually design
    flaws, misconfigurations, or the use of insecure libraries. When testing for JWT
    flaws, the tester attempts to bypass the signature verification process, which
    bypasses the authentication or authorization mechanism. The information sent in
    the JWTs are called claims and are cryptographically signed JSON objects. Each
    JWT is made out of three sections; the first is a header, the second is the payload,
    and the third is a signature. Each section is divided by a **.** (dot) and encoded
    using **base64** encoding. The header contains information about the token, the
    payload section includes the claims, and the signature is usually a hashed value
    of the header and the payload section combined and used for integrity checks.'
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, you will attack a misconfigured server that issues JWTs to accept
    unsigned tokens. To finish the lab, we will walk you through deactivating the
    user – Carlos – and change the session token so that you can access the admin
    panel.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This lab requires a PortSwigger Academy account, a **Base64** encoder/decoder,
    and ZAP should be able to intercept requests and responses from the server to
    your browser.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this section, we will complete the PortSwigger Academy’s *JWT authentication
    bypass via flawed signature verification* lab to demonstrate how to change the
    values in the JWT payload to log in as the administrator and delete a user account.
    Take the following steps to start the lab:'
  prefs: []
  type: TYPE_NORMAL
- en: Navigate to the URL with the browser proxied to ZAP and log into the PortSwigger
    Academy website to launch the *JWT authentication bypass via flawed signature
    verification* lab ([https://portswigger.net/web-security/jwt/lab-jwt-authentication-bypass-via-flawed-signature-verification](https://portswigger.net/web-security/jwt/lab-jwt-authentication-bypass-via-flawed-signature-verification)).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Once you access the lab, click on **My account** and log in with the credentials
    provided in the lab description.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open ZAP and find the **GET** request to **/my-account page**. Right-click the
    request and select **Open/Resend with** **Request Editor…**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'You can see in the request that the cookie session is a JWT, as it is separated
    by a dot. The goal in this lab is to access the admin portal by manipulating the
    JWT cookie. We will need a **Base64** encoder/decoder; in this lab, I am using
    CyberChef ([https://gchq.github.io/CyberChef](https://gchq.github.io/CyberChef)).
    Copy the header from the token, which is the first part before the dot and after
    **session=**. Open your favorite Base64 decoder and encode the header. Change
    the **alg** value from **RS256** to **none** and encode it again, as seen in *Figure
    10**.3*. Copy the encoded value and save it so we can use it later in the lab:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 10.3 – The none algorithm](image/Figure_10.3_B18829.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.3 – The none algorithm
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, copy the payload from the JWT; it is the second part located between two
    dots in the token. Decode it in a Base64 decoder, and change the **sub** value
    from the username you used to **administrator**, as seen in *Figure 10**.4*. Encode
    the payload and copy and save the encoded payload to be used in the next step:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 10.4 – Changing the user account](image/Figure_10.4_B18829.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.4 – Changing the user account
  prefs: []
  type: TYPE_NORMAL
- en: 'In the **Request Editor** in ZAP, change **/my-account** to **/admin**. Delete
    everything after **session=**, and add the encoded header value we created earlier.
    Add a dot, then add the encoded payload value we created earlier. Add a dot after
    the payload. *Figure 10**.5* shows the values added:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 10.5 – Session cookie](image/Figure_10.5_B18829.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.5 – Session cookie
  prefs: []
  type: TYPE_NORMAL
- en: Click on **Send**; as you can see in the **Response** tab, the application responded
    with the Admin Panel code.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open your browser, and go to the **/admin** page, as you can see, you can’t
    view the Admin page. To view the Admin page, we will have to change the cookie
    value. I am using Chrome to change the cookie value. I have to open **Developer
    Tools**, navigate to the **Application** tab, and find the cookie under **Cookies**.
    In the **Value** column, I double-clicked the value and pasted the JWT we created.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: After adding the JWT we created, refresh the page. As you can see, we can view
    the admin page, as shown in *Figure 10**.6*. Let’s delete the user **carlos**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 10.6 – The Users page](image/Figure_10.6_B18829.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.6 – The Users page
  prefs: []
  type: TYPE_NORMAL
- en: This concludes the lab for this recipe. We have bypassed the authentication
    and authorization mechanism to view the admin page.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this lab, we decoded the header of the token and changed the value of the
    **alg** attribute to **none**. By changing the **alg** attribute to **none**,
    we can bypass the verification of the signature in the token. Then, we decoded
    the payload and changed the value of the **sub** attribute to **administrator**
    to be able to use the administrator account. After that, we encoded the header
    and the payload and used them as our session cookie value. By doing that, we were
    able to bypass the authentication and authorization mechanism of the website.
  prefs: []
  type: TYPE_NORMAL
- en: There’s more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Using the **none** value for the **alg** attribute is not the only way to make
    the application server accept the JWT you create. Another method to bypass authentication
    and authorization is to find or brute force the secret key. **HS256** is another
    **alg** value that uses a secret key. If an attacker finds the secret key, they
    could sign any JWT they create and pass it to the server. Tools such as Hashcat
    can brute force the secret key using a wordlist.
  prefs: []
  type: TYPE_NORMAL
- en: Performing Java deserialization attacks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Java employs a process called **serialization** that turns an object into a
    byte stream. On the flip side, **deserialization** is the process of returning
    a serialized stream of bytes to an object in the machine’s memory. In this type
    of attack, the attacker introduces malicious data into the application code by
    modifying serialized objects. This attack is only possible if the website deserializes
    data provided by the user. If user-provided data or any data from sources you
    don’t trust must be deserialized, checks and safeguards must be implemented to
    prevent the untrusted sources from altering the data. Checks and safeguards must
    be done before the start of the deserialization process; otherwise, it will not
    be effective. Due to the difficulties in preventing deserialization attacks, data
    deserialization should only be used if it can’t be avoided.
  prefs: []
  type: TYPE_NORMAL
- en: Within this recipe, you will attack a susceptible serialization-based session
    mechanism that’s vulnerable to privilege escalation. To conduct this attack, you
    will edit the serialized object in the session cookie to take advantage of this
    flaw and gain administrator rights to remove Carlos’ account.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This lab requires a PortSwigger Academy account and ZAP to intercept requests
    and responses from the server to your browser.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The following steps walk you through solving the PortSwigger Academy *Modifying
    serialized objects* lab. In this lab, you will modify the session cookie’s serialized
    object to escalate your account privileges and be able to delete a user account.
    Please follow these instructions:'
  prefs: []
  type: TYPE_NORMAL
- en: Navigate to the URL with the browser proxied to ZAP and log into the PortSwigger
    Academy website to launch the lab ([https://portswigger.net/web-security/deserialization/exploiting/lab-deserialization-modifying-serialized-objects](https://portswigger.net/web-security/deserialization/exploiting/lab-deserialization-modifying-serialized-objects)).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open ZAP and go to **Manual Explorer**. Enter the lab URL in the Firefox launcher.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Log in to the lab application using the credentials provided by PortSwigger.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click the response after the login **GET /my-account** request, which contains
    a session cookie. This cookie appears to be URL and Base64-encoded.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'To understand what data is in this string, send it over to the **Encode/Decode/Hash**
    tool by right-clicking the selected cookie value. Click the **Decode** tab and
    look at the **Base64 Decode** row. You’ll see the following values:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The cookie is actually a serialized PHP object. String values are always contained
    within double quotes. **s** is the size of the object followed by the object name
    in double quotes. At the end of the code string, the admin attribute contains
    **b:0**, indicating a Boolean value of **false**. Open this request in **Manual**
    **Request Editor**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In its decoded form, open CyberChef to change the value of **b:0** to **b:1**
    to equal **true** and re-encode in base64 as well as URL encoded **=**. Insert
    this encoded string back into the cookie and send the request. See *Figure 10**.7*:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 10.7 – CyberChef encoded session data](image/Figure_10.7_B18829.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.7 – CyberChef encoded session data
  prefs: []
  type: TYPE_NORMAL
- en: 'When you receive the response, scroll through the content of the HTML code,
    as shown in *Figure 10**.8*, to find a link that shows **/admin**. This shows
    that you accessed a page with admin privileges:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 10.8 – Response with the /admin path](image/Figure_10.8_B18829.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.8 – Response with the /admin path
  prefs: []
  type: TYPE_NORMAL
- en: 'In our next step, go back to the **Request** tab and update the **GET** request
    path to **/admin,** and hit **Send** again. You’ll receive a **200** HTTP status
    and then see a specific **href** to delete user accounts:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 10.9 – /admin response](image/Figure_10.9_B18829.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.9 – /admin response
  prefs: []
  type: TYPE_NORMAL
- en: Update the path to include **/admin/delete?username=carlos** and send the request
    once more to complete this recipe. You may need to refresh the browser page to
    see the completion status of the lab.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When using Java to build objects and these objects are no longer in use, they
    get saved in memory to be later deleted by the garbage collector. Java must convert
    these objects into a byte stream before transferring that data, storing it on
    a disk, or transmitting it over a network. The class of that object must implement
    the Serializable interface in order to do this. As was already said, serialization
    enables us to transform an object’s state into a stream of bytes. The actual code
    is not included in this byte stream.
  prefs: []
  type: TYPE_NORMAL
- en: A malicious user trying to introduce a changed serialized object into the system
    to compromise the system or its data results in a Java deserialization vulnerability.
  prefs: []
  type: TYPE_NORMAL
- en: There’s more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Java applications automatically manage their memory using a process known as
    **garbage collection**. Java applications can be executed on a **Java virtual
    machine** (**JVM**) by compiling to bytecode. Objects are produced on the heap,
    a section of memory reserved for the application when Java programs are launched
    on the JVM. Some objects will eventually become obsolete. To free up memory, the
    garbage collector discovers these useless objects and deletes them.
  prefs: []
  type: TYPE_NORMAL
- en: As for the Serializable interface, this is contained within the **java.io**
    package. It is a marker interface that contains no methods or fields. Therefore,
    classes that incorporate it don’t need to define any methods. If classes wish
    to be able to serialize or deserialize their instances, they must implement it.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For more information on PHP serialization, visit [https://www.php.net/manual/en/function.serialize.php](https://www.php.net/manual/en/function.serialize.php).
  prefs: []
  type: TYPE_NORMAL
- en: For CyberChef, visit [https://gchq.github.io/CyberChef/](https://gchq.github.io/CyberChef/).
  prefs: []
  type: TYPE_NORMAL
- en: Password brute-force via password change
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A brute force attack is a cracking method that uses trial and error to compromise
    login information, encryption keys, and passwords. It is a simple yet effective
    method for gaining unauthorized access to user accounts, business systems, or
    networks. Until they discover the proper login details, a malicious user attempts
    a wide variety of usernames and password combinations to obtain the right authentication
    credentials.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we will attack a vulnerable password change function within
    the application using brute-force attacks.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This lab requires a PortSwigger Academy account and ZAP to intercept requests
    and responses from the server to your browser.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this recipe, we will demonstrate a brute-force attack by completing the
    PortSwigger Academy *Password brute-force via password change* lab to find the
    correct credentials. To start the lab, follow these instructions:'
  prefs: []
  type: TYPE_NORMAL
- en: Navigate to the URL with the browser proxied to ZAP and log into the PortSwigger
    Academy website to launch the lab ([https://portswigger.net/web-security/authentication/other-mechanisms/lab-password-brute-force-via-password-change](https://portswigger.net/web-security/authentication/other-mechanisms/lab-password-brute-force-via-password-change)).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Download the Authentication lab passwords provided by PortSwigger to a text
    file on your computer. You will be using these specifically for the recipe ([https://portswigger.net/web-security/authentication/auth-lab-passwords](https://portswigger.net/web-security/authentication/auth-lab-passwords)).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: With ZAP open, go to **Manual Explore**, open Firefox via the launcher, and
    resolve the PortSwigger lab URL. Continue to the PortSwigger Authentication lab.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: In ZAP, to view the request and response more easily, be sure to add the URL
    being tested to **Context** by right-clicking on the web URL in the **Sites**
    window and **Include Site in Context**, then click the bullseye to remove any
    other sites from view. This can be done in the **History** tab of the **Information**
    window and elsewhere that has a bullseye.
  prefs: []
  type: TYPE_NORMAL
- en: Log in to the lab application using the credentials provided and set the Breakpoint
    in the HUD.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Once logged in, you will be at the web page where you can update your current
    password. Here, we’ll begin to test its functionality. Keep in mind that the username
    is provided in the request as a hidden input.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We’ll mess around with this feature to enumerate correct passwords but first,
    let’s look at varying ways to gain different responses:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Enter an incorrect current password followed by two matching passwords. If
    you enter passwords like this twice, the account will log you out and lock. Then,
    when attempting to log back in, you’ll get an error of being locked out for one
    minute, as shown in *Figure 10**.10*:'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 10.10 – Locked account message](image/Figure_10.10_B18829.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.10 – Locked account message
  prefs: []
  type: TYPE_NORMAL
- en: But if you use an incorrect current password, but the new passwords do not match,
    you will not be logged out and locked out. A **Current password is incorrect**
    error will appear.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Lastly, if you use the correct, current password but you enter two different
    new passwords, you will get a **New passwords do not match** error message splashed
    on the web page.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the **History** tab, open the request where you entered the correct, current
    password and two different new passwords in **Fuzzer**, as shown in *Figure 10**.11*:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 10.11 – The POST request change password](image/Figure_10.11_B18829.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.11 – The POST request change password
  prefs: []
  type: TYPE_NORMAL
- en: Click on **Edit** to change the username parameter to **carlos**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, select **password** in the **current-password** parameter and click **Add**,
    **Add** again, and then drop down the menu to **File**. This will add our password
    list to use for brute-forcing. Ensure the other two new **password** parameters
    are different values, as shown in the previous example, *Figure 10**.11*.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the **File** payload, click on **Select...** to open your computer’s directory
    and navigate to where you saved the file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, add a second payload, **strings**, in an empty space in the body just
    after the second password. Add the **New passwords do not match** line, check
    the **Multiline** box, click **Add**, then **OK**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: Adding a Stings payload type helps you *grep match* on content in the body of
    the response.
  prefs: []
  type: TYPE_NORMAL
- en: 'Yours should have two payloads, as shown in *Figure 10**.12*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.12 – Fuzzer payloads](image/Figure_10.12_B18829.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.12 – Fuzzer payloads
  prefs: []
  type: TYPE_NORMAL
- en: Start Fuzzing.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The attack will run for a little and once it stops, look for a response that
    contains the word **Reflected** in the **Fuzzer** tab of the **Information** window.
    Sort the **State** column, as shown in *Figure 10**.13*. When scrolling through
    the payloads, look at the body of the response for **<p class=is-warning>New passwords
    do not match**. This payload will be your password:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 10.13 – Fuzzer history](image/Figure_10.13_B18829.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.13 – Fuzzer history
  prefs: []
  type: TYPE_NORMAL
- en: Go back to the application in the browser, log out of the current account you’re
    logged into, and then log back in using the **carlos** username and the newly
    found password.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Attackers look for areas within an application to forcefully attempt numerous
    usernames or passwords and conduct varying techniques to do so. The four most
    common are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Simple brute force attacks are where attackers attempt to guess a user’s login
    by manually typing them in one at a time.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A dictionary attack is a type of password guessing attack that inputs a list
    of potential passwords, consisting of swapping some of the letters with symbols
    or numbers and comparing it to a username of the target. Typically, this attack
    takes much longer to succeed and thus has a decreased likelihood of working.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A rainbow table attack comprises a database that is made up of passwords and
    their hash values, which are then compared against the target hash for a match.
    This takes less time to crack.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Hybrid attacks combine both dictionary and rainbow tables.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Many of these passwords and tables come from underground sources from previous
    breaches being sold or passed around the internet and help form more accurate
    attacks on networks.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Other sources to help build lists can be searched for via search engines for
    default credentials for the technology being used, or utilize one of these links:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Credentials:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/ihebski/DefaultCreds-cheat-sheet](https://github.com/ihebski/DefaultCreds-cheat-sheet)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[http://www.vulnerabilityassessment.co.uk/passwordsC.htm](http://www.vulnerabilityassessment.co.uk/passwordsC.htm)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://192-168-1-1ip.mobi/default-router-passwords-list/](https://192-168-1-1ip.mobi/default-router-passwords-list/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://datarecovery.com/rd/default-passwords/](https://datarecovery.com/rd/default-passwords/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://bizuns.com/default-passwords-list](https://bizuns.com/default-passwords-list)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://github.com/danielmiessler/SecLists/blob/master/Passwords/Default-Credentials/default-passwords.csv](https://github.com/danielmiessler/SecLists/blob/master/Passwords/Default-Credentials/default-passwords.csv)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://www.cirt.net/passwords](https://www.cirt.net/passwords)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://www.passwordsdatabase.com/](https://www.passwordsdatabase.com/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://many-passwords.github.io/](https://many-passwords.github.io/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Wordlists:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/Dormidera/WordList-Compendium](https://github.com/Dormidera/WordList-Compendium)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://github.com/danielmiessler/SecLists](https://github.com/danielmiessler/SecLists)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://github.com/kaonashi-passwords/Kaonashi](https://github.com/kaonashi-passwords/Kaonashi)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://crackstation.net/crackstation-wordlist-password-cracking-dictionary.htm](https://crackstation.net/crackstation-wordlist-password-cracking-dictionary.htm)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Web cache poisoning
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Web cache poisoning** is a sophisticated technique whereby an attacker manipulates
    a web server and its cache functionality to send other users a malicious HTTP
    response. In this recipe, we’ll exploit a vulnerable lab that does not properly
    validate input within an unkeyed header susceptible to web cache poisoning. This
    attack will take advantage of the web application’s home page, where unsuspecting
    visitors will be open to the attack. We’ll walk you through web cache poisoning
    in a response that causes the visitor’s browser to execute malicious JavaScript
    code.'
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This lab requires a PortSwigger Academy account and ZAP to intercept requests
    and responses from the server to your browser.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this section, we will lay out the steps you can take to complete the PortSwigger
    Academy *Web cache poisoning with an unkeyed header* lab and poison the cache
    to display the cookie. To start the lab, take the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Navigate to the URL with the browser proxied to ZAP and log into the PortSwigger
    Academy website to launch the lab:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Capture the website’s home page. To reiterate this response, refresh the web
    page or click the home page button.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Look for the **GET** request that is generated from the home page and open
    it in the **Manual Request Editor**, as shown in *Figure 10**.14*:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 10.14 – The GET request](image/Figure_10.14_B18829.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.14 – The GET request
  prefs: []
  type: TYPE_NORMAL
- en: Next, add a cache-buster query parameter after the URL (**/?cb=1337**).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A **cache-buster header** is a type of HTTP response header that is used to
    prevent web browsers from caching specific resources on a web page. This can be
    useful in situations where you want to ensure that users always see the latest
    version of a resource rather than a potentially outdated version that might have
    been stored in the browser’s cache. Cache-buster headers typically contain a unique
    identifier or timestamp that changes each time the resource is requested, which
    forces the browser to download the latest version of the resource rather than
    using a cached version. This can help to ensure that users always have access
    to the most up-to-date content on a website.
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: The process to locate vulnerable parameters to web cache poison can be automated
    using an extension called **Parameter Digger**. Refer to the *See also* section
    for reference.
  prefs: []
  type: TYPE_NORMAL
- en: In addition, add the **X-Forwarded-Host** header with any random hostname, as
    shown in *Figure 10**.15*, such as **zaproxy.org**, and click **Send**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 10.15 – Cache buster query and the X-Forwarded-Host header](image/Figure_10.15_B18829.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.15 – Cache buster query and the X-Forwarded-Host header
  prefs: []
  type: TYPE_NORMAL
- en: When the **X-Forwarded-Host** header is used, a dynamically generated reference
    is shown in the web app’s source code for importing a JavaScript file that’s stored
    at **/resources/js/tracking.js**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'All the details required to find a resource are in this absolute URL, as shown
    in *Figure 10**.16*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.16 – Dynamic URL in the web app source code](image/Figure_10.16_B18829.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.16 – Dynamic URL in the web app source code
  prefs: []
  type: TYPE_NORMAL
- en: 'In addition, when looking at the response, as in *Figure 10**.16*, the response
    contains the **X-Cache: hit** header. If you see the **X-Cache: miss** header,
    continue to click **Send** to get a hit:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 10.17 – The X-Cache: miss response](image/Figure_10.17_B18829.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10.17 – The X-Cache: miss response'
  prefs: []
  type: TYPE_NORMAL
- en: The **X-Cache** header is a type of HTTP response header that is used to indicate
    whether a resource was served from the cache of a web server or from the origin
    server itself. If the header contains the value **hit**, the resource was served
    from the cache, which can be faster and more efficient than serving the resource
    directly from the origin server. This can be useful for improving a website’s
    performance by reducing the amount of data that needs to be transferred between
    the server and the client.
  prefs: []
  type: TYPE_NORMAL
- en: 'With this information, click the link to go to the exploit server and update
    the filename to be the path to the JavaScript from the absolute URL:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, enter a JavaScript XSS payload into the body and click **Store** to save
    the exploit:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Again, open the **GET** request for the home page in **Manual Response Editor**
    and remove the cache buster parameter and then add the **X-Forwarded-Host** header
    that points to the exploit server (ensure to use your **EXPLOIT-SERVER-ID** that
    is provided in the URL on top of the exploit page):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '![Figure 10.18 – The GET request for web cache poisoning](image/Figure_10.18_B18829.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.18 – The GET request for web cache poisoning
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: When crafting the **GET** request, be sure to remove the cache-buster header,
    and when adding the exploit server URL, do not include **https://** or the trailing
    **/**.
  prefs: []
  type: TYPE_NORMAL
- en: 'Click **Send**, and continue sending the request until the exploit server URL
    is reflected in the response along with **X-Cache: hit** in the headers, as shown
    in *Figure 10**.19*:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 10.19 – A successful exploit request](image/Figure_10.19_B18829.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.19 – A successful exploit request
  prefs: []
  type: TYPE_NORMAL
- en: Once you have a hit, go to the web app in the browser and refresh the page.
    This will load the web cache poisoned URL into the browser that triggers the **alert()**
    JavaScript payload, as shown in *Figure 10**.20*.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: The web cache for this lab will expire every 30 seconds. It’s important to perform
    the test quickly.
  prefs: []
  type: TYPE_NORMAL
- en: 'You may need to continue sending the malicious **GET** request, followed by
    refreshing the web app browser page to get the web-poisoned page to load and execute
    the payload:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 10.20 – The XSS payload execution](image/Figure_10.20_B18829.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.20 – The XSS payload execution
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Web cache poisoning typically involves manipulating the HTTP headers of a request
    to a web server in such a way that the server will cache a malicious or false
    version of the response. For example, an attacker might send a request with a
    forged **Last-Modified** header that indicates that the response should be considered
    fresh and cached by the server, even if it contains malicious or false content.
    When subsequent requests are made to the same resource, the server will serve
    the poisoned response from its cache instead of requesting a fresh copy from the
    origin server.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Parameter Digger, a tool for finding parameters, is called the **Param Digger**.
    It reveals obscure, unconnected, and hidden characteristics that can help broaden
    the attack surface and make it simpler to uncover vulnerabilities. It employs
    brute-force guessing techniques to find parameters using a seed URL that has been
    provided here: [https://www.zaproxy.org/docs/desktop/addons/parameter-digger/](https://www.zaproxy.org/docs/desktop/addons/parameter-digger/).'
  prefs: []
  type: TYPE_NORMAL
